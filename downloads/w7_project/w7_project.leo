<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20220407133244.1"><vh>@settings</vh>
<v t="leo.20220407133244.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20220407133244.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20220407134316.1"><vh>readme</vh>
<v t="leo.20220407135400.1"><vh>compilation</vh></v>
</v>
<v t="leo.20220407134541.1"><vh>repo</vh>
<v t="leo.20220407133128.2"><vh>@path scarysim</vh>
<v t="leo.20220407133901.1"><vh>importer</vh></v>
</v>
</v>
<v t="leo.20220407134416.2"><vh>@path scarysim</vh>
<v t="leo.20220407142040.1"><vh>@edit scarysim.bat</vh></v>
<v t="leo.20220407141349.1"><vh>@edit scarysim.pro</vh></v>
<v t="leo.20220407141832.1"><vh>@edit Makefile.Release</vh></v>
<v t="leo.20220407134416.3"><vh>@clean glwidget.cpp</vh>
<v t="leo.20220407134416.4"><vh>void GLWidget::initializeGL (glwidget.cpp)</vh></v>
<v t="leo.20220407134416.5"><vh>void GLWidget::paintGL (glwidget.cpp)</vh></v>
<v t="leo.20220407134416.6"><vh>void GLWidget::resizeGL (glwidget.cpp)</vh></v>
<v t="leo.20220407134416.7"><vh>void GLWidget::setPitch (glwidget.cpp)</vh></v>
<v t="leo.20220407134416.8"><vh>void GLWidget::setYaw (glwidget.cpp)</vh></v>
<v t="leo.20220407134416.9"><vh>void GLWidget::setDistance (glwidget.cpp)</vh></v>
<v t="leo.20220407134416.10"><vh>void GLWidget::setView (glwidget.cpp)</vh></v>
<v t="leo.20220407134416.11"><vh>void GLWidget::setLight (glwidget.cpp)</vh></v>
</v>
<v t="leo.20220407134416.12"><vh>@clean main.cpp</vh>
<v t="leo.20220407134416.13"><vh>int main (main.cpp)</vh></v>
</v>
<v t="leo.20220407134416.14"><vh>@clean mainwindow.cpp</vh>
<v t="leo.20220407134416.15"><vh>void MainWindow::go (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.16"><vh>void MainWindow::on_verticalSliderPitch_valueChanged (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.17"><vh>void MainWindow::on_horizontalSliderYaw_valueChanged (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.18"><vh>void MainWindow::on_horizontalSliderTh1_valueChanged (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.19"><vh>void MainWindow::on_horizontalSliderTh2_valueChanged (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.20"><vh>void MainWindow::on_horizontalSliderZ_valueChanged (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.21"><vh>void MainWindow::on_commandLinkButtonGo_clicked (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.22"><vh>void MainWindow::on_radioButtonSimple_clicked (mainwindow.cpp)</vh></v>
<v t="leo.20220407134416.23"><vh>void MainWindow::on_radioButtonTarget_clicked (mainwindow.cpp)</vh></v>
</v>
<v t="leo.20220407134416.24"><vh>@clean model.cpp</vh>
<v t="leo.20220407134416.25"><vh>void replace (model.cpp)</vh></v>
<v t="leo.20220407134416.26"><vh>void Model::load (model.cpp)</vh></v>
<v t="leo.20220407134416.27"><vh>void Model::load_materials (model.cpp)</vh></v>
<v t="leo.20220407134416.28"><vh>void Model::display (model.cpp)</vh></v>
</v>
<v t="leo.20220407134416.29"><vh>@clean scara.cpp</vh>
<v t="leo.20220407134416.30"><vh>void Scara::go (scara.cpp)</vh></v>
<v t="leo.20220407134416.31"><vh>void Scara::displayPath (scara.cpp)</vh></v>
<v t="leo.20220407134416.32"><vh>void Scara::display (scara.cpp)</vh></v>
<v t="leo.20220407134416.33"><vh>void Scara::setTh1 (scara.cpp)</vh></v>
<v t="leo.20220407134416.34"><vh>void Scara::setTh2 (scara.cpp)</vh></v>
<v t="leo.20220407134416.35"><vh>void Scara::setZ (scara.cpp)</vh></v>
<v t="leo.20220407134416.36"><vh>void Scara::setMode (scara.cpp)</vh></v>
<v t="leo.20220407134416.37"><vh>void Scara::setTarget (scara.cpp)</vh></v>
<v t="leo.20220407134416.38"><vh>void Scara::kinPr (scara.cpp)</vh></v>
<v t="leo.20220407134416.39"><vh>void Scara::kinOdwr (scara.cpp)</vh></v>
<v t="leo.20220407134416.40"><vh>bool Scara::calcSpeed (scara.cpp)</vh></v>
</v>
</v>
<v t="leo.20220412140946.1"><vh>編譯 simExtMtb</vh></v>
<v t="leo.20220407134651.2"><vh>@path simExtMtb</vh>
<v t="leo.20220407134651.3"><vh>@clean simExtMTB.cpp</vh>
<v t="leo.20220407134651.4"><vh>int getServerIndexFromServerHandle (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.5"><vh>int getServerIndexFromScriptHandle (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.6"><vh>void removeOutputInputConnection (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.7"><vh>void updateInputsFromConnections (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.8"><vh>void updateAllInputs (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.9"><vh>bool addOutputInputConnection (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.10"><vh>int inArgs_START_SERVER (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.11"><vh>void LUA_START_SERVER_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.12"><vh>int inArgs_STOP_SERVER (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.13"><vh>void LUA_STOP_SERVER_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.14"><vh>int inArgs_STEP (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.15"><vh>void LUA_STEP_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.16"><vh>int inArgs_GET_JOINTS (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.17"><vh>void LUA_GET_JOINTS_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.18"><vh>int inArgs_GET_OUTPUT (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.19"><vh>void LUA_GET_OUTPUT_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.20"><vh>int inArgs_GET_INPUT (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.21"><vh>void LUA_GET_INPUT_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.22"><vh>int inArgs_SET_INPUT (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.23"><vh>void LUA_SET_INPUT_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.24"><vh>int inArgs_CONNECT_INPUT (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.25"><vh>void LUA_CONNECT_INPUT_CALLBACK (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.26"><vh>int inArgs_DISCONNECT_INPUT (simExtMTB.cpp)</vh></v>
<v t="leo.20220407134651.27"><vh>void LUA_DISCONNECT_INPUT_CALLBACK (simExtMTB.cpp)</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20220407133128.2"></t>
<t tx="leo.20220407133244.1"></t>
<t tx="leo.20220407133244.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20220407133244.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20220407133901.1">'''Recursively import all python files in a directory and clean the result.'''
 
c.recursiveImport(
    dir_ = r'./',
    kind = '@clean', 
    safe_at_file = False,
    theTypes =  ['.cpp']
)</t>
<t tx="leo.20220407134316.1">importer 執行必須滑鼠停在節點上, 然後按下 ctrl + b

'''Recursively import all python files in a directory and clean the result.'''
 
c.recursiveImport(
    dir_ = r'./',
    kind = '@clean', 
    safe_at_file = False,
    theTypes =  ['.py']
)</t>
<t tx="leo.20220407134416.10">void GLWidget::setView()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1.0*w/h, 0.1, 100.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    gluLookAt(-distance, 0.0, 0.0,
              0.0, 0.0, 0.0,
              0.0, 0.0, 1.0);
    glRotatef(pitch, 0.0, -1.0, 0.0);
    glRotatef(yaw, 0.0, 0.0, -1.0);
}

</t>
<t tx="leo.20220407134416.11">void GLWidget::setLight()
{
    GLfloat lamb[] = { 0.1, 0.1, 0.1, 1.0 };
    GLfloat ldif[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat lpos[] = { -10.0, -10.0, 10.0, 1.0 };

    glEnable(GL_COLOR_MATERIAL);
    glDisable(GL_LIGHTING);
    glDisable(GL_LIGHT0);
    glColor4fv(ldif);
    glBegin(GL_POINTS);
        glVertex4fv(lpos);
    glEnd();

    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT0, GL_POSITION, lpos);
    glLightfv(GL_LIGHT0, GL_AMBIENT, lamb);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, ldif);
}
</t>
<t tx="leo.20220407134416.12">@path ./
#include &lt;QtWidgets/QApplication&gt;
#include "mainwindow.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407134416.13">int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();

    return a.exec();
}
</t>
<t tx="leo.20220407134416.14">@path ./
#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow),
    dt(0.0)
{
    ui-&gt;setupUi(this);

    connect(&amp;tmr, SIGNAL(timeout()), this, SLOT(go()));
    tmr.setInterval(0);
    tmr.start();

    robot = new Scara(this);

    clk = clock();
}

MainWindow::~MainWindow()
{
    delete ui;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407134416.15">void MainWindow::go()
{
    dt = 1.0 * (clock() - clk) / CLOCKS_PER_SEC;
    clk = clock();
    t += dt;

    robot-&gt;go(dt);

    bool mode = ui-&gt;radioButtonTarget-&gt;isChecked();

    QString text;

    text.sprintf("%.3f", robot-&gt;getTh1());
    ui-&gt;labelTh1-&gt;setText(text);

    text.sprintf("%.3f", robot-&gt;getTh2());
    ui-&gt;labelTh2-&gt;setText(text);

    text.sprintf("%.3f", robot-&gt;getZ());
    ui-&gt;labelThZ-&gt;setText(text);

    text.sprintf("%.3f", robot-&gt;getY());
    ui-&gt;labelY-&gt;setText(text);

    text.sprintf("%.3f", robot-&gt;getX());
    ui-&gt;labelX-&gt;setText(text);

    text.sprintf("%.3f", robot-&gt;getY());
    ui-&gt;labelY-&gt;setText(text);

    text.sprintf("%.3f", robot-&gt;getZ());
    ui-&gt;labelZ-&gt;setText(text);

    if(mode) {
        ui-&gt;horizontalSliderTh1-&gt;setValue(robot-&gt;getTh1());
        ui-&gt;horizontalSliderTh2-&gt;setValue(robot-&gt;getTh2());
        ui-&gt;horizontalSliderZ-&gt;setValue(100.0*robot-&gt;getZ());
    }

    ui-&gt;view-&gt;updateGL();
}

</t>
<t tx="leo.20220407134416.16">void MainWindow::on_verticalSliderPitch_valueChanged(int value)
{
    ui-&gt;view-&gt;setPitch(value);
}

</t>
<t tx="leo.20220407134416.17">void MainWindow::on_horizontalSliderYaw_valueChanged(int value)
{
    ui-&gt;view-&gt;setYaw(value);
}

</t>
<t tx="leo.20220407134416.18">void MainWindow::on_horizontalSliderTh1_valueChanged(int value)
{
    mode = ui-&gt;radioButtonTarget-&gt;isChecked();

    if(!mode) robot-&gt;setTh1(value);
}

</t>
<t tx="leo.20220407134416.19">void MainWindow::on_horizontalSliderTh2_valueChanged(int value)
{
    mode = ui-&gt;radioButtonTarget-&gt;isChecked();

    if(!mode) robot-&gt;setTh2(value);
}

</t>
<t tx="leo.20220407134416.2"></t>
<t tx="leo.20220407134416.20">void MainWindow::on_horizontalSliderZ_valueChanged(int value)
{
    mode = ui-&gt;radioButtonTarget-&gt;isChecked();

    if(!mode) robot-&gt;setZ(0.01 * value);
}

</t>
<t tx="leo.20220407134416.21">void MainWindow::on_commandLinkButtonGo_clicked()
{
    robot-&gt;setTarget(ui-&gt;lineEditTx-&gt;text().toDouble(), ui-&gt;lineEditTy-&gt;text().toDouble(), ui-&gt;lineEditTz-&gt;text().toDouble());
}

</t>
<t tx="leo.20220407134416.22">void MainWindow::on_radioButtonSimple_clicked()
{
    robot-&gt;setMode(SIMPLE);

    ui-&gt;groupBoxSimple-&gt;setEnabled(true);
    ui-&gt;groupBoxTarget-&gt;setDisabled(true);
}

</t>
<t tx="leo.20220407134416.23">void MainWindow::on_radioButtonTarget_clicked()
{
    robot-&gt;setMode(TARGET);

    ui-&gt;groupBoxSimple-&gt;setDisabled(true);
    ui-&gt;groupBoxTarget-&gt;setEnabled(true);
}
</t>
<t tx="leo.20220407134416.24">@path ./
#include "model.h"

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;QString&gt;
#include &lt;QFileInfo&gt;

Model::Model(QObject *parent) :
    QObject(parent)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407134416.25">void replace(std::string &amp;str, const char from, const char to)
{
    std::string::iterator i;
    for(i = str.begin(); i &lt; str.end(); ++i)
        if(*i == from) *i = to;
}

</t>
<t tx="leo.20220407134416.26">void Model::load(const char *filename)
{
    std::cout &lt;&lt; "Loading obj\n";

    //wyczysc
    materials.clear();
    vertex.clear();
    faces.clear();
    normals.clear();

    std::ifstream file(filename);

    if(!file) {
        std::cout &lt;&lt; "Obj file not found\n";
        exit(-1);
    }

    std::string s;
    int current_material = -1;

    while(getline(file, s)) {
        std::stringstream sstr;

        replace(s, '/', ' ');
        sstr &lt;&lt; s;

        std::string cmd;
        sstr &gt;&gt; cmd;

        if(cmd == "mtllib") {
            sstr &gt;&gt; matfile;

            std::cout &lt;&lt; matfile &lt;&lt; "\n";

            load_materials();
        }

        if(cmd == "v") {
            Vertex vtx;

            sstr &gt;&gt; vtx.x[0] &gt;&gt; vtx.x[1] &gt;&gt; vtx.x[2];

            //vtx.x[1] *= -1; //odwroc y

            vertex.push_back(vtx);
        }

        if(cmd == "vn") {
            Vertex nrm;

            sstr &gt;&gt; nrm.x[0] &gt;&gt; nrm.x[1] &gt;&gt; nrm.x[2];

            for(int i = 0; i &lt; 3; nrm.x[i++] *= -1);
            nrm.x[0] *= -1; //odwroc normale
            nrm.x[1] *= -1;
            nrm.x[2] *= -1;

            normals.push_back(nrm);
        }

        if(cmd == "f") {
            Face face;

            for(int i = 0; i &lt; 3; ++i) {
                sstr &gt;&gt; face.vertex[i] &gt;&gt; face.normal;
            }

            face.material = current_material;

            faces.push_back(face);
       }

       if(cmd == "usemtl") {
            std::string matname;
            sstr &gt;&gt; matname;

            // znajdz numer materialu
            int i = 0;
            for(; i &lt; materials.size(); ++i) {
                if(matname == materials[i].name) break;
            }

            current_material = i;
        }
    }

    file.close();

    std::cout &lt;&lt; "Obj loaded\n";
}

</t>
<t tx="leo.20220407134416.27">void Model::load_materials()
{
    std::cout &lt;&lt; "Loading materials: " &lt;&lt; matfile.c_str() &lt;&lt; "\n";

    std::ifstream file(matfile.c_str());

    if(!file) {
        std::cout &lt;&lt; "Mat file not found\n";
        exit(-1);
    }

    std::string line;
    Material nmat;

    while(getline(file, line)) {
        std::stringstream sstr;
        sstr &lt;&lt; line;

        std::string cmd;
        sstr &gt;&gt; cmd;

        if(cmd == "newmtl") {
            sstr &gt;&gt; nmat.name;
        }

        if(cmd == "Ns") {
            sstr &gt;&gt; nmat.shininess;
        }

        if(cmd == "Ka") {
            sstr &gt;&gt; nmat.ambient[0] &gt;&gt; nmat.ambient[1] &gt;&gt; nmat.ambient[2];
        }

        if(cmd == "Kd") {
            sstr &gt;&gt; nmat.diffuse[0] &gt;&gt; nmat.diffuse[1] &gt;&gt; nmat.diffuse[2];
        }

        if(cmd == "Ks") {
            sstr &gt;&gt; nmat.specular[0] &gt;&gt; nmat.specular[1] &gt;&gt; nmat.specular[2];
        }

        if(cmd == "d") {
            float alpha;
            sstr &gt;&gt; alpha;
            nmat.ambient[3] = alpha;
            nmat.diffuse[3] = alpha;
            nmat.specular[3] = alpha;
        }

        // illum bo akurat program konczy blok tym i nie ma oprocz tego zadnego znaczenia
        if(cmd == "illum") {
            materials.push_back(nmat);
        }
    }

    file.close();

    std::cout &lt;&lt; "Materials loaded\n";
}

</t>
<t tx="leo.20220407134416.28">void Model::display()
{
    //std::cout &lt;&lt; "display()\n";

    GLfloat emiss[4] = { 0.0, 0.0, 0.0, 0.0 };

    glBegin(GL_TRIANGLES);

    int current_material = -1;

    std::vector&lt;Face&gt;::iterator i;
    for(i = faces.begin(); i &lt; faces.end(); ++i) {
        // jaki material?
        int mat = (*i).material;

        if(current_material != mat) { // ustaw nowe parametry tylko kiedy nastepuje zmiana materialu
            Material m = materials[mat];

            glEnd();
            glMaterialfv(GL_FRONT, GL_AMBIENT, m.diffuse);
            glMaterialfv(GL_FRONT, GL_DIFFUSE, m.diffuse);
            glMaterialfv(GL_FRONT, GL_SPECULAR, m.specular);
            glMaterialfv(GL_FRONT, GL_EMISSION, emiss);
            glMaterialfv(GL_FRONT, GL_SHININESS, &amp;m.shininess);

            current_material = mat;
            glBegin(GL_TRIANGLES);
        }

        int n_normal = (*i).normal - 1;

        glNormal3fv(normals[n_normal].x);
        for(int j = 0; j &lt; 3; ++j) {
            int n_vtx = (*i).vertex[j] - 1;
            glVertex3fv(vertex[n_vtx].x);
        }
    }
    glEnd();
}
</t>
<t tx="leo.20220407134416.29">@path ./
#include "scara.h"

#include &lt;iostream&gt;

Scara *robot;

Scara::Scara(QObject *parent) :
    QObject(parent),
    th1(0.0), th2(90.0), z(0.0),
    dth1(0.0), dth2(0.0), dz(0.0),
    posx(0.0), posy(0.0), posz(0.0),
    tx(1.0), ty(1.0), tz(0.0),
    mode(SIMPLE),
    r1(1.5), r2(1.5)
{
    baseModel.load("base.obj");
    arm1Model.load("arm1.obj");
    arm2Model.load("arm2.obj");
    arm3Model.load("arm3.obj");

    kinPr();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407134416.3">@path ./
#include "glwidget.h"

#include &lt;GL/glu.h&gt;

GLWidget::GLWidget(QWidget *parent) :
    QGLWidget(parent),
    pitch(30.0), yaw(0.0), distance(7.0)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407134416.30">void Scara::go(double dt)
{
    if(mode == TARGET) {
        double rx = tx - posx;
        double ry = ty - posy;
        double rz = tz - posz;

        double vmax = 0.5;

        double v = sqrt(rx*rx + ry*ry + rz*rz);
        rx *= vmax/v;
        ry *= vmax/v;
        rz *= vmax/v;

        calcSpeed(rx, ry, rz);
    } else {
        dth1 = 0.0;
        dth2 = 0.0;
        dz = 0.0;
    }

    th1 += dt * dth1;
    th2 += dt * dth2;
    z += dt * dz;

    if(th1 &gt; 180.0) th1 -= 360.0;
    if(th1 &lt; -180.0) th1 += 360.0;
    if(th2 &gt; 180.0) th2 -= 360.0;
    if(th2 &lt; -180.0) th2 += 360.0;

    if(z &lt; 0.0) z = 0.0;
    if(z &gt; 0.5) z = 0.5;

    kinPr();

    PathPoint p = { posx, posy, posz };
    path.push_back(p);

    if(path.size() &gt; 10000) path.erase(path.begin());
}

</t>
<t tx="leo.20220407134416.31">void Scara::displayPath()
{
    std::vector&lt;PathPoint&gt;::iterator i;
    glBegin(GL_LINE_STRIP);
        for(i = path.begin(); i &lt; path.end(); ++i)
            glVertex3f(i-&gt;y, -i-&gt;x, i-&gt;z+0.5);
    glEnd();
}

</t>
<t tx="leo.20220407134416.32">void Scara::display()
{
    baseModel.display();

    glTranslatef(0.0, 0.0, 0.9);
    glRotatef(th1, 0.0, 0.0, 1.0);
    arm1Model.display();

    glTranslatef(0.0, -r1, 0.1);
    glRotatef(th2, 0.0, 0.0, 1.0);
    arm2Model.display();

    glTranslatef(0.0, -r2, -0.5 + z);
    arm3Model.display();
}

double Scara::getTh1()
{
    return th1;
}

double Scara::getTh2()
{
    return th2;
}

double Scara::getX()
{
    return posx;
}

double Scara::getY()
{
    return posy;
}

double Scara::getZ()
{
    return posz;
}

</t>
<t tx="leo.20220407134416.33">void Scara::setTh1(double _th1)
{
    th1 = _th1;

    kinPr();
}

</t>
<t tx="leo.20220407134416.34">void Scara::setTh2(double _th2)
{
    th2 = _th2;

    kinPr();
}

</t>
<t tx="leo.20220407134416.35">void Scara::setZ(double _z)
{
    z = _z;

    kinPr();
}

</t>
<t tx="leo.20220407134416.36">void Scara::setMode(SteeringMode _mode)
{
    mode = _mode;
}

</t>
<t tx="leo.20220407134416.37">void Scara::setTarget(double _tx, double _ty, double _tz)
{
    tx = _tx;
    ty = _ty;
    tz = _tz;
}

</t>
<t tx="leo.20220407134416.38">void Scara::kinPr()
{
    posx = r1 * cos(M_PI*th1/180.0) + r2 * cos(M_PI*(th1+th2)/180.0);
    posy = r1 * sin(M_PI*th1/180.0) + r2 * sin(M_PI*(th1+th2)/180.0);
    posz = z;
}

</t>
<t tx="leo.20220407134416.39">void Scara::kinOdwr()
{

}

</t>
<t tx="leo.20220407134416.4">void GLWidget::initializeGL()
{
    glEnable(GL_DEPTH_TEST);
    glClearDepth(1.0);

    glEnable(GL_CULL_FACE);

    glEnable(GL_POINT_SMOOTH);
    glPointSize(10.0);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

    glClearColor(0.0, 0.0, 0.0, 0.0);
}

</t>
<t tx="leo.20220407134416.40">bool Scara::calcSpeed(double vx, double vy, double vz)
{
    double sth1 = sin(M_PI*th1/180.0);
    double cth1 = cos(M_PI*th1/180.0);
    double sth12 = sin(M_PI*(th1+th2)/180.0);
    double cth12 = cos(M_PI*(th1+th2)/180.0);

    double det = (-r1*sth1-r2*sth12) * (r2*cth12) + (r2*sth12) * (r1*cth1+r2*cth12);

    if(!det) {
        dth1 = 0.0;
        dth2 = 0.0;
        dz = 0.0;

        return false;
    }

    //std::cout &lt;&lt; det &lt;&lt; '\n';

    double t11 = r2*cth12/det;
    double t12 = r2*sth12/det;
    double t21 = -(r1*cth1+r2*cth12)/det;
    double t22 = -(r1*sth1+r2*sth12)/det;

    dth1 = t11*vx + t12*vy;
    dth2 = t21*vx + t22*vy;
    dz = vz;

    dth1 *= 180.0/M_PI;
    dth2 *= 180.0/M_PI;

    return true;
}
</t>
<t tx="leo.20220407134416.5">void GLWidget::paintGL()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    setView();
    setLight();

    glEnable(GL_COLOR_MATERIAL);
    glDisable(GL_LIGHTING);

    glColor4f(0.0, 0.5, 0.0, 0.5);
    for(int i = 0; i &lt;= 20; ++i) {
        glBegin(GL_LINES);
            glVertex3f(-5.0+0.5*i, -5.0, 0.0); glVertex3f(-5.0+0.5*i, 5.0, 0.0);
            glVertex3f(-5.0, -5.0+0.5*i, 0.0); glVertex3f(5.0, -5.0+0.5*i, 0.0);
        glEnd();
    }
    glColor4f(0.5, 0.5, 0.0, 0.5);
    glBegin(GL_LINES);
        glVertex3f(robot-&gt;getY(), -robot-&gt;getX(), 0.0); glVertex3f(robot-&gt;getY(), -robot-&gt;getX(), robot-&gt;getZ()+0.5);
    glEnd();

    glColor4f(0.9, 0.0, 0.0, 0.5);
    robot-&gt;displayPath();

    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);

    robot-&gt;display();

    glFlush();
}

</t>
<t tx="leo.20220407134416.6">void GLWidget::resizeGL(int _w, int _h)
{
    w = _w; h = _h;

    glViewport(0.0, 0.0, w, h);

    setView();
}

</t>
<t tx="leo.20220407134416.7">void GLWidget::setPitch(double _pitch)
{
    pitch = _pitch;
}

</t>
<t tx="leo.20220407134416.8">void GLWidget::setYaw(double _yaw)
{
    yaw = _yaw;
}

</t>
<t tx="leo.20220407134416.9">void GLWidget::setDistance(double _distance)
{
    distance = _distance;
}

</t>
<t tx="leo.20220407134541.1"></t>
<t tx="leo.20220407134651.10">const int inArgs_START_SERVER[]={
    5,
    sim_script_arg_string,0,
    sim_script_arg_int32,0,
    sim_script_arg_charbuff,0,
    sim_script_arg_float|sim_script_arg_table,4,
    sim_script_arg_float|sim_script_arg_table,2,
};

</t>
<t tx="leo.20220407134651.11">void LUA_START_SERVER_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    int handle=-1; // means error
    std::string msg("Problem launching or communicating with the MTB server.");
    if (D.readDataFromStack(p-&gt;stackID,inArgs_START_SERVER,inArgs_START_SERVER[0],LUA_START_SERVER_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        std::string mtbServerExecutableName(inData-&gt;at(0).stringData[0]);
        int portNumber=inData-&gt;at(1).int32Data[0];
        std::string arguments(boost::lexical_cast&lt;std::string&gt;(portNumber));
        std::string program(inData-&gt;at(2).stringData[0]);

        #ifdef QT_COMPIL
            QString cmd;
            if (mtbServerExecutableName.find('/')==std::string::npos)
                cmd="./";
            cmd+=QString(mtbServerExecutableName.c_str());
            QStringList strList;
            strList &lt;&lt; QString(arguments.c_str());
            QProcess::startDetached(cmd,strList,QString(currentDirAndPath.c_str()),NULL);
            #ifdef _WIN32
                Sleep(1000);
            #else
                sleep(1);
            #endif
        #else
            #ifdef _WIN32
                ShellExecuteA(NULL,"open",mtbServerExecutableName.c_str(),arguments.c_str(),NULL,SW_SHOWDEFAULT);
                Sleep(1000);
            #else
                pid_t pid=fork();
                if (pid==0)
                {
                    execl(mtbServerExecutableName.c_str(),mtbServerExecutableName.c_str(),inData-&gt;at(0).stringData[0].c_str(),inData-&gt;at(1).stringData[0].c_str(),boost::lexical_cast&lt;std::string&gt;(inData-&gt;at(2).int32Data[0]).c_str(), (char*) 0);
                    exit(0);
                }
                sleep(1);
            #endif
        #endif
        
        CSocketOutConnection* connection=new CSocketOutConnection("127.0.0.1",portNumber);
        if (connection-&gt;connectToServer()==1)
        { // we could connect!
            // Now send the program and initial values to the server:
            std::string dat(25,0);
            dat[0]=0; // compile command
            for (unsigned int i=0;i&lt;4;i++)
                ((float*)(&amp;dat[1+i*4]))[0]=inData-&gt;at(3).floatData[i];
            for (unsigned int i=0;i&lt;2;i++)
                ((float*)(&amp;dat[1+16+i*4]))[0]=inData-&gt;at(4).floatData[i];
            dat.insert(dat.end(),program.begin(),program.end());
            if (connection-&gt;sendData(&amp;dat[0],int(dat.size())))
            { // send was successful
                // Now wait for the status reply:
                int dataSize;
                char* data=connection-&gt;receiveReplyData(dataSize);
                if (dataSize&gt;0)
                { // data reception was ok!
                    if (dataSize==2)
                    { // ok, the program was correctly compiled
                        handle=nextMtbServerHandle++;
                        sMtbServer server;
                        server.connection=connection;
                        server.mtbServerHandle=handle;
                        server.scriptHandle=p-&gt;scriptID;
                        for (unsigned int i=0;i&lt;4;i++)
                            server.jointPositions[i]=inData-&gt;at(3).floatData[i];
                        for (unsigned int i=0;i&lt;4;i++)
                        {
                            server.robotInput[i]=0;
                            server.robotOutput[i]=0;
                        }
                        allMtbServers.push_back(server);
                        updateAllInputs();
                    }
                    else
                    { // there was a problem. Return the error string:
                        msg=std::string(data+1);
                        delete connection;
                    }
                    delete[] data;
                }
                else
                {
                    delete connection;
                    simSetLastError(LUA_START_SERVER_COMMAND,"Failed to receive data from the MTB server.");
                }
            }
            else
            {
                delete connection;
                simSetLastError(LUA_START_SERVER_COMMAND,"Failed to send data to the MTB server.");
            }
        }
        else
        {
            delete connection;
            simSetLastError(LUA_START_SERVER_COMMAND,"Failed to start or connect to MTB server.");
        }
            
    }
    else
        msg="Wrong or missing arguments.";
    D.pushOutData(CScriptFunctionDataItem(handle));
    if (handle&lt;0)
        D.pushOutData(CScriptFunctionDataItem(msg));
    else
        D.pushOutData(CScriptFunctionDataItem(""));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------
// simExtMtb_stopServer
// --------------------------------------------------------------------------------------
#define LUA_STOP_SERVER_COMMAND "simMTB.stopServer"

</t>
<t tx="leo.20220407134651.12">const int inArgs_STOP_SERVER[]={
    1,
    sim_script_arg_int32,0,
};

</t>
<t tx="leo.20220407134651.13">void LUA_STOP_SERVER_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    bool success=false;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_STOP_SERVER,inArgs_STOP_SERVER[0],LUA_STOP_SERVER_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int serverHandle=inData-&gt;at(0).int32Data[0];
        int index=getServerIndexFromServerHandle(serverHandle);
        if (index!=-1)
        {
            delete allMtbServers[index].connection;
            allMtbServers.erase(allMtbServers.begin()+index);
            updateAllInputs();
            success=true;
        }
        else
            simSetLastError(LUA_STOP_SERVER_COMMAND,"Invalid MTB server handle.");
    }
    D.pushOutData(CScriptFunctionDataItem(success));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// simExtMtb_step
// --------------------------------------------------------------------------------------
#define LUA_STEP_COMMAND "simMTB.step"

</t>
<t tx="leo.20220407134651.14">const int inArgs_STEP[]={
    2,
    sim_script_arg_int32,0,
    sim_script_arg_float,0,
};

</t>
<t tx="leo.20220407134651.15">void LUA_STEP_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    std::string msg("Invalid MTB server handle, or problem communicating with the MTB server.");
    int result=-1;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_STEP,inArgs_STEP[0],LUA_STEP_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int serverHandle=inData-&gt;at(0).int32Data[0];
        float timeStep=inData-&gt;at(1).floatData[0];
        int index=getServerIndexFromServerHandle(serverHandle);
        if (index!=-1)
        {
            // Now send the data to the server:
            std::string dat(9,0);
            dat[0]=1; // step command
            dat[1]=allMtbServers[index].robotInput[0];
            dat[2]=allMtbServers[index].robotInput[1];
            dat[3]=allMtbServers[index].robotInput[2];
            dat[4]=allMtbServers[index].robotInput[3];
            ((float*)&amp;dat[5])[0]=timeStep;
            if (allMtbServers[index].connection-&gt;sendData(&amp;dat[0],int(dat.size())))
            { // send was successful
                // Now wait for the status reply:
                int dataSize;
                char* data=allMtbServers[index].connection-&gt;receiveReplyData(dataSize);
                if (dataSize&gt;=22)
                { // data reception was ok!
                    for (unsigned int i=0;i&lt;4;i++)
                        allMtbServers[index].jointPositions[i]=((float*)(data+1))[i];
                    for (unsigned int i=0;i&lt;4;i++)
                        allMtbServers[index].robotOutput[i]=data[1+16+i];
                    updateAllInputs();
                    msg=std::string(data+1+16+4);
                    if (msg.length()!=0)
                        result=0; // program not yet finished
                    else
                        result=1; // program finished

                    delete[] data;
                }
                else
                    simSetLastError(LUA_STEP_COMMAND,"Failed to receive data from the MTB server.");
            }
            else
                simSetLastError(LUA_STEP_COMMAND,"Failed to send data to the MTB server.");
        }
        else
            simSetLastError(LUA_STEP_COMMAND,"Invalid MTB server handle.");
    }
    else
        msg="Wrong or missing arguments.";
    D.pushOutData(CScriptFunctionDataItem(result));
    D.pushOutData(CScriptFunctionDataItem(msg));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// simExtMtb_getJoints
// --------------------------------------------------------------------------------------
#define LUA_GET_JOINTS_COMMAND "simMTB.getJoints"

</t>
<t tx="leo.20220407134651.16">const int inArgs_GET_JOINTS[]={
    1,
    sim_script_arg_int32,0,
};

</t>
<t tx="leo.20220407134651.17">void LUA_GET_JOINTS_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    std::vector&lt;float&gt; joints;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_GET_JOINTS,inArgs_GET_JOINTS[0],LUA_GET_JOINTS_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int serverHandle=inData-&gt;at(0).int32Data[0];
        int index=getServerIndexFromServerHandle(serverHandle);
        if (index!=-1)
        {
            for (unsigned int i=0;i&lt;4;i++)
                joints.push_back(allMtbServers[index].jointPositions[i]);
        }
        else
            simSetLastError(LUA_GET_JOINTS_COMMAND,"Invalid MTB server handle.");
    }
    if (joints.size()!=0)
        D.pushOutData(CScriptFunctionDataItem(joints));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// simExtMtb_getOutput
// --------------------------------------------------------------------------------------
#define LUA_GET_OUTPUT_COMMAND "simMTB.getOutput"

</t>
<t tx="leo.20220407134651.18">const int inArgs_GET_OUTPUT[]={
    1,
    sim_script_arg_int32,0,
};

</t>
<t tx="leo.20220407134651.19">void LUA_GET_OUTPUT_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    std::vector&lt;int&gt; output;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_GET_OUTPUT,inArgs_GET_OUTPUT[0],LUA_GET_OUTPUT_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int serverHandle=inData-&gt;at(0).int32Data[0];
        int index=getServerIndexFromServerHandle(serverHandle);
        if (index!=-1)
        {
            for (unsigned int i=0;i&lt;4;i++)
                output.push_back(allMtbServers[index].robotOutput[i]);
        }
        else
            simSetLastError(LUA_GET_OUTPUT_COMMAND,"Invalid MTB server handle.");
    }
    if (output.size()!=0)
        D.pushOutData(CScriptFunctionDataItem(output));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// simExtMtb_getInput
// --------------------------------------------------------------------------------------
#define LUA_GET_INPUT_COMMAND "simMTB.getInput"

</t>
<t tx="leo.20220407134651.2"></t>
<t tx="leo.20220407134651.20">const int inArgs_GET_INPUT[]={
    1,
    sim_script_arg_int32,0,
};

</t>
<t tx="leo.20220407134651.21">void LUA_GET_INPUT_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    std::vector&lt;int&gt; input;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_GET_INPUT,inArgs_GET_INPUT[0],LUA_GET_INPUT_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int serverHandle=inData-&gt;at(0).int32Data[0];
        int index=getServerIndexFromServerHandle(serverHandle);
        if (index!=-1)
        {
            for (unsigned int i=0;i&lt;4;i++)
                input.push_back(allMtbServers[index].robotInput[i]);
        }
        else
            simSetLastError(LUA_GET_INPUT_COMMAND,"Invalid MTB server handle.");
    }
    if (input.size()!=0)
        D.pushOutData(CScriptFunctionDataItem(input));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// simExtMtb_setInput
// --------------------------------------------------------------------------------------
#define LUA_SET_INPUT_COMMAND "simMTB.setInput"

</t>
<t tx="leo.20220407134651.22">const int inArgs_SET_INPUT[]={
    2,
    sim_script_arg_int32,0,
    sim_script_arg_int32|sim_script_arg_table,4,
};

</t>
<t tx="leo.20220407134651.23">void LUA_SET_INPUT_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    bool result=false;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_SET_INPUT,inArgs_SET_INPUT[0],LUA_SET_INPUT_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int serverHandle=inData-&gt;at(0).int32Data[0];
        int index=getServerIndexFromServerHandle(serverHandle);
        if (index!=-1)
        {
            for (unsigned int i=0;i&lt;4;i++)
                allMtbServers[index].robotInput[i]=(unsigned char)inData-&gt;at(1).int32Data[i];
            updateAllInputs();
            result=true;
        }
        else
            simSetLastError(LUA_SET_INPUT_COMMAND,"Invalid MTB server handle.");
    }
    D.pushOutData(CScriptFunctionDataItem(result));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// simExtMtb_connectInput
// --------------------------------------------------------------------------------------
#define LUA_CONNECT_INPUT_COMMAND "simMTB.connectInput"

</t>
<t tx="leo.20220407134651.24">const int inArgs_CONNECT_INPUT[]={
    5,
    sim_script_arg_int32,0,
    sim_script_arg_int32,0,
    sim_script_arg_int32,0,
    sim_script_arg_int32,0,
    sim_script_arg_int32,0,
};

</t>
<t tx="leo.20220407134651.25">void LUA_CONNECT_INPUT_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    bool result=false;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_CONNECT_INPUT,inArgs_CONNECT_INPUT[0],LUA_CONNECT_INPUT_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int inputServerHandle=inData-&gt;at(0).int32Data[0];
        int inputIndex=getServerIndexFromServerHandle(inputServerHandle);
        int inputBits=inData-&gt;at(1).int32Data[0];
        int outputServerHandle=inData-&gt;at(2).int32Data[0];
        int outputIndex=getServerIndexFromServerHandle(outputServerHandle);
        int outputBits=inData-&gt;at(3).int32Data[0];
        int connectionType=inData-&gt;at(4).int32Data[0];
        if ((inputIndex!=-1)&amp;&amp;(outputIndex!=-1))
        {
            result=addOutputInputConnection(inputIndex,inputBits,outputIndex,outputBits,connectionType);        
            updateAllInputs();
        }
        else
            simSetLastError(LUA_CONNECT_INPUT_COMMAND,"Invalid MTB server handle.");
    }
    D.pushOutData(CScriptFunctionDataItem(result));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------
// simExtMtb_disconnectInput
// --------------------------------------------------------------------------------------
#define LUA_DISCONNECT_INPUT_COMMAND "simMTB.disconnectInput"

</t>
<t tx="leo.20220407134651.26">const int inArgs_DISCONNECT_INPUT[]={
    2,
    sim_script_arg_int32,0,
    sim_script_arg_int32,0,
};

</t>
<t tx="leo.20220407134651.27">void LUA_DISCONNECT_INPUT_CALLBACK(SScriptCallBack* p)
{
    CScriptFunctionData D;
    bool result=false;
    if (D.readDataFromStack(p-&gt;stackID,inArgs_DISCONNECT_INPUT,inArgs_DISCONNECT_INPUT[0],LUA_DISCONNECT_INPUT_COMMAND))
    {
        std::vector&lt;CScriptFunctionDataItem&gt;* inData=D.getInDataPtr();
        int inputServerHandle=inData-&gt;at(0).int32Data[0];
        int inputIndex=getServerIndexFromServerHandle(inputServerHandle);
        int inputBits=inData-&gt;at(1).int32Data[0];
        if (inputIndex!=-1)
        {
            removeOutputInputConnection(inputIndex,inputBits);
            updateAllInputs();
            result=true;
        }
        else
            simSetLastError(LUA_DISCONNECT_INPUT_COMMAND,"Invalid MTB server handle.");
    }
    D.pushOutData(CScriptFunctionDataItem(result));
    D.writeDataToStack(p-&gt;stackID);
}
// --------------------------------------------------------------------------------------

SIM_DLLEXPORT unsigned char simStart(void*,int)
{
    char curDirAndFile[1024];
#ifdef _WIN32
    #ifdef QT_COMPIL
        _getcwd(curDirAndFile, sizeof(curDirAndFile));
    #else
        GetModuleFileName(NULL,curDirAndFile,1023);
        PathRemoveFileSpec(curDirAndFile);
    #endif
#elif defined (__linux) || defined (__APPLE__)
    getcwd(curDirAndFile, sizeof(curDirAndFile));
#endif
    currentDirAndPath=curDirAndFile;

    std::string temp(currentDirAndPath);
#ifdef _WIN32
    temp+="\\coppeliaSim.dll";
#elif defined (__linux)
    temp+="/libcoppeliaSim.so";
#elif defined (__APPLE__)
    temp+="/libcoppeliaSim.dylib";
#endif 

    simLib=loadSimLibrary(temp.c_str());
    if (simLib==NULL)
    {
        printf("simExtMTB: error: could not find or correctly load the CoppeliaSim library. Cannot start the plugin.\n"); // cannot use simAddLog here.
        return(0); 
    }
    if (getSimProcAddresses(simLib)==0)
    {
        printf("simExtMTB: error: could not find all required functions in the CoppeliaSim library. Cannot start the plugin.\n"); // cannot use simAddLog here.
        unloadSimLibrary(simLib);
        return(0);
    }

    // Register the new functions:
    simRegisterScriptCallbackFunction(strConCat(LUA_START_SERVER_COMMAND,"@","MTB"),strConCat("int mtbServerHandle,string message=",LUA_START_SERVER_COMMAND,"(string mtbServerExecutable,int portNumber,charBuffer program,table_4 jointPositions, table_2 velocities)"),LUA_START_SERVER_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_STOP_SERVER_COMMAND,"@","MTB"),strConCat("bool result=",LUA_STOP_SERVER_COMMAND,"(int mtbServerHandle)"),LUA_STOP_SERVER_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_STEP_COMMAND,"@","MTB"),strConCat("int result,string message=",LUA_STEP_COMMAND,"(int mtbServerHandle,float timeStep)"),LUA_STEP_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_GET_JOINTS_COMMAND,"@","MTB"),strConCat("table_4 jointValues=",LUA_GET_JOINTS_COMMAND,"(int mtbServerHandle)"),LUA_GET_JOINTS_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_GET_OUTPUT_COMMAND,"@","MTB"),strConCat("table_4 outputValues=",LUA_GET_OUTPUT_COMMAND,"(int mtbServerHandle)"),LUA_GET_OUTPUT_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_GET_INPUT_COMMAND,"@","MTB"),strConCat("table_4 inputValues=",LUA_GET_INPUT_COMMAND,"(int mtbServerHandle)"),LUA_GET_INPUT_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_SET_INPUT_COMMAND,"@","MTB"),strConCat("bool result=",LUA_SET_INPUT_COMMAND,"(int mtbServerHandle,table_4 inputValues)"),LUA_SET_INPUT_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_CONNECT_INPUT_COMMAND,"@","MTB"),strConCat("bool result=",LUA_CONNECT_INPUT_COMMAND,"(int inputMtbServerHandle,int inputBitNumber,int outputMtbServerHandle,int outputBitNumber,int connectionType)"),LUA_CONNECT_INPUT_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_DISCONNECT_INPUT_COMMAND,"@","MTB"),strConCat("bool result=",LUA_DISCONNECT_INPUT_COMMAND,"(int inputMtbServerHandle,int inputBitNumber)"),LUA_DISCONNECT_INPUT_CALLBACK);

    // Following for backward compatibility:
    simRegisterScriptVariable(LUA_START_SERVER_COMMANDOLD,LUA_START_SERVER_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_START_SERVER_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_START_SERVER_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_STOP_SERVER_COMMANDOLD,LUA_STOP_SERVER_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_STOP_SERVER_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_STOP_SERVER_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_STEP_COMMANDOLD,LUA_STEP_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_STEP_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_STEP_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_GET_JOINTS_COMMANDOLD,LUA_GET_JOINTS_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_GET_JOINTS_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_GET_JOINTS_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_GET_OUTPUT_COMMANDOLD,LUA_GET_OUTPUT_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_GET_OUTPUT_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_GET_OUTPUT_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_GET_INPUT_COMMANDOLD,LUA_GET_INPUT_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_GET_INPUT_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_GET_INPUT_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_SET_INPUT_COMMANDOLD,LUA_SET_INPUT_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_SET_INPUT_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_SET_INPUT_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_CONNECT_INPUT_COMMANDOLD,LUA_CONNECT_INPUT_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_CONNECT_INPUT_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_CONNECT_INPUT_COMMAND," notation instead"),0);
    simRegisterScriptVariable(LUA_DISCONNECT_INPUT_COMMANDOLD,LUA_DISCONNECT_INPUT_COMMAND,-1);
    simRegisterScriptCallbackFunction(strConCat(LUA_DISCONNECT_INPUT_COMMANDOLD,"@","MTB"),strConCat("Please use the ",LUA_DISCONNECT_INPUT_COMMAND," notation instead"),0);

    return(PLUGIN_VERSION);
}

SIM_DLLEXPORT void simEnd()
{
    unloadSimLibrary(simLib);
}

SIM_DLLEXPORT void* simMessage(int message,int* auxiliaryData,void*,int*)
{
    void* retVal=NULL;

    if (message==sim_message_eventcallback_scriptstatedestroyed)
    { // script state was destroyed. Destroy all associated server instances:
        int index=getServerIndexFromScriptHandle(auxiliaryData[0]);
        while (index&gt;=0)
        {
            allMtbServers.erase(allMtbServers.begin()+index);
            index=getServerIndexFromScriptHandle(auxiliaryData[0]);
        }
    }

    return(retVal);
}

</t>
<t tx="leo.20220407134651.3">@path ./
#include "simExtMTB.h"
#include "simLib.h"
#include "scriptFunctionData.h"
#include "socketOutConnection.h"
#include &lt;iostream&gt;
#include &lt;boost/lexical_cast.hpp&gt;

#ifdef _WIN32
#ifdef QT_COMPIL
    #include &lt;direct.h&gt;
#else
    #include &lt;Shellapi.h&gt;
    #include &lt;shlwapi.h&gt;
    #pragma comment(lib, "Shlwapi.lib")
    #pragma comment(lib, "Shell32.lib")
#endif
#endif

#ifdef QT_COMPIL
    #include &lt;QString&gt;
    #include &lt;QProcess&gt;
#endif

#if defined (__linux) || defined (__APPLE__)
    #include &lt;unistd.h&gt;
    #define _stricmp(x,y) strcasecmp(x,y)
#endif

#define PLUGIN_VERSION 10
                // version 8 is after CoppeliaSim 3.3.0. Using stacks to exchange data with scripts.
                // version 9 is after CoppeliaSim 3.4.0. Using the new API notation.
                // version 10 is after CoppeliaSim 4.2.0.

#define CONCAT(x,y,z) x y z
#define strConCat(x,y,z)    CONCAT(x,y,z)

LIBRARY simLib;

struct sMtbServer
{
    CSocketOutConnection* connection;
    int mtbServerHandle;
    int scriptHandle;
    float jointPositions[4];
    unsigned char robotInput[4];
    unsigned char robotOutput[4];
    std::vector&lt;int&gt; inputOutputConnections; // indicates which input buffer bit is linked with what output buffer bit:
                                            // value[0+4*n] = input bit number (1-32) of this robot 
                                            // value[1+4*n] = handle of the server robot on which we want to connect an output
                                            // value[2+4*n] = output bit number (1-32) of the other robot (see above) 
                                            // value[3+4*n] = connection type (0=same, 1=inverted) 
};

std::vector&lt;sMtbServer&gt; allMtbServers;
int nextMtbServerHandle=0;
std::string currentDirAndPath;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407134651.4">int getServerIndexFromServerHandle(int serverHandle)
{
    for (unsigned int i=0;i&lt;allMtbServers.size();i++)
    {
        if (allMtbServers[i].mtbServerHandle==serverHandle)
            return(i);
    }
    return(-1);
}

</t>
<t tx="leo.20220407134651.5">int getServerIndexFromScriptHandle(int h)
{
    for (unsigned int i=0;i&lt;allMtbServers.size();i++)
    {
        if (allMtbServers[i].scriptHandle==h)
            return(i);
    }
    return(-1);
}

</t>
<t tx="leo.20220407134651.6">void removeOutputInputConnection(int inputIndex,int inputBit)
{
    if ((inputIndex&gt;=0)&amp;&amp;(inputIndex&lt;int(allMtbServers.size())))
    {
        if (inputBit==0)
            allMtbServers[inputIndex].inputOutputConnections.clear();
        else
        {
            for (unsigned int i=0;i&lt;allMtbServers[inputIndex].inputOutputConnections.size()/4;i++)
            {
                if (allMtbServers[inputIndex].inputOutputConnections[4*i+0]==inputBit)
                {
                    allMtbServers[inputIndex].inputOutputConnections.erase(allMtbServers[inputIndex].inputOutputConnections.begin()+4*i+0,allMtbServers[inputIndex].inputOutputConnections.begin()+4*i+4);
                    break;
                }
            }
        }
    }
}

</t>
<t tx="leo.20220407134651.7">void updateInputsFromConnections(int inputIndex)
{
    if ((inputIndex&gt;=0)&amp;&amp;(inputIndex&lt;int(allMtbServers.size())))
    {
        for (unsigned int i=0;i&lt;allMtbServers[inputIndex].inputOutputConnections.size()/4;i++)
        {
            int outputIndex=allMtbServers[inputIndex].inputOutputConnections[4*i+1];
            if ((outputIndex&gt;=0)&amp;&amp;(outputIndex&lt;int(allMtbServers.size())))
            {
                unsigned char otherRobotOutputData[4];
                for (int j=0;j&lt;4;j++)
                    otherRobotOutputData[j]=allMtbServers[outputIndex].robotOutput[j];

                int inBytePos=(allMtbServers[inputIndex].inputOutputConnections[4*i+0]-1)/8; // 0-3
                int inBitPos=(allMtbServers[inputIndex].inputOutputConnections[4*i+0]-1)%8; //0-7

                int outBytePos=(allMtbServers[inputIndex].inputOutputConnections[4*i+2]-1)/8; // 0-3
                int outBitPos=(allMtbServers[inputIndex].inputOutputConnections[4*i+2]-1)%8; //0-7

                bool setInputBit=false;
                if (otherRobotOutputData[outBytePos]&amp;(1&lt;&lt;outBitPos))
                    setInputBit=((1-allMtbServers[inputIndex].inputOutputConnections[4*i+3])!=0);
                else
                    setInputBit=(allMtbServers[inputIndex].inputOutputConnections[4*i+3]!=0);

                if (setInputBit)
                    allMtbServers[inputIndex].robotInput[inBytePos]|=(1&lt;&lt;inBitPos);
                else
                    allMtbServers[inputIndex].robotInput[inBytePos]&amp;=255-(1&lt;&lt;inBitPos);
            }
            else
            { // the other server robot was removed. We have to remove this output-input connection:
                allMtbServers[inputIndex].inputOutputConnections.erase(allMtbServers[inputIndex].inputOutputConnections.begin()+4*i+0,allMtbServers[inputIndex].inputOutputConnections.begin()+4*i+4);
                i--; // we have to reprocess this position in the for-loop!
            }
        }
    }
}

</t>
<t tx="leo.20220407134651.8">void updateAllInputs()
{ // Since each output can influence each input, and this cascaded, we call the update n*n times, where n is the number of servers
    for (unsigned int j=0;j&lt;allMtbServers.size();j++)
    {
        for (unsigned int i=0;i&lt;allMtbServers.size();i++)
            updateInputsFromConnections(i);
    }
}

</t>
<t tx="leo.20220407134651.9">bool addOutputInputConnection(int inputIndex,int inputBit,int outputIndex,int outputBit,int connectionType)
{
    if ((inputIndex&lt;0)||(inputIndex&gt;=int(allMtbServers.size())))
        return(false);
    if ((outputIndex&lt;0)||(outputIndex&gt;=int(allMtbServers.size())))
        return(false);
    if ( (inputBit&lt;1)||(inputBit&gt;32)||(outputBit&lt;1)||(outputBit&gt;32)||(connectionType&lt;0)||(connectionType&gt;1) )
        return(false);
    removeOutputInputConnection(inputIndex,inputBit);
    //4. Add the connection:
    allMtbServers[inputIndex].inputOutputConnections.push_back(inputBit);
    allMtbServers[inputIndex].inputOutputConnections.push_back(outputIndex);
    allMtbServers[inputIndex].inputOutputConnections.push_back(outputBit);
    allMtbServers[inputIndex].inputOutputConnections.push_back(connectionType);
    return(true);
}

// Follwing for backward compatibility:
#define LUA_START_SERVER_COMMANDOLD "simExtMtb_startServer"
#define LUA_STOP_SERVER_COMMANDOLD "simExtMtb_stopServer"
#define LUA_DISCONNECT_INPUT_COMMANDOLD "simExtMtb_disconnectInput"
#define LUA_CONNECT_INPUT_COMMANDOLD "simExtMtb_connectInput"
#define LUA_SET_INPUT_COMMANDOLD "simExtMtb_setInput"
#define LUA_GET_INPUT_COMMANDOLD "simExtMtb_getInput"
#define LUA_GET_OUTPUT_COMMANDOLD "simExtMtb_getOutput"
#define LUA_GET_JOINTS_COMMANDOLD "simExtMtb_getJoints"
#define LUA_STEP_COMMANDOLD "simExtMtb_step"


// --------------------------------------------------------------------------------------
// simExtMtb_startServer
// --------------------------------------------------------------------------------------
#define LUA_START_SERVER_COMMAND "simMTB.startServer"

</t>
<t tx="leo.20220407135400.1">設法以隨身程式系統編譯此程式碼:

    git clone https://github.com/mdecourse/scarysim.git
    修改 scarysim.pro, 蓋掉第 11 行, 成為 # LIBS     += -lglut -lGLU
    cd scarysim
    qmake -o Makefile scarysim.pro
    mingw32-make -f Makefile.Release 可以在 release 目錄取得 scarysim.exe
    因為 scarysim.exe 執行需要 base.obj, arm1.obj, arm2.obj, arm3.obj 等零件外型檔案, 以及對應的 .mtl 材質檔案, 因此可將 scarysim.exe 移至倉儲根目錄, 並且需要 msys64_20210419\mingw64\bin 路徑中的 dll 動態連結程式庫配合執行.
    由於此套程式碼在 Target 模式下, 零組件間會造成干涉, 表示其 Inverse Kinematic 運算並不正確, 請設法修正此錯誤後, 修改其零件尺寸與操作控制方法, 設法模擬 MTB 的 Pick and Place demo 範例.
    請各組指定組員分別利用 Solvespace、NX12、NX1980、NX2008 與 Onshape 繪製 Pick and Place demo 範例所需的零組件, 並完成 Coppeliasim 4.1.0、4.2.0 與 4.3.0 版的 MTB 機械手臂 Pick and Place 模擬, 完成後請說明在使用不同 MCAD 系統與版次的情況下, 該如何執行協同產品設計專案.
</t>
<t tx="leo.20220412140946.1">編譯 simExtMtb plugin:

https://github.com/CoppeliaRobotics/simExtMTB

針對 simExtMtb.pro:

    CoppeliaSim 4.1.0 原始碼編譯專案 (登入 @gm OneDrive 後下載).
    
    https://gmnfuedutw-my.sharepoint.com/:u:/g/personal/yen_gm_nfu_edu_tw/EccOQ_vbC2FAqk59lpm3sMIB8L7T9hc1wKbT3dkz5Aa9MA?e=dLP7ql
    
    E:\downloads\cop410\programming\simExtMTB&gt;qmake -o Makefile simExtMtb.pro
    E:\downloads\cop410\programming\simExtMTB&gt;mingw32-make -f Makefile.Release
    在 release 目錄中取得 simExtMtb.dll, 啟動前放入 Coppeliasim 根目錄.</t>
</tnodes>
</leo_file>
