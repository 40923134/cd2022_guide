<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20220502144333.1"><vh>@settings</vh>
<v t="leo.20220502144333.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20220502144333.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20220502161804.1"><vh>專案說明</vh></v>
<v t="leo.20220502160945.1"><vh>importer</vh></v>
<v t="leo.20220502161105.1"><vh>pymesh</vh>
<v t="leo.20220502161105.2"><vh>@path ./</vh>
<v t="leo.20220502161105.3"><vh>@clean setup.py</vh></v>
<v t="leo.20220502161105.4"><vh>@path example</vh>
<v t="leo.20220502161105.5"><vh>@clean env.py</vh></v>
<v t="leo.20220502161105.6"><vh>@clean sample.py</vh>
<v t="leo.20220502161105.7"><vh>main</vh></v>
</v>
</v>
<v t="leo.20220502161105.9"><vh>@path pymesh</vh>
<v t="leo.20220502161105.10"><vh>@clean base.py</vh>
<v t="leo.20220502161105.11"><vh>class BaseMesh</vh>
<v t="leo.20220502161105.12"><vh>BaseMesh.__init__</vh></v>
<v t="leo.20220502161105.13"><vh>BaseMesh.set_initial_values</vh></v>
<v t="leo.20220502161105.14"><vh>BaseMesh.rotate_x</vh></v>
<v t="leo.20220502161105.15"><vh>BaseMesh.rotate_y</vh></v>
<v t="leo.20220502161105.16"><vh>BaseMesh.rotate_z</vh></v>
<v t="leo.20220502161105.17"><vh>BaseMesh.translate_x</vh></v>
<v t="leo.20220502161105.18"><vh>BaseMesh.translate_y</vh></v>
<v t="leo.20220502161105.19"><vh>BaseMesh.translate_z</vh></v>
<v t="leo.20220502161105.20"><vh>BaseMesh.scale</vh></v>
<v t="leo.20220502161105.21"><vh>BaseMesh.join</vh></v>
<v t="leo.20220502161105.22"><vh>BaseMesh.update_normals</vh></v>
<v t="leo.20220502161105.23"><vh>BaseMesh.get_volume</vh></v>
<v t="leo.20220502161105.24"><vh>BaseMesh.__calc_signed_volume</vh></v>
<v t="leo.20220502161105.25"><vh>BaseMesh.Save functions</vh></v>
<v t="leo.20220502161105.26"><vh>BaseMesh.save_stl</vh></v>
<v t="leo.20220502161105.27"><vh>BaseMesh.__save_stl_binary</vh></v>
<v t="leo.20220502161105.28"><vh>BaseMesh.__save_stl_ascii</vh></v>
<v t="leo.20220502161105.29"><vh>BaseMesh.save_obj</vh></v>
</v>
</v>
<v t="leo.20220502161105.30"><vh>@clean obj.py</vh>
<v t="leo.20220502161105.31"><vh>class Obj</vh>
<v t="leo.20220502161105.32"><vh>Obj.__init__</vh></v>
<v t="leo.20220502161105.33"><vh>Obj.__load</vh></v>
<v t="leo.20220502161105.34"><vh>Obj.__read</vh></v>
</v>
</v>
<v t="leo.20220502161105.35"><vh>@clean stl.py</vh>
<v t="leo.20220502161105.36"><vh>class Stl</vh>
<v t="leo.20220502161105.37"><vh>Stl.__init__</vh></v>
<v t="leo.20220502161105.38"><vh>Stl.__load</vh></v>
<v t="leo.20220502161105.39"><vh>Stl.__load_binary</vh></v>
<v t="leo.20220502161105.40"><vh>Stl.__load_ascii</vh></v>
<v t="leo.20220502161105.41"><vh>Stl.__ascii_reader</vh></v>
</v>
</v>
<v t="leo.20220502161105.42"><vh>@clean utils.py</vh>
<v t="leo.20220502161105.43"><vh>class Validator</vh></v>
</v>
<v t="leo.20220502161105.44"><vh>@clean __init__.py</vh></v>
</v>
<v t="leo.20220502161105.45"><vh>@path tests</vh>
<v t="leo.20220502161105.46"><vh>@clean test_obj.py</vh>
<v t="leo.20220502161105.47"><vh>class SimpleTest</vh>
<v t="leo.20220502161105.48"><vh>SimpleTest.setUp</vh></v>
<v t="leo.20220502161105.49"><vh>SimpleTest.tearDown</vh></v>
<v t="leo.20220502161105.50"><vh>SimpleTest.test_sample</vh></v>
</v>
</v>
<v t="leo.20220502161105.51"><vh>@clean test_stl.py</vh>
<v t="leo.20220502161105.52"><vh>class SimpleTest</vh>
<v t="leo.20220502161105.53"><vh>SimpleTest.setUp</vh></v>
<v t="leo.20220502161105.54"><vh>SimpleTest.tearDown</vh></v>
<v t="leo.20220502161105.55"><vh>SimpleTest.test_sample</vh></v>
</v>
</v>
<v t="leo.20220502161105.56"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="leo.20220502161649.1"><vh>numpy-stl</vh>
<v t="leo.20220502161649.2"><vh>@path ./</vh>
<v t="leo.20220502161649.3"><vh>@clean setup.py</vh>
<v t="leo.20220502161649.4"><vh>error</vh></v>
<v t="leo.20220502161649.5"><vh>try:</vh></v>
<v t="leo.20220502161649.6"><vh>class PyTest</vh>
<v t="leo.20220502161649.7"><vh>PyTest.finalize_options</vh></v>
<v t="leo.20220502161649.8"><vh>PyTest.run_tests</vh></v>
</v>
<v t="leo.20220502161649.9"><vh>if sys.version_info.major == 2 or sys.platform.lower() != 'win32':</vh></v>
<v t="leo.20220502161649.10"><vh>class BuildExt</vh>
<v t="leo.20220502161649.11"><vh>BuildExt.run</vh></v>
</v>
</v>
<v t="leo.20220502161649.12"><vh>@path docs</vh>
<v t="leo.20220502161649.13"><vh>@clean conf.py</vh></v>
<v t="leo.20220502161649.14"><vh>@path _theme</vh>
<v t="leo.20220502161649.15"><vh>@clean flask_theme_support.py</vh>
<v t="leo.20220502161649.16"><vh>class FlaskyStyle</vh></v>
</v>
<v t="leo.20220502161649.17"><vh>@path wolph</vh></v>
</v>
</v>
<v t="leo.20220502161649.19"><vh>@path stl</vh>
<v t="leo.20220502161649.20"><vh>@clean base.py</vh>
<v t="leo.20220502161649.21"><vh>class Dimension</vh></v>
<v t="leo.20220502161649.22"><vh>For backwards compatibility, leave the original references</vh></v>
<v t="leo.20220502161649.23"><vh>class RemoveDuplicates</vh>
<v t="leo.20220502161649.24"><vh>RemoveDuplicates.map</vh></v>
</v>
<v t="leo.20220502161649.25"><vh>logged</vh></v>
<v t="leo.20220502161649.26"><vh>class BaseMesh</vh>
<v t="leo.20220502161649.27"><vh>BaseMesh.__init__</vh></v>
<v t="leo.20220502161649.28"><vh>BaseMesh.attr</vh></v>
<v t="leo.20220502161649.29"><vh>BaseMesh.attr</vh></v>
<v t="leo.20220502161649.30"><vh>BaseMesh.normals</vh></v>
<v t="leo.20220502161649.31"><vh>BaseMesh.normals</vh></v>
<v t="leo.20220502161649.32"><vh>BaseMesh.vectors</vh></v>
<v t="leo.20220502161649.33"><vh>BaseMesh.vectors</vh></v>
<v t="leo.20220502161649.34"><vh>BaseMesh.points</vh></v>
<v t="leo.20220502161649.35"><vh>BaseMesh.points</vh></v>
<v t="leo.20220502161649.36"><vh>BaseMesh.v0</vh></v>
<v t="leo.20220502161649.37"><vh>BaseMesh.v0</vh></v>
<v t="leo.20220502161649.38"><vh>BaseMesh.v1</vh></v>
<v t="leo.20220502161649.39"><vh>BaseMesh.v1</vh></v>
<v t="leo.20220502161649.40"><vh>BaseMesh.v2</vh></v>
<v t="leo.20220502161649.41"><vh>BaseMesh.v2</vh></v>
<v t="leo.20220502161649.42"><vh>BaseMesh.x</vh></v>
<v t="leo.20220502161649.43"><vh>BaseMesh.x</vh></v>
<v t="leo.20220502161649.44"><vh>BaseMesh.y</vh></v>
<v t="leo.20220502161649.45"><vh>BaseMesh.y</vh></v>
<v t="leo.20220502161649.46"><vh>BaseMesh.z</vh></v>
<v t="leo.20220502161649.47"><vh>BaseMesh.z</vh></v>
<v t="leo.20220502161649.48"><vh>BaseMesh.remove_duplicate_polygons</vh></v>
<v t="leo.20220502161649.49"><vh>BaseMesh.remove_empty_areas</vh></v>
<v t="leo.20220502161649.50"><vh>BaseMesh.update_normals</vh></v>
<v t="leo.20220502161649.51"><vh>BaseMesh.get_unit_normals</vh></v>
<v t="leo.20220502161649.52"><vh>BaseMesh.update_min</vh></v>
<v t="leo.20220502161649.53"><vh>BaseMesh.update_max</vh></v>
<v t="leo.20220502161649.54"><vh>BaseMesh.update_areas</vh></v>
<v t="leo.20220502161649.55"><vh>BaseMesh.check</vh></v>
<v t="leo.20220502161649.56"><vh>BaseMesh.is_closed</vh></v>
<v t="leo.20220502161649.57"><vh>BaseMesh.get_mass_properties</vh></v>
<v t="leo.20220502161649.58"><vh>BaseMesh.update_units</vh></v>
<v t="leo.20220502161649.59"><vh>BaseMesh.rotation_matrix</vh></v>
<v t="leo.20220502161649.60"><vh>BaseMesh.rotate</vh></v>
<v t="leo.20220502161649.61"><vh>BaseMesh.rotate_using_matrix</vh></v>
<v t="leo.20220502161649.62"><vh>BaseMesh.translate</vh></v>
<v t="leo.20220502161649.63"><vh>BaseMesh.transform</vh></v>
<v t="leo.20220502161649.64"><vh>BaseMesh._get_or_update</vh></v>
<v t="leo.20220502161649.65"><vh>BaseMesh._set</vh></v>
<v t="leo.20220502161649.66"><vh>BaseMesh.min_ = property(_get_or_update('min'), _set('min'),</vh></v>
<v t="leo.20220502161649.67"><vh>BaseMesh.__getitem__</vh></v>
<v t="leo.20220502161649.68"><vh>BaseMesh.__setitem__</vh></v>
<v t="leo.20220502161649.69"><vh>BaseMesh.__len__</vh></v>
<v t="leo.20220502161649.70"><vh>BaseMesh.__iter__</vh></v>
<v t="leo.20220502161649.71"><vh>BaseMesh.get_mass_properties_with_density</vh></v>
</v>
</v>
<v t="leo.20220502161649.72"><vh>@clean main.py</vh>
<v t="leo.20220502161649.73"><vh>_get_parser</vh></v>
<v t="leo.20220502161649.74"><vh>_get_name</vh></v>
<v t="leo.20220502161649.75"><vh>main</vh></v>
<v t="leo.20220502161649.76"><vh>to_ascii</vh></v>
<v t="leo.20220502161649.77"><vh>to_binary</vh></v>
</v>
<v t="leo.20220502161649.78"><vh>@clean mesh.py</vh></v>
<v t="leo.20220502161649.79"><vh>@clean stl.py</vh>
<v t="leo.20220502161649.80"><vh>class Mode</vh></v>
<v t="leo.20220502161649.81"><vh>For backwards compatibility, leave the original references</vh></v>
<v t="leo.20220502161649.82"><vh>class BaseStl</vh>
<v t="leo.20220502161649.83"><vh>BaseStl.load</vh></v>
<v t="leo.20220502161649.84"><vh>BaseStl._load_binary</vh></v>
<v t="leo.20220502161649.85"><vh>BaseStl._ascii_reader</vh></v>
<v t="leo.20220502161649.86"><vh>BaseStl._load_ascii</vh></v>
<v t="leo.20220502161649.87"><vh>BaseStl.save</vh></v>
<v t="leo.20220502161649.88"><vh>BaseStl._write_ascii</vh>
<v t="leo.20220502161649.89"><vh>BaseStl.p</vh></v>
</v>
<v t="leo.20220502161649.90"><vh>BaseStl.get_header</vh></v>
<v t="leo.20220502161649.91"><vh>BaseStl._write_binary</vh></v>
<v t="leo.20220502161649.92"><vh>BaseStl.from_file</vh></v>
<v t="leo.20220502161649.93"><vh>BaseStl.from_multi_file</vh></v>
<v t="leo.20220502161649.94"><vh>BaseStl.from_files</vh></v>
</v>
</v>
<v t="leo.20220502161649.95"><vh>@clean utils.py</vh>
<v t="leo.20220502161649.96"><vh>b</vh></v>
<v t="leo.20220502161649.97"><vh>s</vh></v>
</v>
<v t="leo.20220502161649.98"><vh>@clean __about__.py</vh></v>
<v t="leo.20220502161649.99"><vh>@clean __init__.py</vh></v>
</v>
<v t="leo.20220502161649.100"><vh>@path tests</vh>
<v t="leo.20220502161649.101"><vh>@clean conftest.py</vh>
<v t="leo.20220502161649.102"><vh>pytest_generate_tests</vh></v>
<v t="leo.20220502161649.103"><vh>cwd</vh></v>
<v t="leo.20220502161649.104"><vh>ascii_path</vh></v>
<v t="leo.20220502161649.105"><vh>binary_path</vh></v>
<v t="leo.20220502161649.106"><vh>binary_ascii_path</vh></v>
<v t="leo.20220502161649.107"><vh>ascii_file</vh></v>
<v t="leo.20220502161649.108"><vh>binary_file</vh></v>
</v>
<v t="leo.20220502161649.109"><vh>@clean stl_corruption.py</vh>
<v t="leo.20220502161649.110"><vh>test_valid_ascii</vh></v>
<v t="leo.20220502161649.111"><vh>test_ascii_with_missing_name</vh></v>
<v t="leo.20220502161649.112"><vh>test_ascii_with_blank_lines</vh></v>
<v t="leo.20220502161649.113"><vh>test_incomplete_ascii_file</vh></v>
<v t="leo.20220502161649.114"><vh>test_corrupt_ascii_file</vh></v>
<v t="leo.20220502161649.115"><vh>test_corrupt_binary_file</vh></v>
<v t="leo.20220502161649.116"><vh>test_duplicate_polygons</vh></v>
</v>
<v t="leo.20220502161649.117"><vh>@clean test_ascii.py</vh>
<v t="leo.20220502161649.118"><vh>test_ascii_file</vh></v>
<v t="leo.20220502161649.119"><vh>test_chinese_name</vh></v>
<v t="leo.20220502161649.120"><vh>test_long_name</vh></v>
<v t="leo.20220502161649.121"><vh>test_scientific_notation</vh></v>
<v t="leo.20220502161649.122"><vh>@pytest.mark.skipif(sys.platform.startswith('win'),</vh></v>
<v t="leo.20220502161649.123"><vh>test_locale_restore</vh></v>
<v t="leo.20220502161649.124"><vh>@pytest.mark.skipif(sys.platform.startswith('win'),</vh></v>
<v t="leo.20220502161649.125"><vh>test_use_with_qt_with_custom_locale_decimal_delimeter</vh></v>
<v t="leo.20220502161649.126"><vh>test_ascii_io</vh></v>
</v>
<v t="leo.20220502161649.127"><vh>@clean test_binary.py</vh>
<v t="leo.20220502161649.128"><vh>test_ascii_like_binary</vh></v>
<v t="leo.20220502161649.129"><vh>test_binary_in_ascii_mode</vh></v>
<v t="leo.20220502161649.130"><vh>_test</vh></v>
<v t="leo.20220502161649.131"><vh>test_write_bytes_io</vh></v>
<v t="leo.20220502161649.132"><vh>test_binary_file</vh></v>
</v>
<v t="leo.20220502161649.133"><vh>@clean test_commandline.py</vh>
<v t="leo.20220502161649.134"><vh>test_main</vh></v>
<v t="leo.20220502161649.135"><vh>test_args</vh>
<v t="leo.20220502161649.136"><vh>_get_name</vh></v>
</v>
<v t="leo.20220502161649.137"><vh>test_ascii</vh></v>
<v t="leo.20220502161649.138"><vh>test_binary</vh></v>
</v>
<v t="leo.20220502161649.139"><vh>@clean test_convert.py</vh>
<v t="leo.20220502161649.140"><vh>_test_conversion</vh></v>
<v t="leo.20220502161649.141"><vh>test_ascii_to_binary</vh></v>
<v t="leo.20220502161649.142"><vh>test_binary_to_ascii</vh></v>
<v t="leo.20220502161649.143"><vh>test_stl_mesh</vh></v>
</v>
<v t="leo.20220502161649.144"><vh>@clean test_line_endings.py</vh>
<v t="leo.20220502161649.145"><vh>test_line_endings</vh></v>
</v>
<v t="leo.20220502161649.146"><vh>@clean test_mesh.py</vh>
<v t="leo.20220502161649.147"><vh>test_units_1d</vh></v>
<v t="leo.20220502161649.148"><vh>test_units_2d</vh></v>
<v t="leo.20220502161649.149"><vh>test_units_3d</vh></v>
<v t="leo.20220502161649.150"><vh>test_duplicate_polygons</vh></v>
<v t="leo.20220502161649.151"><vh>test_remove_all_duplicate_polygons</vh></v>
<v t="leo.20220502161649.152"><vh>test_empty_areas</vh></v>
<v t="leo.20220502161649.153"><vh>test_base_mesh</vh></v>
</v>
<v t="leo.20220502161649.154"><vh>@clean test_meshProperties.py</vh>
<v t="leo.20220502161649.155"><vh>close</vh></v>
<v t="leo.20220502161649.156"><vh>test_mass_properties_for_half_donut</vh></v>
<v t="leo.20220502161649.157"><vh>test_mass_properties_for_moon</vh></v>
<v t="leo.20220502161649.158"><vh>test_mass_properties_for_star</vh></v>
<v t="leo.20220502161649.159"><vh>test_mass_properties_for_half_donut_with_density</vh></v>
</v>
<v t="leo.20220502161649.160"><vh>@clean test_multiple.py</vh>
<v t="leo.20220502161649.161"><vh>test_single_stl</vh></v>
<v t="leo.20220502161649.162"><vh>test_multiple_stl</vh></v>
<v t="leo.20220502161649.163"><vh>test_single_stl_file</vh></v>
<v t="leo.20220502161649.164"><vh>test_multiple_stl_file</vh></v>
<v t="leo.20220502161649.165"><vh>test_multiple_stl_files</vh></v>
</v>
<v t="leo.20220502161649.166"><vh>@clean test_rotate.py</vh>
<v t="leo.20220502161649.167"><vh>test_rotation</vh></v>
<v t="leo.20220502161649.168"><vh>test_rotation_over_point</vh></v>
<v t="leo.20220502161649.169"><vh>test_double_rotation</vh></v>
<v t="leo.20220502161649.170"><vh>test_no_rotation</vh></v>
<v t="leo.20220502161649.171"><vh>test_no_translation</vh></v>
<v t="leo.20220502161649.172"><vh>test_translation</vh></v>
<v t="leo.20220502161649.173"><vh>test_no_transformation</vh></v>
<v t="leo.20220502161649.174"><vh>test_transformation</vh></v>
</v>
<v t="leo.20220502161649.175"><vh>@clean utils.py</vh>
<v t="leo.20220502161649.176"><vh>to_array</vh></v>
<v t="leo.20220502161649.177"><vh>array_equals</vh></v>
</v>
<v t="leo.20220502161649.178"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="leo.20220502224846.1"><vh>STL-Volume-Model-Calculator</vh>
<v t="leo.20220502224846.2"><vh>@path ./</vh>
<v t="leo.20220502224846.3"><vh>@clean mesure_volume.py</vh>
<v t="leo.20220502224846.4"><vh>class STLUtils</vh>
<v t="leo.20220502224846.5"><vh>STLUtils.resetVariables</vh></v>
<v t="leo.20220502224846.6"><vh>STLUtils.signedVolumeOfTriangle</vh></v>
<v t="leo.20220502224846.7"><vh>STLUtils.unpack</vh></v>
<v t="leo.20220502224846.8"><vh>STLUtils.read_triangle</vh></v>
<v t="leo.20220502224846.9"><vh>STLUtils.read_length</vh></v>
<v t="leo.20220502224846.10"><vh>STLUtils.read_header</vh></v>
<v t="leo.20220502224846.11"><vh>STLUtils.cm3_To_inch3Transform</vh></v>
<v t="leo.20220502224846.12"><vh>STLUtils.calculateMassCM3</vh></v>
<v t="leo.20220502224846.13"><vh>STLUtils.calculateVolume</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20220502234818.1"><vh>pySTL</vh>
<v t="leo.20220502234818.2"><vh>@path ./</vh>
<v t="leo.20220502234818.3"><vh>@clean editSTL.py</vh></v>
<v t="leo.20220502234818.4"><vh>@clean moveToCentroid.py</vh></v>
<v t="leo.20220502234818.5"><vh>@clean pySTL.py</vh>
<v t="leo.20220502234818.6"><vh>rotationAboutX</vh></v>
<v t="leo.20220502234818.7"><vh>rotationAboutY</vh></v>
<v t="leo.20220502234818.8"><vh>rotationAboutZ</vh></v>
<v t="leo.20220502234818.9"><vh>class triangle</vh>
<v t="leo.20220502234818.10"><vh>triangle.__init__</vh></v>
<v t="leo.20220502234818.11"><vh>triangle.calculate_normal</vh></v>
</v>
<v t="leo.20220502234818.12"><vh>class STLmodel</vh>
<v t="leo.20220502234818.13"><vh>STLmodel.__init__</vh></v>
<v t="leo.20220502234818.14"><vh>STLmodel.get_triangles</vh></v>
<v t="leo.20220502234818.15"><vh>STLmodel.get_centroid</vh></v>
<v t="leo.20220502234818.16"><vh>STLmodel.get_volume</vh></v>
<v t="leo.20220502234818.17"><vh>STLmodel.calculateCentroid</vh></v>
<v t="leo.20220502234818.18"><vh>STLmodel.load_stl</vh></v>
<v t="leo.20220502234818.19"><vh>STLmodel.load_text_stl</vh></v>
<v t="leo.20220502234818.20"><vh>STLmodel.load_binary_stl</vh></v>
<v t="leo.20220502234818.21"><vh>STLmodel.write_text_stl</vh></v>
<v t="leo.20220502234818.22"><vh>STLmodel.translate</vh></v>
<v t="leo.20220502234818.23"><vh>STLmodel.rotate</vh></v>
<v t="leo.20220502234818.24"><vh>STLmodel.scale</vh></v>
</v>
</v>
<v t="leo.20220502234818.25"><vh>@clean sample.py</vh>
<v t="leo.20220502234818.26"><vh>leoprint</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20220502144333.1"></t>
<t tx="leo.20220502144333.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20220502144333.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20220502160945.1">'''Recursively import all python files in a directory and clean the result.'''
 
c.recursiveImport(
    dir_ = r'./pySTL',
    kind = '@clean', 
    safe_at_file = False,
    theTypes =  ['.py']
)</t>
<t tx="leo.20220502161105.1"></t>
<t tx="leo.20220502161105.10">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

from __future__ import absolute_import, print_function
import datetime
import math
import numpy
import os
import struct
from . import __title__
from . import __version__
from . import __url__

MODE_STL_AUTO = 0
MODE_STL_ASCII = 1
MODE_STL_BINARY = 2


@others
</t>
<t tx="leo.20220502161105.11">class BaseMesh(object):

    stl_dtype = numpy.dtype([
        ('normals', numpy.float32, (3, )),
        ('vectors', numpy.float32, (3, 3)),
        ('attr', numpy.uint16, (1, )),
    ])

    @others
</t>
<t tx="leo.20220502161105.12">def __init__(self):
    self.data = None
    self.normals = []
    self.vectors = []
    self.attr = []
    self.mode = MODE_STL_BINARY

</t>
<t tx="leo.20220502161105.13">def set_initial_values(self):
    """Set initial values form existing self.data value
    :return: None
    """
    self.normals = self.data['normals']
    self.vectors = numpy.ones((
        self.data['vectors'].shape[0],
        self.data['vectors'].shape[1],
        self.data['vectors'].shape[2] + 1
    ))
    self.vectors[:, :, :-1] = self.data['vectors']
    self.attr = self.data['attr']
    return

</t>
<t tx="leo.20220502161105.14">def rotate_x(self, deg):
    """Rotate mesh around x-axis

    :param float deg: Rotation angle (degree)
    :return:
    """
    rad = math.radians(deg)
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, math.cos(rad), math.sin(rad), 0],
        [0, -math.sin(rad), math.cos(rad), 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.15">def rotate_y(self, deg):
    """Rotate mesh around y-axis

    :param float deg: Rotation angle (degree)
    """
    rad = math.radians(deg)
    mat = numpy.array([
        [math.cos(rad), 0, -math.sin(rad), 0],
        [0, 1, 0, 0],
        [math.sin(rad), 0, math.cos(rad), 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.16">def rotate_z(self, deg):
    """Rotate mesh around z-axis

    :param float deg: Rotation angle (degree)
    """
    rad = math.radians(deg)
    mat = numpy.array([
        [math.cos(rad), math.sin(rad), 0, 0],
        [-math.sin(rad), math.cos(rad), 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.17">def translate_x(self, d):
    """Translate mesh for x-direction

    :param float d: Amount to translate
    """
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [d, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.18">def translate_y(self, d):
    """Translate mesh for y-direction

    :param float d: Amount to translate
    """
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, d, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.19">def translate_z(self, d):
    """Translate mesh for z-direction

    :param float d: Amount to translate
    """
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, d, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.2"></t>
<t tx="leo.20220502161105.20">def scale(self, sx, sy, sz):
    """Scale mesh

    :param float sx: Amount to scale for x-direction
    :param float sy: Amount to scale for y-direction
    :param float sz: Amount to scale for z-direction
    """
    mat = numpy.array([
        [sx, 0, 0, 0],
        [0, sy, 0, 0],
        [0, 0, sz, 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.21">def join(self, another):
    """

    :param m: BaseMesh
    :return:
    """
    if another is None:
        raise AttributeError("another BaseMesh instance is required")

    if not isinstance(another, BaseMesh):
        raise TypeError("anther must be an instance of BaseMesh")

    self.data = numpy.append(self.data, another.data)
    self.normals = numpy.append(self.normals, another.normals, axis=0)
    self.vectors = numpy.append(self.vectors, another.vectors, axis=0)
    self.attr = numpy.append(self.attr, another.attr, axis=0)
    return self

</t>
<t tx="leo.20220502161105.22">def update_normals(self):
    v0 = self.vectors[:, 0, :3]
    v1 = self.vectors[:, 1, :3]
    v2 = self.vectors[:, 2, :3]
    _normals = numpy.cross(v1 - v0, v2 - v0)

    for i in range(len(_normals)):
        norm = numpy.linalg.norm(_normals[i])
        if norm != 0:
            _normals[i] /= numpy.linalg.norm(_normals[i])

    self.normals[:] = _normals
    return self

</t>
<t tx="leo.20220502161105.23">#####################################################################
# Analyze functions
#
def get_volume(self):
    total_volume = 0
    for triangle in self.vectors:
        total_volume += BaseMesh.__calc_signed_volume(triangle)
    return total_volume

</t>
<t tx="leo.20220502161105.24">@staticmethod
def __calc_signed_volume(triangle):
    """ Calculate signed volume of given triangle
    :param list of list triangle:
    :rtype float
    """
    v321 = triangle[2][0] * triangle[1][1] * triangle[0][2]
    v231 = triangle[1][0] * triangle[2][1] * triangle[0][2]
    v312 = triangle[2][0] * triangle[0][1] * triangle[1][2]
    v132 = triangle[0][0] * triangle[2][1] * triangle[1][2]
    v213 = triangle[1][0] * triangle[0][1] * triangle[2][2]
    v123 = triangle[0][0] * triangle[1][1] * triangle[2][2]

    signed_volume = (-v321 + v231 + v312 - v132 - v213 + v123) / 6.0
    return signed_volume

</t>
<t tx="leo.20220502161105.25">#####################################################################
# Save functions
#

</t>
<t tx="leo.20220502161105.26"># STL
def save_stl(self, path, mode=MODE_STL_AUTO, update_normals=True):
    """Save data with stl format
    :param str path:
    :param int mode:
    :param bool update_normals:
    """
    if update_normals:
        self.update_normals()

    filename = os.path.split(path)[-1]

    if mode is MODE_STL_AUTO:
        if self.mode == MODE_STL_BINARY:
            save_func = self.__save_stl_binary

        elif self.mode == MODE_STL_ASCII:
            save_func = self.__save_stl_ascii

        else:
            raise ValueError("Mode %r is invalid" % mode)

    elif mode is MODE_STL_BINARY:
        save_func = self.__save_stl_binary

    else:
        raise ValueError("Mode %r is invalid" % mode)

    with open(path, 'wb') as fh:
        save_func(fh, filename)

</t>
<t tx="leo.20220502161105.27">def __save_stl_binary(self, fh, name):
    fh.write(("%s (%s) %s %s" % (
        "{}".format(__title__),
        "{}".format(__version__),
        datetime.datetime.now(),
        name
    ))[:80].ljust(80, ' '))

    bin_data = numpy.zeros(self.data.size, BaseMesh.stl_dtype)
    bin_data['normals'] = self.normals[:]
    bin_data['vectors'] = self.vectors[:, :, :3]
    bin_data['attr'] = self.attr
    fh.write(struct.pack('i', bin_data.size))
    bin_data.tofile(fh)

</t>
<t tx="leo.20220502161105.28">def __save_stl_ascii(self, fh, name):
    print("solid {}".format(name), file=fh)
    for i in range(len(self.vectors)):
        print("facet normal %f %f %f" % tuple(self.normals[i][:3]), file=fh)
        print("  outer loop", file=fh)
        print("    vertex %f %f %f" % tuple(self.vectors[i][0][:3]), file=fh)
        print("    vertex %f %f %f" % tuple(self.vectors[i][1][:3]), file=fh)
        print("    vertex %f %f %f" % tuple(self.vectors[i][2][:3]), file=fh)
        print("  endloop", file=fh)
        print("endfacet", file=fh)
    print("endsolid {}".format(name), file=fh)

</t>
<t tx="leo.20220502161105.29"># OBJ
def save_obj(self, path, update_normals=True):
    """Save data with OBJ format
    :param stl path:
    :param bool update_normals:
    """
    if update_normals:
        self.update_normals()

    # Create triangle_list
    vectors_key_list = []
    vectors_list = []
    normals_key_list = []
    normals_list = []
    triangle_list = []
    for i, vector in enumerate(self.vectors):
        one_triangle = []
        for j in range(3):
            v_key = ",".join(map(str, self.vectors[i][j][:3]))
            if v_key in vectors_key_list:
                v_index = vectors_key_list.index(v_key)
            else:
                v_index = len(vectors_key_list)
                vectors_key_list.append(v_key)
                vectors_list.append(self.vectors[i][j][:3])
            one_triangle.append(v_index + 1)

        n_key = ",".join(map(str, self.normals[i][:3]))
        if n_key in normals_key_list:
            n_index = normals_key_list.index(n_key)
        else:
            n_index = len(normals_key_list)
            normals_key_list.append(n_key)
            normals_list.append(self.normals[i][:3])

        # print(normals_list)
        triangle_list.append((one_triangle, n_index + 1))

    with open(path, "wb") as fh:
        print("# {} {}".format(__title__, __version__), file=fh)
        print("# {}".format(datetime.datetime.now()), file=fh)
        print("# {}".format(__url__), file=fh)
        print("", file=fh)
        for v in vectors_list:
            print("v {} {} {}".format(v[0], v[1], v[2]), file=fh)
        for vn in normals_list:
            print("vn {} {} {}".format(vn[0], vn[1], vn[2]), file=fh)
        for t in triangle_list:
            faces = t[0]
            normal = t[1]

            print("f {}//{} {}//{} {}//{}".format(
                faces[0], normal,
                faces[1], normal,
                faces[2], normal,
            ), file=fh)

</t>
<t tx="leo.20220502161105.3">@path ./pymesh/
@language python
@tabwidth -4
from setuptools import setup
import pymesh

setup(
    name=pymesh.__title__,
    packages=[pymesh.__title__],
    version=pymesh.__version__,
    author=pymesh.__author__,
    author_email="taxpon@gmail.com",
    description="Library for manipulating (Translate, Rotate and Scale) 3D data using numpy.",
    url=pymesh.__url__,
    license=pymesh.__license__,
    classifiers=[
        'License :: OSI Approved :: MIT License',
        "Programming Language :: Python",

    ],
    install_requires=[
        'numpy'
    ],
)
</t>
<t tx="leo.20220502161105.30">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

from __future__ import absolute_import, print_function
import numpy
from .base import BaseMesh


@others
</t>
<t tx="leo.20220502161105.31">class Obj(BaseMesh):

    obj_dtype = numpy.dtype([
        ('normals', numpy.float32, (3, )),
        ('vectors', numpy.float32, (3, 3)),
        ('attr', numpy.uint16, (1, )),
    ])

    @others
</t>
<t tx="leo.20220502161105.32">def __init__(self, path=None):
    """Create an instance of Obj (Wavefront)
    :param str path:
    """
    super(Obj, self).__init__()

    if path is None:
        # Create EMPTY data
        self.name = "empty"
        self.data = numpy.zeros(0, dtype=Obj.obj_dtype)

    else:
        # Create data from file
        with open(path, "rb") as fh:
            data = Obj.__load(fh)
        self.name = path
        self.data = data

    super(Obj, self).set_initial_values()
    return

</t>
<t tx="leo.20220502161105.33">@staticmethod
def __load(fh):
    return numpy.fromiter(Obj.__read(fh), dtype=Obj.obj_dtype)

</t>
<t tx="leo.20220502161105.34">@staticmethod
def __read(fh):
    vertices_list = []
    triangles_list = []

    try:
        while True:
            line = fh.readline()
            if line == "":
                break

            elif line.lstrip().startswith("vn"):
                continue

            elif line.lstrip().startswith("v"):
                vertices = line.replace("\n", "").split(" ")[1:]
                vertices_list.append(map(float, vertices))

            elif line.lstrip().startswith("f"):
                t_index_list = []
                for t in line.replace("\n", "").split(" ")[1:]:
                    t_index = t.split("/")[0]
                    t_index_list.append(int(t_index) - 1)
                triangles_list.append(t_index_list)

            else:
                continue

        for t in triangles_list:
            yield ([0, 0, 0], (vertices_list[t[0]], vertices_list[t[1]], vertices_list[t[2]]), 0)

    except:
        raise RuntimeError("Failed to load OBJ file.")
</t>
<t tx="leo.20220502161105.35">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

from __future__ import absolute_import, print_function
import numpy
import os
import struct
from .base import BaseMesh


@others
</t>
<t tx="leo.20220502161105.36">class Stl(BaseMesh):

    MODE_AUTO = 0
    MODE_ASCII = 1
    MODE_BINARY = 2

    HEADER_SIZE = 80
    COUNT_SIZE = 4
    MAX_COUNT = 1e6
    BUFFER_SIZE = 4096

    stl_dtype = numpy.dtype([
        ('normals', numpy.float32, (3, )),
        ('vectors', numpy.float32, (3, 3)),
        ('attr', numpy.uint16, (1, )),
    ])

    @others
</t>
<t tx="leo.20220502161105.37">def __init__(self, path=None, mode_policy=MODE_AUTO):
    """Craete a instance of Stl.
    :param str path: The file path to open
    :param int mode_policy: The mode to open, default is :py:data:`AUTOMATIC`.
    """
    super(Stl, self).__init__()

    if path is None:
        # Create EMPTY data
        self.name = "empty"
        self.data = numpy.zeros(0, dtype=Stl.stl_dtype)
        self.mode = Stl.MODE_BINARY

    else:
        # Create data from file
        with open(path, "rb") as fh:
            name, data, mode = Stl.__load(fh, mode=mode_policy)
        self.name = name
        self.data = data
        self.mode = mode

    super(Stl, self).set_initial_values()
    return

</t>
<t tx="leo.20220502161105.38">@staticmethod
def __load(fh, mode=MODE_AUTO):
    """Load Mesh from STL file

    :param FileIO fh: The file handle to open
    :param int mode: The mode to open, default is :py:data:`AUTOMATIC`.
    :return:
    """
    header = fh.read(Stl.HEADER_SIZE).lower()
    name = ""
    data = None
    if not header.strip():
        return

    if mode in (Stl.MODE_AUTO, Stl.MODE_ASCII) and header.startswith(b'solid'):
        try:
            name = header.split('\n', 1)[0][:5].strip()
            data = Stl.__load_ascii(fh, header)
            mode = Stl.MODE_ASCII

        except:
            pass

    else:
        data = Stl.__load_binary(fh)
        mode = Stl.MODE_BINARY

    return name, data, mode

</t>
<t tx="leo.20220502161105.39">@staticmethod
def __load_binary(fh):
    # Read the triangle count
    count, = struct.unpack("i", fh.read(Stl.COUNT_SIZE))
    assert count &lt; Stl.MAX_COUNT, \
        'File too large, got {} triangles which exceeds the maximum of {}' .format(
            count, Stl.MAX_COUNT
        )
    return numpy.fromfile(fh, Stl.stl_dtype, count=count)

</t>
<t tx="leo.20220502161105.4"></t>
<t tx="leo.20220502161105.40">@staticmethod
def __load_ascii(fh, header):
    return numpy.fromiter(Stl.__ascii_reader(fh, header), dtype=Stl.stl_dtype)

</t>
<t tx="leo.20220502161105.41">@staticmethod
def __ascii_reader(fh, header):
    """
    :param fh:
    :param header:
    :return:
    """

    lines = header.split('\n')
    recoverable = [True]

    def get(prefix=''):
        if lines:
            line = lines.pop(0)
        else:
            raise RuntimeError(recoverable[0], 'Unable to find more lines')

        if not lines:
            recoverable[0] = False

            # Read more lines and make sure we prepend any old data
            lines[:] = fh.read(Stl.BUFFER_SIZE).split('\n')
            line += lines.pop(0)
        line = line.lower().strip()
        if prefix:
            if line.startswith(prefix):
                values = line.replace(prefix, '', 1).strip().split()
            elif line.startswith('endsolid'):
                raise StopIteration()
            else:
                raise RuntimeError(recoverable[0],
                                   '%r should start with %r' % (line,
                                                                prefix))

            if len(values) == 3:
                vertex = [float(v) for v in values]
                return vertex
            else:  # pragma: no cover
                raise RuntimeError(recoverable[0],
                                   'Incorrect value %r' % line)
        else:
            return line

    line = get()
    if not line.startswith('solid ') and line.startswith('solid'):
        print("Error")

    if not lines:
        raise RuntimeError(recoverable[0],
                           'No lines found, impossible to read')

    while True:
        # Read from the header lines first, until that point we can recover
        # and go to the binary option. After that we cannot due to
        # unseekable files such as sys.stdin
        #
        # Numpy doesn't support any non-file types so wrapping with a
        # buffer and/or StringIO does not work.
        try:
            normals = get('facet normal')
            assert get() == 'outer loop'
            v0 = get('vertex')
            v1 = get('vertex')
            v2 = get('vertex')
            assert get() == 'endloop'
            assert get() == 'endfacet'
            attrs = 0
            yield (normals, (v0, v1, v2), attrs)
        except AssertionError as e:
            raise RuntimeError(recoverable[0], e)
        except StopIteration:
            if any(lines):
                # Seek back to where the next solid should begin
                fh.seek(-len('\n'.join(lines)), os.SEEK_CUR)
            raise

</t>
<t tx="leo.20220502161105.42">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-


@others
</t>
<t tx="leo.20220502161105.43">class Validator(object):

    @staticmethod
    def is_string(value):
        if value is None  or not isinstance(value, (str, unicode)):
            return False
        return True
</t>
<t tx="leo.20220502161105.44">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

#
# PyMesh
#

__title__ = "pymesh"
__versioninfo__ = (1, 0, 2)
__version__ = ".".join(map(str, __versioninfo__))
__author__ = "Takuro Wada"
__license__ = "MIT"
__copyright__ = "Copyright 2015 Takuro Wada"
__url__ = "https://github.com/taxpon/pymesh"
</t>
<t tx="leo.20220502161105.45"></t>
<t tx="leo.20220502161105.46">@path ./pymesh/tests/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

import unittest
from pymesh import stl


@others
if __name__ == "__main__":
    unittest.main()
</t>
<t tx="leo.20220502161105.47">class SimpleTest(unittest.TestCase):
    @others
</t>
<t tx="leo.20220502161105.48">def setUp(self):
    pass

</t>
<t tx="leo.20220502161105.49">def tearDown(self):
    pass

</t>
<t tx="leo.20220502161105.5">@path ./pymesh/example/
@language python
@tabwidth -4
import sys
import os

this = os.path.normpath(os.path.abspath(os.path.dirname(__file__)))
sys.path.insert(0, "/".join(this.split("/")[:-1]))
# sys.path.append("/".join(this.split("/")[:-1]))
</t>
<t tx="leo.20220502161105.50">def test_sample(self):
    pass


</t>
<t tx="leo.20220502161105.51">@path ./pymesh/tests/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

import unittest
from pymesh import stl


@others
if __name__ == "__main__":
    unittest.main()
</t>
<t tx="leo.20220502161105.52">class SimpleTest(unittest.TestCase):
    @others
</t>
<t tx="leo.20220502161105.53">def setUp(self):
    pass

</t>
<t tx="leo.20220502161105.54">def tearDown(self):
    pass

</t>
<t tx="leo.20220502161105.55">def test_sample(self):
    pass


</t>
<t tx="leo.20220502161105.56">@path ./pymesh/tests/
@language python
@tabwidth -4
</t>
<t tx="leo.20220502161105.6">@path ./pymesh/example/
@language python
@tabwidth -4
import env
from pymesh import stl
from pymesh import obj


@others
if __name__ == '__main__':
    main()
</t>
<t tx="leo.20220502161105.7">def main():
    print(stl.__file__)
    empty = stl.Stl()
    e2 = obj.Obj()
    m = stl.Stl('sample.stl')
    m2 = obj.Obj('sample.obj')
    print(m.get_volume())
    m.scale(1, 2, 1)
    m.rotate_x(90)
    m.rotate_y(30)
    m.translate_x(2)
    m.join(m2)
    empty.join(m2)
    empty.join(e2)
    m.save_stl("sample_out.stl", update_normals=True)
    empty.save_stl("empty.stl")


</t>
<t tx="leo.20220502161105.9"></t>
<t tx="leo.20220502161649.1"></t>
<t tx="leo.20220502161649.10">class BuildExt(build_ext):

    @others
</t>
<t tx="leo.20220502161649.100"></t>
<t tx="leo.20220502161649.101">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import py
import pytest


@others
</t>
<t tx="leo.20220502161649.102">def pytest_generate_tests(metafunc):
    # Run all tests both with and without speedups
    metafunc.fixturenames.append('speedups')
    metafunc.parametrize('speedups', [False, True])


</t>
<t tx="leo.20220502161649.103">@pytest.fixture(scope='session')
def cwd():
    return py.path.local(__file__).dirpath()


</t>
<t tx="leo.20220502161649.104">@pytest.fixture(scope='session')
def ascii_path(cwd):
    return cwd.join('stl_ascii')


</t>
<t tx="leo.20220502161649.105">@pytest.fixture(scope='session')
def binary_path(cwd):
    return cwd.join('stl_binary')


</t>
<t tx="leo.20220502161649.106">@pytest.fixture(scope='session', params=['ascii', 'binary'])
def binary_ascii_path(request, ascii_path, binary_path):
    return ascii_path if request.param == 'ascii' else binary_path


</t>
<t tx="leo.20220502161649.107">@pytest.fixture(scope='session')
def ascii_file(ascii_path):
    return str(ascii_path.join('HalfDonut.stl'))


</t>
<t tx="leo.20220502161649.108">@pytest.fixture(scope='session')
def binary_file(binary_path):
    return str(binary_path.join('HalfDonut.stl'))
</t>
<t tx="leo.20220502161649.109">@path ./numpy-stl/tests/
@language python
@tabwidth -4
from __future__ import print_function
import sys
import numpy
import pytest
import struct

from stl import mesh

_STL_FILE = '''
solid test.stl
facet normal -0.014565 0.073223 -0.002897
  outer loop
    vertex 0.399344 0.461940 1.044090
    vertex 0.500000 0.500000 1.500000
    vertex 0.576120 0.500000 1.117320
  endloop
endfacet
endsolid test.stl
'''.lstrip()


@others
</t>
<t tx="leo.20220502161649.11">def run(self):
    try:
        build_ext.run(self)
    except Exception as e:
        warnings.warn('''
        Unable to build speedups module, defaulting to pure Python. Note
        that the pure Python version is more than fast enough in most cases
        %r
        ''' % e)


</t>
<t tx="leo.20220502161649.110">def test_valid_ascii(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('w+') as fh:
        fh.write(_STL_FILE)
        fh.seek(0)
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)


</t>
<t tx="leo.20220502161649.111">def test_ascii_with_missing_name(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('w+') as fh:
        # Split the file into lines
        lines = _STL_FILE.splitlines()

        # Remove everything except solid
        lines[0] = lines[0].split()[0]

        # Join the lines to test files that start with solid without space
        fh.write('\n'.join(lines))
        fh.seek(0)
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)


</t>
<t tx="leo.20220502161649.112">def test_ascii_with_blank_lines(tmpdir, speedups):
    _stl_file = '''
    solid test.stl


      facet normal -0.014565 0.073223 -0.002897

        outer loop

          vertex 0.399344 0.461940 1.044090
          vertex 0.500000 0.500000 1.500000

          vertex 0.576120 0.500000 1.117320

        endloop

      endfacet

    endsolid test.stl
    '''.lstrip()

    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('w+') as fh:
        fh.write(_stl_file)
        fh.seek(0)
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)


</t>
<t tx="leo.20220502161649.113">def test_incomplete_ascii_file(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('w+') as fh:
        fh.write('solid some_file.stl')
        fh.seek(0)
        with pytest.raises(AssertionError):
            mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)

    for offset in (-20, 82, 100):
        with tmp_file.open('w+') as fh:
            fh.write(_STL_FILE[:-offset])
            fh.seek(0)
            with pytest.raises(AssertionError):
                mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)


</t>
<t tx="leo.20220502161649.114">def test_corrupt_ascii_file(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('w+') as fh:
        fh.write(_STL_FILE)
        fh.seek(40)
        print('####\n' * 100, file=fh)
        fh.seek(0)
        if speedups and sys.version_info.major != 2:
            with pytest.raises(AssertionError):
                mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)

    with tmp_file.open('w+') as fh:
        fh.write(_STL_FILE)
        fh.seek(40)
        print(' ' * 100, file=fh)
        fh.seek(80)
        fh.write(struct.pack('&lt;i', 10).decode('utf-8'))
        fh.seek(0)
        with pytest.raises(AssertionError):
            mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)


</t>
<t tx="leo.20220502161649.115">def test_corrupt_binary_file(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('w+') as fh:
        fh.write('#########\n' * 8)
        fh.write('#\0\0\0')
        fh.seek(0)
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)

    with tmp_file.open('w+') as fh:
        fh.write('#########\n' * 9)
        fh.seek(0)
        with pytest.raises(AssertionError):
            mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)

    with tmp_file.open('w+') as fh:
        fh.write('#########\n' * 8)
        fh.write('#\0\0\0')
        fh.seek(0)
        fh.write('solid test.stl')
        fh.seek(0)
        mesh.Mesh.from_file(str(tmp_file), fh=fh, speedups=speedups)


</t>
<t tx="leo.20220502161649.116">def test_duplicate_polygons():
    data = numpy.zeros(3, dtype=mesh.Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [1, 0, 0],
                                      [0, 1, 1.]])
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [2, 0, 0],
                                      [0, 2, 1.]])
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [3, 0, 0],
                                      [0, 3, 1.]])

    assert not mesh.Mesh(data, remove_empty_areas=False).check()
</t>
<t tx="leo.20220502161649.117">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import os
import sys
import locale
import pytest
import pathlib
import warnings
import subprocess
import io
import numpy

from stl.utils import b
from stl import mesh, Mode


FILES_PATH = pathlib.Path(__file__).parent / 'stl_tests'


@others
</t>
<t tx="leo.20220502161649.118">def test_ascii_file(speedups):
    filename = FILES_PATH / 'bwb.stl'
    mesh.Mesh.from_file(filename, speedups=speedups)


</t>
<t tx="leo.20220502161649.119">def test_chinese_name(tmpdir, speedups):
    name = 'Test Chinese name 月球'
    _stl_file = ('''
    solid %s
      facet normal -0.014565 0.073223 -0.002897
        outer loop
          vertex 0.399344 0.461940 1.044090
          vertex 0.500000 0.500000 1.500000
          vertex 0.576120 0.500000 1.117320
        endloop
      endfacet
    endsolid
    ''' % name).lstrip()

    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        fh.write(b(_stl_file))
        fh.seek(0)
        test_mesh = mesh.Mesh.from_file(str(tmp_file), fh=fh,
                                        speedups=speedups)
        if speedups:
            assert test_mesh.name.lower() == b(name).lower()
        else:
            assert test_mesh.name == b(name)


</t>
<t tx="leo.20220502161649.12"></t>
<t tx="leo.20220502161649.120">def test_long_name(tmpdir, speedups):
    name = 'Just Some Very Long Name which will not fit within the standard'
    name += name
    _stl_file = ('''
    solid %s
      facet normal -0.014565 0.073223 -0.002897
        outer loop
          vertex 0.399344 0.461940 1.044090
          vertex 0.500000 0.500000 1.500000
          vertex 0.576120 0.500000 1.117320
        endloop
      endfacet
    endsolid
    ''' % name).lstrip()

    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        fh.write(b(_stl_file))
        fh.seek(0)
        test_mesh = mesh.Mesh.from_file(str(tmp_file), fh=fh,
                                        speedups=speedups)

        if speedups:
            assert test_mesh.name.lower() == b(name).lower()
        else:
            assert test_mesh.name == b(name)


</t>
<t tx="leo.20220502161649.121">def test_scientific_notation(tmpdir, speedups):
    name = 'just some very long name which will not fit within the standard'
    name += name
    _stl_file = ('''
    solid %s
      facet normal 1.014565e-10 7.3223e-5 -10
        outer loop
          vertex 0.399344 0.461940 1.044090e-5
          vertex 5.00000e-5 5.00000e-5 1.500000e-3
          vertex 0 2.22045e-15 -10
        endloop
      endfacet
    endsolid
    ''' % name).lstrip()

    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        fh.write(b(_stl_file))
        fh.seek(0)
        test_mesh = mesh.Mesh.from_file(str(tmp_file), fh=fh,
                                        speedups=speedups)
        assert test_mesh.name == b(name)


</t>
<t tx="leo.20220502161649.122">@pytest.mark.skipif(sys.platform.startswith('win'),
                    reason='Only makes sense on Unix')
</t>
<t tx="leo.20220502161649.123">def test_locale_restore(speedups):
    if not speedups:
        pytest.skip('Only makes sense with speedups')

    old_locale = locale.nl_langinfo(locale.CODESET)

    filename = FILES_PATH / 'bwb.stl'
    mesh.Mesh.from_file(filename, speedups=speedups)

    new_locale = locale.nl_langinfo(locale.CODESET)
    assert old_locale == new_locale


</t>
<t tx="leo.20220502161649.124">@pytest.mark.skipif(sys.platform.startswith('win'),
                    reason='Only makes sense on Unix')
</t>
<t tx="leo.20220502161649.125">def test_use_with_qt_with_custom_locale_decimal_delimeter(speedups):
    if not speedups:
        pytest.skip('Only makes sense with speedups')

    venv = os.environ.get('VIRTUAL_ENV', '')
    if (3, 6) == sys.version_info[:2] and venv.startswith('/home/travis/'):
        pytest.skip('PySide2/PyQt5 tests are broken on Travis Python 3.6')

    try:
        from PySide2 import QtWidgets
    except ImportError:
        try:
            from PyQt5 import QtWidgets
        except ImportError:
            warnings.warn(
                'Unable to import PySide2/PyQt5, skipping locale tests',
                ImportWarning,
            )
            pytest.skip('PySide2/PyQt5 missing')
    assert QtWidgets

    dir_path = os.path.dirname(os.path.realpath(__file__))
    script_path = os.path.join(dir_path, 'qt-lc_numeric-reproducer')

    env = os.environ.copy()
    env['LC_NUMERIC'] = 'cs_CZ.utf-8'

    prefix = tuple()
    if sys.platform.startswith('linux'):
        prefix = ('xvfb-run', '-a')

    p = subprocess.Popen(prefix + (sys.executable, script_path),
                         env=env,
                         universal_newlines=True,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    out, err = p.communicate()

    # Unable to read the file with speedups, retrying
    # https://github.com/WoLpH/numpy-stl/issues/52
    sys.stdout.write(out)
    sys.stderr.write(err)

    assert 'File too large' not in out
    assert 'File too large' not in err
    assert p.returncode == 0


</t>
<t tx="leo.20220502161649.126">def test_ascii_io():
    # Create a vanilla mesh.
    mesh_ = mesh.Mesh(numpy.empty(3, mesh.Mesh.dtype))
    mesh_.vectors = numpy.arange(27).reshape((3, 3, 3))

    # Check that unhelpful 'expected str but got bytes' error is caught and
    # replaced.
    with pytest.raises(TypeError, match="handles should be in binary mode"):
        mesh_.save("nameless", fh=io.StringIO(), mode=Mode.ASCII)

    # Write to an io.BytesIO().
    fh = io.BytesIO()
    mesh_.save("nameless", fh=fh, mode=Mode.ASCII)
    # Assert binary file is still only ascii characters.
    fh.getvalue().decode("ascii")

    # Read the mesh back in.
    read = mesh.Mesh.from_file("anonymous.stl", fh=io.BytesIO(fh.getvalue()))
    # Check what comes out is the same as what went in.
    assert numpy.allclose(mesh_.vectors, read.vectors)
</t>
<t tx="leo.20220502161649.127">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import io
import numpy
import pytest
import pathlib
from stl import mesh, Mode


TESTS_PATH = pathlib.Path(__file__).parent


@others
</t>
<t tx="leo.20220502161649.128">@pytest.mark.parametrize('mode', [Mode.BINARY, Mode.AUTOMATIC])
def test_ascii_like_binary(tmpdir, speedups, mode):
    _test(tmpdir, speedups, mode, False)
    _test(tmpdir, speedups, mode, True)


</t>
<t tx="leo.20220502161649.129">def test_binary_in_ascii_mode(tmpdir, speedups):
    with pytest.raises(RuntimeError):
        _test(tmpdir, speedups, mode=Mode.ASCII, use_filehandle=False)

    with pytest.raises(RuntimeError):
        _test(tmpdir, speedups, mode=Mode.ASCII, use_filehandle=True)


</t>
<t tx="leo.20220502161649.13">@path ./numpy-stl/docs/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-
#
# Documentation build configuration file, created by
# sphinx-quickstart on Thu Feb 27 20:00:23 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
import datetime

try:
    import numpy
    assert numpy
except ImportError:
    # From the readthedocs manual
    # http://read-the-docs.readthedocs.org/en/latest/faq.html?highlight=numpy
    print &gt;&gt;sys.stderr, 'Unable to import numpy, falling back to mock'
    import mock

    MOCK_MODULES = ['pygtk', 'gtk', 'gobject', 'argparse', 'numpy', 'pandas']
    for mod_name in MOCK_MODULES:
        sys.modules[mod_name] = mock.Mock()

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
from stl import __about__ as metadata


# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = metadata.__package_name__.replace('-', ' ').capitalize()
copyright = u'%s,  &lt;a href="http://wol.ph/"&gt;%s&lt;/a&gt;' % (
    datetime.date.today().year,
    metadata.__author__,
)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = metadata.__version__
# The full version, including alpha/beta/rc tags.
release = metadata.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'wolph'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_theme']

# The name for this set of Sphinx documents.  If None, it defaults to
# "&lt;project&gt; v&lt;release&gt; documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a &lt;link&gt; tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = metadata.__package_name__ + '-doc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [(
    'index',
    '%s.tex' % metadata.__package_name__,
    u'%s Documentation' % metadata.__package_name__.replace('-', ' ').capitalize(),
   metadata.__author__,
   'manual',
)]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [(
    'index',
    metadata.__package_name__,
    u'%s Documentation' % metadata.__package_name__.replace('-', ' ').capitalize(),
    [metadata.__author__],
    1,
)]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [(
    'index',
    metadata.__package_name__,
    u'%s Documentation' % metadata.__package_name__.replace('-', ' ').capitalize(),
    metadata.__author__,
    metadata.__package_name__,
    metadata.__description__,
    'Miscellaneous',
)]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# -- Options for Epub output ----------------------------------------------

# Bibliographic Dublin Core info.
epub_title = metadata.__package_name__.replace('-', ' ').capitalize()
epub_author = metadata.__author__
epub_publisher = metadata.__author__
epub_copyright = copyright

# The HTML theme for the epub output. Since the default themes are not optimized
# for small screen space, using the same theme for HTML and epub output is
# usually not wise. This defaults to 'epub', a theme designed to save visual
# space.
#epub_theme = 'epub'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
#epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
epub_exclude_files = ['search.html']

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

# Choose between 'default' and 'includehidden'.
#epub_tocscope = 'default'

# Fix unsupported image types using the PIL.
#epub_fix_images = False

# Scale large images.
#epub_max_image_width = 0

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#epub_show_urls = 'inline'

# If false, no index is generated.
#epub_use_index = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'python': ('http://docs.python.org/2', None),
    'pythonutils': ('http://python-utils.readthedocs.org/en/latest/', None),
    'numpy': ('http://docs.scipy.org/doc/numpy/', None),
    'scipy': ('http://docs.scipy.org/doc/scipy/reference/', None),
    'matplotlib': ('http://matplotlib.sourceforge.net/', None),
}
</t>
<t tx="leo.20220502161649.130">def _test(tmpdir, speedups, mode, use_filehandle=True):
    filename = TESTS_PATH / 'stl_binary' / 'rear_case.stl'
    if use_filehandle:
        with open(filename, 'rb') as fh:
            mesh.Mesh.from_file(filename, fh=fh, speedups=speedups,
                                mode=mode)

        with open(filename, 'rb') as fh:
            # Test with BytesIO
            fh = io.BytesIO(fh.read())
            mesh.Mesh.from_file(filename, fh=fh, speedups=speedups,
                                mode=mode)
    else:
        mesh.Mesh.from_file(filename,
                            speedups=speedups, mode=mode)


</t>
<t tx="leo.20220502161649.131">@pytest.mark.parametrize('mode', [Mode.BINARY, Mode.AUTOMATIC])
def test_write_bytes_io(binary_file, mode):
    mesh_ = mesh.Mesh.from_file(binary_file)

    # Write to io.Bytes() in BINARY mode.
    fh = io.BytesIO()
    mesh_.save('mesh.stl', fh, mode=mode)

    assert len(fh.getvalue()) &gt; 84
    assert fh.getvalue()[84:] == mesh_.data.tobytes()

    read = mesh.Mesh.from_file('nameless', fh=io.BytesIO(fh.getvalue()))
    assert numpy.allclose(read.vectors, mesh_.vectors)


</t>
<t tx="leo.20220502161649.132">def test_binary_file():
    list(mesh.Mesh.from_multi_file(TESTS_PATH / 'stl_tests' / 'triamid.stl'))
</t>
<t tx="leo.20220502161649.133">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import sys

from stl import main


@others
</t>
<t tx="leo.20220502161649.134">def test_main(ascii_file, binary_file, tmpdir, speedups):
    original_argv = sys.argv[:]
    args_pre = ['stl']
    args_post = [str(tmpdir.join('output.stl'))]

    if not speedups:
        args_pre.append('-s')

    try:
        sys.argv[:] = args_pre + [ascii_file] + args_post
        main.main()
        sys.argv[:] = args_pre + ['-r', ascii_file] + args_post
        main.main()
        sys.argv[:] = args_pre + ['-a', binary_file] + args_post
        main.main()
        sys.argv[:] = args_pre + ['-b', ascii_file] + args_post
        main.main()
    finally:
        sys.argv[:] = original_argv


</t>
<t tx="leo.20220502161649.135">def test_args(ascii_file, tmpdir):
    parser = main._get_parser('')

    @others
    assert _get_name('--name', 'foobar') == 'foobar'
    assert _get_name('-', tmpdir.join('binary.stl')).endswith('binary.stl')
    assert _get_name(ascii_file, '-').endswith('HalfDonut.stl')
    assert _get_name('-', '-')


</t>
<t tx="leo.20220502161649.136">def _get_name(*args):
    return main._get_name(parser.parse_args(list(map(str, args))))

</t>
<t tx="leo.20220502161649.137">def test_ascii(binary_file, tmpdir, speedups):
    original_argv = sys.argv[:]
    try:
        sys.argv[:] = [
            'stl',
            '-s' if not speedups else '',
            binary_file,
            str(tmpdir.join('ascii.stl')),
        ]
        try:
            main.to_ascii()
        except SystemExit:
            pass
    finally:
        sys.argv[:] = original_argv


</t>
<t tx="leo.20220502161649.138">def test_binary(ascii_file, tmpdir, speedups):
    original_argv = sys.argv[:]
    try:
        sys.argv[:] = [
            'stl',
            '-s' if not speedups else '',
            ascii_file,
            str(tmpdir.join('binary.stl')),
        ]
        try:
            main.to_binary()
        except SystemExit:
            pass
    finally:
        sys.argv[:] = original_argv
</t>
<t tx="leo.20220502161649.139">@path ./numpy-stl/tests/
@language python
@tabwidth -4
# import os
import pytest
import tempfile

from stl import stl


@others
</t>
<t tx="leo.20220502161649.14"></t>
<t tx="leo.20220502161649.140">def _test_conversion(from_, to, mode, speedups):

    for name in from_.listdir():
        source_file = from_.join(name)
        expected_file = to.join(name)
        if not expected_file.exists():
            continue

        mesh = stl.StlMesh(source_file, speedups=speedups)
        with open(str(expected_file), 'rb') as expected_fh:
            expected = expected_fh.read()
            # For binary files, skip the header
            if mode is stl.BINARY:
                expected = expected[80:]

            with tempfile.TemporaryFile() as dest_fh:
                mesh.save(name, dest_fh, mode)
                # Go back to the beginning to read
                dest_fh.seek(0)
                dest = dest_fh.read()
                # For binary files, skip the header
                if mode is stl.BINARY:
                    dest = dest[80:]

                assert dest.strip() == expected.strip()


</t>
<t tx="leo.20220502161649.141">def test_ascii_to_binary(ascii_path, binary_path, speedups):
    _test_conversion(ascii_path, binary_path, mode=stl.BINARY,
                     speedups=speedups)


</t>
<t tx="leo.20220502161649.142">def test_binary_to_ascii(ascii_path, binary_path, speedups):
    _test_conversion(binary_path, ascii_path, mode=stl.ASCII,
                     speedups=speedups)


</t>
<t tx="leo.20220502161649.143">def test_stl_mesh(ascii_file, tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')

    mesh = stl.StlMesh(ascii_file, speedups=speedups)
    with pytest.raises(ValueError):
        mesh.save(filename=str(tmp_file), mode='test')

    mesh.save(str(tmp_file))
    mesh.save(str(tmp_file), update_normals=False)
</t>
<t tx="leo.20220502161649.144">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import pathlib
import pytest
from stl import mesh


FILES_PATH = pathlib.Path(__file__).parent / 'stl_tests'


@others
</t>
<t tx="leo.20220502161649.145">@pytest.mark.parametrize('line_ending', ['dos', 'unix'])
def test_line_endings(line_ending, speedups):
    filename = FILES_PATH / ('%s.stl' % line_ending)
    mesh.Mesh.from_file(filename, speedups=speedups)
</t>
<t tx="leo.20220502161649.146">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import numpy

from stl.mesh import Mesh
from stl.base import BaseMesh
from stl.base import RemoveDuplicates

from . import utils


@others
</t>
<t tx="leo.20220502161649.147">def test_units_1d():
    data = numpy.zeros(1, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [1, 0, 0],
                                      [2, 0, 0]])

    mesh = Mesh(data, remove_empty_areas=False)
    mesh.update_units()

    assert mesh.areas == 0
    utils.array_equals(mesh.normals, [0, 0, 0])
    utils.array_equals(mesh.units, [0, 0, 0])
    utils.array_equals(mesh.get_unit_normals(), [0, 0, 0])


</t>
<t tx="leo.20220502161649.148">def test_units_2d():
    data = numpy.zeros(2, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [1, 0, 0],
                                      [0, 1, 0]])
    data['vectors'][1] = numpy.array([[1, 0, 0],
                                      [0, 1, 0],
                                      [1, 1, 0]])

    mesh = Mesh(data, remove_empty_areas=False)
    mesh.update_units()

    assert numpy.allclose(mesh.areas, [0.5, 0.5])
    assert numpy.allclose(mesh.normals, [
                          [0.0, 0.0, 1.0],
                          [0.0, 0.0, -1.0]])
    assert numpy.allclose(mesh.units, [[0, 0, 1], [0, 0, -1]])
    assert numpy.allclose(mesh.get_unit_normals(), [
                          [0.0, 0.0, 1.0],
                          [0.0, 0.0, -1.0]])


</t>
<t tx="leo.20220502161649.149">def test_units_3d():
    data = numpy.zeros(1, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [1, 0, 0],
                                      [0, 1, 1.]])

    mesh = Mesh(data, remove_empty_areas=False)
    mesh.update_units()

    assert (mesh.areas - 2 ** .5) &lt; 0.0001
    assert numpy.allclose(mesh.normals, [0.0, -1.0, 1.0])
    assert numpy.allclose(mesh.units[0], [0.0, -0.70710677, 0.70710677])
    assert numpy.allclose(numpy.linalg.norm(mesh.units, axis=-1), 1)
    assert numpy.allclose(mesh.get_unit_normals(),
                          [0.0, -0.70710677, 0.70710677])


</t>
<t tx="leo.20220502161649.15">@path ./numpy-stl/docs/_theme/
@language python
@tabwidth -4
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
    Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


@others
</t>
<t tx="leo.20220502161649.150">def test_duplicate_polygons():
    data = numpy.zeros(6, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[1, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][1] = numpy.array([[2, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][2] = numpy.array([[0, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][3] = numpy.array([[2, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][4] = numpy.array([[1, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][5] = numpy.array([[0, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])

    mesh = Mesh(data)
    assert mesh.data.size == 6

    mesh = Mesh(data, remove_duplicate_polygons=0)
    assert mesh.data.size == 6

    mesh = Mesh(data, remove_duplicate_polygons=False)
    assert mesh.data.size == 6

    mesh = Mesh(data, remove_duplicate_polygons=None)
    assert mesh.data.size == 6

    mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.NONE)
    assert mesh.data.size == 6

    mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.SINGLE)
    assert mesh.data.size == 3

    mesh = Mesh(data, remove_duplicate_polygons=True)
    assert mesh.data.size == 3

    assert numpy.allclose(mesh.vectors[0], numpy.array([[1, 0, 0],
                                                        [0, 0, 0],
                                                        [0, 0, 0]]))
    assert numpy.allclose(mesh.vectors[1], numpy.array([[2, 0, 0],
                                                        [0, 0, 0],
                                                        [0, 0, 0]]))
    assert numpy.allclose(mesh.vectors[2], numpy.array([[0, 0, 0],
                                                        [0, 0, 0],
                                                        [0, 0, 0]]))

    mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.ALL)
    assert mesh.data.size == 3

    assert numpy.allclose(mesh.vectors[0], numpy.array([[1, 0, 0],
                                                        [0, 0, 0],
                                                        [0, 0, 0]]))
    assert numpy.allclose(mesh.vectors[1], numpy.array([[2, 0, 0],
                                                        [0, 0, 0],
                                                        [0, 0, 0]]))
    assert numpy.allclose(mesh.vectors[2], numpy.array([[0, 0, 0],
                                                        [0, 0, 0],
                                                        [0, 0, 0]]))


</t>
<t tx="leo.20220502161649.151">def test_remove_all_duplicate_polygons():
    data = numpy.zeros(5, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][1] = numpy.array([[1, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][2] = numpy.array([[2, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][3] = numpy.array([[3, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])
    data['vectors'][4] = numpy.array([[3, 0, 0],
                                      [0, 0, 0],
                                      [0, 0, 0]])

    mesh = Mesh(data, remove_duplicate_polygons=False)
    assert mesh.data.size == 5
    Mesh.remove_duplicate_polygons(mesh.data, RemoveDuplicates.NONE)

    mesh = Mesh(data, remove_duplicate_polygons=RemoveDuplicates.ALL)
    assert mesh.data.size == 3

    assert (mesh.vectors[0] == numpy.array([[0, 0, 0],
                                            [0, 0, 0],
                                            [0, 0, 0]])).all()
    assert (mesh.vectors[1] == numpy.array([[1, 0, 0],
                                            [0, 0, 0],
                                            [0, 0, 0]])).all()
    assert (mesh.vectors[2] == numpy.array([[2, 0, 0],
                                            [0, 0, 0],
                                            [0, 0, 0]])).all()


</t>
<t tx="leo.20220502161649.152">def test_empty_areas():
    data = numpy.zeros(3, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 0, 0],
                                      [1, 0, 0],
                                      [0, 1, 0]])
    data['vectors'][1] = numpy.array([[1, 0, 0],
                                      [0, 1, 0],
                                      [1, 0, 0]])
    data['vectors'][2] = numpy.array([[1, 0, 0],
                                      [0, 1, 0],
                                      [1, 0, 0]])

    mesh = Mesh(data, calculate_normals=False, remove_empty_areas=False)
    assert mesh.data.size == 3

    # Test the normals recalculation which also calculates the areas by default
    mesh.areas[1] = 1
    mesh.areas[2] = 2
    assert numpy.allclose(mesh.areas, [[0.5], [1.0], [2.0]])

    mesh.update_normals(update_areas=False)
    assert numpy.allclose(mesh.areas, [[0.5], [1.0], [2.0]])

    mesh.update_normals(update_areas=True)
    assert numpy.allclose(mesh.areas, [[0.5], [0.0], [0.0]])

    mesh = Mesh(data, remove_empty_areas=True)
    assert mesh.data.size == 1


</t>
<t tx="leo.20220502161649.153">def test_base_mesh():
    data = numpy.zeros(10, dtype=BaseMesh.dtype)
    mesh = BaseMesh(data, remove_empty_areas=False)
    # Increment vector 0 item 0
    mesh.v0[0] += 1
    mesh.v1[0] += 2

    # Check item 0 (contains v0, v1 and v2)
    assert (mesh[0] == numpy.array(
        [1., 1., 1., 2., 2., 2., 0., 0., 0.], dtype=numpy.float32)
    ).all()
    assert (mesh.vectors[0] == numpy.array([
            [1., 1., 1.],
            [2., 2., 2.],
            [0., 0., 0.]], dtype=numpy.float32)).all()
    assert (mesh.v0[0] == numpy.array([1., 1., 1.], dtype=numpy.float32)).all()
    assert (mesh.points[0] == numpy.array(
        [1., 1., 1., 2., 2., 2., 0., 0., 0.], dtype=numpy.float32)
    ).all()
    assert (
        mesh.x[0] == numpy.array([1., 2., 0.], dtype=numpy.float32)).all()

    mesh[0] = 3
    assert (mesh[0] == numpy.array(
        [3., 3., 3., 3., 3., 3., 3., 3., 3.], dtype=numpy.float32)
    ).all()

    assert len(mesh) == len(list(mesh))
    assert (mesh.min_ &lt; mesh.max_).all()
    mesh.update_normals()
    assert mesh.units.sum() == 0.0
    mesh.v0[:] = mesh.v1[:] = mesh.v2[:] = 0
    assert mesh.points.sum() == 0.0
</t>
<t tx="leo.20220502161649.154">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import numpy
import pytest

from stl import stl


tolerance = 1e-6


@others
</t>
<t tx="leo.20220502161649.155">def close(a, b):
    return numpy.allclose(a, b, atol=tolerance)


</t>
<t tx="leo.20220502161649.156">def test_mass_properties_for_half_donut(binary_ascii_path, speedups):
    '''
    Checks the results of method get_mass_properties() on
    STL ASCII and binary files HalfDonut.stl
    One checks the results obtained with stl
    with the ones obtained with meshlab
    '''
    filename = binary_ascii_path.join('HalfDonut.stl')
    mesh = stl.StlMesh(str(filename), speedups=speedups)
    volume, cog, inertia = mesh.get_mass_properties()
    assert close([volume], [2.343149])
    assert close(cog, [1.500001, 0.209472, 1.500001])
    assert close(inertia, [[+1.390429, +0.000000, +0.000000],
                           [+0.000000, +2.701025, +0.000000],
                           [+0.000000, +0.000000, +1.390429]])


</t>
<t tx="leo.20220502161649.157">def test_mass_properties_for_moon(binary_ascii_path, speedups):
    '''
    Checks the results of method get_mass_properties() on
    STL ASCII and binary files Moon.stl
    One checks the results obtained with stl
    with the ones obtained with meshlab
    '''
    filename = binary_ascii_path.join('Moon.stl')
    mesh = stl.StlMesh(str(filename), speedups=speedups)
    volume, cog, inertia = mesh.get_mass_properties()
    assert close([volume], [0.888723])
    assert close(cog, [0.906913, 0.170731, 1.500001])
    assert close(inertia, [[+0.562097, -0.000457, +0.000000],
                           [-0.000457, +0.656851, +0.000000],
                           [+0.000000, +0.000000, +0.112465]])


</t>
<t tx="leo.20220502161649.158">@pytest.mark.parametrize('filename', ('Star.stl', 'StarWithEmptyHeader.stl'))
def test_mass_properties_for_star(binary_ascii_path, filename, speedups):
    '''
    Checks the results of method get_mass_properties() on
    STL ASCII and binary files Star.stl and
    STL binary file StarWithEmptyHeader.stl (with no header)
    One checks the results obtained with stl
    with the ones obtained with meshlab
    '''
    filename = binary_ascii_path.join(filename)
    if not filename.exists():
        pytest.skip('STL file does not exist')
    mesh = stl.StlMesh(str(filename), speedups=speedups)
    volume, cog, inertia = mesh.get_mass_properties()
    assert close([volume], [1.416599])
    assert close(cog, [1.299040, 0.170197, 1.499999])
    assert close(inertia, [[+0.509549, +0.000000, -0.000000],
                           [+0.000000, +0.991236, +0.000000],
                           [-0.000000, +0.000000, +0.509550]])


</t>
<t tx="leo.20220502161649.159">def test_mass_properties_for_half_donut_with_density(
        binary_ascii_path, speedups):
    '''
    Checks the results of method get_mass_properties_with_density() on
    STL ASCII and binary files HalfDonut.stl
    One checks the results obtained with stl
    with the ones obtained with meshlab
    '''
    filename = binary_ascii_path.join('HalfDonut.stl')
    mesh = stl.StlMesh(str(filename), speedups=speedups)
    volume, mass, cog, inertia = mesh.get_mass_properties_with_density(1.23)

    assert close([mass], [2.882083302268982])
    assert close([volume], [2.343149026234945])
    assert close(cog, [1.500001, 0.209472, 1.500001])
    print('inertia')
    numpy.set_printoptions(suppress=True)
    print(inertia)
    assert close(inertia, [[+1.71022851, +0.00000001, -0.00000011],
                           [+0.00000001, +3.32226227, +0.00000002],
                           [-0.00000011, +0.00000002, +1.71022859]])
</t>
<t tx="leo.20220502161649.16">class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        # Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929",  # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902",  # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902",  # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000",  # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }
</t>
<t tx="leo.20220502161649.160">@path ./numpy-stl/tests/
@language python
@tabwidth -4
from stl import mesh
from stl.utils import b

_STL_FILE = b('''
solid test.stl
facet normal -0.014565 0.073223 -0.002897
  outer loop
    vertex 0.399344 0.461940 1.044090
    vertex 0.500000 0.500000 1.500000
    vertex 0.576120 0.500000 1.117320
  endloop
endfacet
endsolid test.stl
'''.lstrip())


@others
</t>
<t tx="leo.20220502161649.161">def test_single_stl(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        fh.write(_STL_FILE)
        fh.seek(0)
        for m in mesh.Mesh.from_multi_file(
                str(tmp_file), fh=fh, speedups=speedups):
            pass


</t>
<t tx="leo.20220502161649.162">def test_multiple_stl(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        for _ in range(10):
            fh.write(_STL_FILE)
        fh.seek(0)
        for i, m in enumerate(mesh.Mesh.from_multi_file(
                str(tmp_file), fh=fh, speedups=speedups)):
            assert m.name == b'test.stl'

        assert i == 9


</t>
<t tx="leo.20220502161649.163">def test_single_stl_file(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        fh.write(_STL_FILE)
        fh.seek(0)
        for m in mesh.Mesh.from_multi_file(
                str(tmp_file), speedups=speedups):
            pass


</t>
<t tx="leo.20220502161649.164">def test_multiple_stl_file(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        for _ in range(10):
            fh.write(_STL_FILE)

        fh.seek(0)
        for i, m in enumerate(mesh.Mesh.from_multi_file(
                str(tmp_file), speedups=speedups)):
            assert m.name == b'test.stl'

        assert i == 9


</t>
<t tx="leo.20220502161649.165">def test_multiple_stl_files(tmpdir, speedups):
    tmp_file = tmpdir.join('tmp.stl')
    with tmp_file.open('wb+') as fh:
        fh.write(_STL_FILE)
        fh.seek(0)

        filenames = [str(tmp_file)] * 10

        m = mesh.Mesh.from_files(filenames, speedups=speedups)
        assert m.data.size == 10


</t>
<t tx="leo.20220502161649.166">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import math
import numpy
import pytest

from stl.mesh import Mesh

from . import utils


@others
</t>
<t tx="leo.20220502161649.167">def test_rotation():
    # Create 6 faces of a cube
    data = numpy.zeros(6, dtype=Mesh.dtype)

    # Top of the cube
    data['vectors'][0] = numpy.array([[0, 1, 1],
                                      [1, 0, 1],
                                      [0, 0, 1]])
    data['vectors'][1] = numpy.array([[1, 0, 1],
                                      [0, 1, 1],
                                      [1, 1, 1]])
    # Right face
    data['vectors'][2] = numpy.array([[1, 0, 0],
                                      [1, 0, 1],
                                      [1, 1, 0]])
    data['vectors'][3] = numpy.array([[1, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]])
    # Left face
    data['vectors'][4] = numpy.array([[0, 0, 0],
                                      [1, 0, 0],
                                      [1, 0, 1]])
    data['vectors'][5] = numpy.array([[0, 0, 0],
                                      [0, 0, 1],
                                      [1, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)

    # Since the cube faces are from 0 to 1 we can move it to the middle by
    # substracting .5
    data['vectors'] -= .5

    # Rotate 90 degrees over the X axis followed by the Y axis followed by the
    # X axis
    mesh.rotate([0.5, 0.0, 0.0], math.radians(90))
    mesh.rotate([0.0, 0.5, 0.0], math.radians(90))
    mesh.rotate([0.5, 0.0, 0.0], math.radians(90))

    # Since the cube faces are from 0 to 1 we can move it to the middle by
    # substracting .5
    data['vectors'] += .5

    # We use a slightly higher absolute tolerance here, for ppc64le
    # https://github.com/WoLpH/numpy-stl/issues/78
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[1, 0, 0], [0, 1, 0], [0, 0, 0]],
        [[0, 1, 0], [1, 0, 0], [1, 1, 0]],
        [[0, 1, 1], [0, 1, 0], [1, 1, 1]],
        [[1, 1, 0], [0, 1, 0], [1, 1, 1]],
        [[0, 0, 1], [0, 1, 1], [0, 1, 0]],
        [[0, 0, 1], [0, 0, 0], [0, 1, 0]],
    ]), atol=1e-07)


</t>
<t tx="leo.20220502161649.168">def test_rotation_over_point():
    # Create a single face
    data = numpy.zeros(1, dtype=Mesh.dtype)

    data['vectors'][0] = numpy.array([[1, 0, 0],
                                      [0, 1, 0],
                                      [0, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)

    mesh.rotate([1, 0, 0], math.radians(180), point=[1, 2, 3])
    utils.array_equals(
        mesh.vectors,
        numpy.array([[[1., 4., 6.],
                      [0., 3., 6.],
                      [0., 4., 5.]]]))

    mesh.rotate([1, 0, 0], math.radians(-180), point=[1, 2, 3])
    utils.array_equals(
        mesh.vectors,
        numpy.array([[[1, 0, 0],
                      [0, 1, 0],
                      [0, 0, 1]]]))

    mesh.rotate([1, 0, 0], math.radians(180), point=0.0)
    utils.array_equals(
        mesh.vectors,
        numpy.array([[[1., 0., -0.],
                      [0., -1., -0.],
                      [0., 0., -1.]]]))

    with pytest.raises(TypeError):
        mesh.rotate([1, 0, 0], math.radians(180), point='x')


</t>
<t tx="leo.20220502161649.169">def test_double_rotation():
    # Create a single face
    data = numpy.zeros(1, dtype=Mesh.dtype)

    data['vectors'][0] = numpy.array([[1, 0, 0],
                                      [0, 1, 0],
                                      [0, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)

    rotation_matrix = mesh.rotation_matrix([1, 0, 0], math.radians(180))
    combined_rotation_matrix = numpy.dot(rotation_matrix, rotation_matrix)

    mesh.rotate_using_matrix(combined_rotation_matrix)
    utils.array_equals(
        mesh.vectors,
        numpy.array([[[1., 0., 0.],
                      [0., 1., 0.],
                      [0., 0., 1.]]]))


</t>
<t tx="leo.20220502161649.17"></t>
<t tx="leo.20220502161649.170">def test_no_rotation():
    # Create a single face
    data = numpy.zeros(1, dtype=Mesh.dtype)

    data['vectors'][0] = numpy.array([[0, 1, 1],
                                      [1, 0, 1],
                                      [0, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)

    # Rotate by 0 degrees
    mesh.rotate([0.5, 0.0, 0.0], math.radians(0))
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))

    # Use a zero rotation matrix
    mesh.rotate([0.0, 0.0, 0.0], math.radians(90))
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))


</t>
<t tx="leo.20220502161649.171">def test_no_translation():
    # Create a single face
    data = numpy.zeros(1, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 1, 1],
                                      [1, 0, 1],
                                      [0, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))

    # Translate mesh with a zero vector
    mesh.translate([0.0, 0.0, 0.0])
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))


</t>
<t tx="leo.20220502161649.172">def test_translation():
    # Create a single face
    data = numpy.zeros(1, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 1, 1],
                                      [1, 0, 1],
                                      [0, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))

    # Translate mesh with vector [1, 2, 3]
    mesh.translate([1.0, 2.0, 3.0])
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[1, 3, 4], [2, 2, 4], [1, 2, 4]]]))


</t>
<t tx="leo.20220502161649.173">def test_no_transformation():
    # Create a single face
    data = numpy.zeros(1, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 1, 1],
                                      [1, 0, 1],
                                      [0, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))

    # Transform mesh with identity matrix
    mesh.transform(numpy.eye(4))
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))
    assert numpy.allclose(mesh.areas, 0.5)


</t>
<t tx="leo.20220502161649.174">def test_transformation():
    # Create a single face
    data = numpy.zeros(1, dtype=Mesh.dtype)
    data['vectors'][0] = numpy.array([[0, 1, 1],
                                      [1, 0, 1],
                                      [0, 0, 1]])

    mesh = Mesh(data, remove_empty_areas=False)
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 1, 1], [1, 0, 1], [0, 0, 1]]]))

    # Transform mesh with identity matrix
    tr = numpy.zeros((4, 4))
    tr[0:3, 0:3] = Mesh.rotation_matrix([0, 0, 1], 0.5 * numpy.pi)
    tr[0:3, 3] = [1, 2, 3]
    mesh.transform(tr)
    assert numpy.allclose(mesh.vectors, numpy.array([
        [[0, 2, 4], [1, 3, 4], [1, 2, 4]]]))
    assert numpy.allclose(mesh.areas, 0.5)
</t>
<t tx="leo.20220502161649.175">@path ./numpy-stl/tests/
@language python
@tabwidth -4
import numpy


@others
</t>
<t tx="leo.20220502161649.176">def to_array(array, round):
    __tracebackhide__ = True

    if not isinstance(array, numpy.ndarray):
        array = numpy.array(array)

    if round:
        array = array.round(round)

    return array


</t>
<t tx="leo.20220502161649.177">def array_equals(left, right, round=6):
    __tracebackhide__ = True
    left = to_array(left, round)
    right = to_array(right, round)

    message = 'Arrays are unequal:\n%s\n%s' % (left, right)
    if left.size == right.size:
        message += '\nDifference:\n%s' % (left - right)

    assert (left == right).all(), message
</t>
<t tx="leo.20220502161649.178">@path ./numpy-stl/tests/
@language python
@tabwidth -4
</t>
<t tx="leo.20220502161649.19"></t>
<t tx="leo.20220502161649.2"></t>
<t tx="leo.20220502161649.20">@path ./numpy-stl/stl/
@language python
@tabwidth -4
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)
import enum
import math
import numpy
import logging
try:  # pragma: no cover
    from collections import abc
except ImportError:  # pragma: no cover
    import collections as abc

from python_utils import logger

from .utils import s

#: When removing empty areas, remove areas that are smaller than this
AREA_SIZE_THRESHOLD = 0
#: Vectors in a point
VECTORS = 3
#: Dimensions used in a vector
DIMENSIONS = 3


@others
</t>
<t tx="leo.20220502161649.21">class Dimension(enum.IntEnum):
    #: X index (for example, `mesh.v0[0][X]`)
    X = 0
    #: Y index (for example, `mesh.v0[0][Y]`)
    Y = 1
    #: Z index (for example, `mesh.v0[0][Z]`)
    Z = 2


</t>
<t tx="leo.20220502161649.22"># For backwards compatibility, leave the original references
X = Dimension.X
Y = Dimension.Y
Z = Dimension.Z


</t>
<t tx="leo.20220502161649.23">class RemoveDuplicates(enum.Enum):
    '''
    Choose whether to remove no duplicates, leave only a single of the
    duplicates or remove all duplicates (leaving holes).
    '''
    NONE = 0
    SINGLE = 1
    ALL = 2

    @others
</t>
<t tx="leo.20220502161649.24">@classmethod
def map(cls, value):
    if value is True:
        value = cls.SINGLE
    elif value and value in cls:
        pass
    else:
        value = cls.NONE

    return value


</t>
<t tx="leo.20220502161649.25">def logged(class_):
    # For some reason the Logged baseclass is not properly initiated on Linux
    # systems while this works on OS X. Please let me know if you can tell me
    # what silly mistake I made here

    logger_name = logger.Logged._Logged__get_name(
        __name__,
        class_.__name__,
    )

    class_.logger = logging.getLogger(logger_name)

    for key in dir(logger.Logged):
        if not key.startswith('__'):
            setattr(class_, key, getattr(class_, key))

    return class_


</t>
<t tx="leo.20220502161649.26">@logged
class BaseMesh(logger.Logged, abc.Mapping):
    '''
    Mesh object with easy access to the vectors through v0, v1 and v2.
    The normals, areas, min, max and units are calculated automatically.

    :param numpy.array data: The data for this mesh
    :param bool calculate_normals: Whether to calculate the normals
    :param bool remove_empty_areas: Whether to remove triangles with 0 area
            (due to rounding errors for example)

    :ivar str name: Name of the solid, only exists in ASCII files
    :ivar numpy.array data: Data as :func:`BaseMesh.dtype`
    :ivar numpy.array points: All points (Nx9)
    :ivar numpy.array normals: Normals for this mesh, calculated automatically
        by default (Nx3)
    :ivar numpy.array vectors: Vectors in the mesh (Nx3x3)
    :ivar numpy.array attr: Attributes per vector (used by binary STL)
    :ivar numpy.array x: Points on the X axis by vertex (Nx3)
    :ivar numpy.array y: Points on the Y axis by vertex (Nx3)
    :ivar numpy.array z: Points on the Z axis by vertex (Nx3)
    :ivar numpy.array v0: Points in vector 0 (Nx3)
    :ivar numpy.array v1: Points in vector 1 (Nx3)
    :ivar numpy.array v2: Points in vector 2 (Nx3)

    &gt;&gt;&gt; data = numpy.zeros(10, dtype=BaseMesh.dtype)
    &gt;&gt;&gt; mesh = BaseMesh(data, remove_empty_areas=False)
    &gt;&gt;&gt; # Increment vector 0 item 0
    &gt;&gt;&gt; mesh.v0[0] += 1
    &gt;&gt;&gt; mesh.v1[0] += 2

    &gt;&gt;&gt; # Check item 0 (contains v0, v1 and v2)
    &gt;&gt;&gt; assert numpy.array_equal(
    ...     mesh[0],
    ...     numpy.array([1., 1., 1., 2., 2., 2., 0., 0., 0.]))
    &gt;&gt;&gt; assert numpy.array_equal(
    ... mesh.vectors[0],
    ... numpy.array([[1., 1., 1.],
    ...     [2., 2., 2.],
    ...     [0., 0., 0.]]))
    &gt;&gt;&gt; assert numpy.array_equal(
    ...     mesh.v0[0],
    ...     numpy.array([1., 1., 1.]))
    &gt;&gt;&gt; assert numpy.array_equal(
    ...     mesh.points[0],
    ...     numpy.array([1., 1., 1., 2., 2., 2., 0., 0., 0.]))
    &gt;&gt;&gt; assert numpy.array_equal(
    ...     mesh.data[0],
    ...     numpy.array((
    ...             [0., 0., 0.],
    ...             [[1., 1., 1.], [2., 2., 2.], [0., 0., 0.]],
    ...             [0]),
    ...         dtype=BaseMesh.dtype))
    &gt;&gt;&gt; assert numpy.array_equal(mesh.x[0], numpy.array([1., 2., 0.]))

    &gt;&gt;&gt; mesh[0] = 3
    &gt;&gt;&gt; assert numpy.array_equal(
    ...     mesh[0],
    ...     numpy.array([3., 3., 3., 3., 3., 3., 3., 3., 3.]))

    &gt;&gt;&gt; len(mesh) == len(list(mesh))
    True
    &gt;&gt;&gt; (mesh.min_ &lt; mesh.max_).all()
    True
    &gt;&gt;&gt; mesh.update_normals()
    &gt;&gt;&gt; mesh.units.sum()
    0.0
    &gt;&gt;&gt; mesh.v0[:] = mesh.v1[:] = mesh.v2[:] = 0
    &gt;&gt;&gt; mesh.points.sum()
    0.0

    &gt;&gt;&gt; mesh.v0 = mesh.v1 = mesh.v2 = 0
    &gt;&gt;&gt; mesh.x = mesh.y = mesh.z = 0

    &gt;&gt;&gt; mesh.attr = 1
    &gt;&gt;&gt; (mesh.attr == 1).all()
    True

    &gt;&gt;&gt; mesh.normals = 2
    &gt;&gt;&gt; (mesh.normals == 2).all()
    True

    &gt;&gt;&gt; mesh.vectors = 3
    &gt;&gt;&gt; (mesh.vectors == 3).all()
    True

    &gt;&gt;&gt; mesh.points = 4
    &gt;&gt;&gt; (mesh.points == 4).all()
    True
    '''
    #: - normals: :func:`numpy.float32`, `(3, )`
    #: - vectors: :func:`numpy.float32`, `(3, 3)`
    #: - attr: :func:`numpy.uint16`, `(1, )`
    dtype = numpy.dtype([
        (s('normals'), numpy.float32, (3, )),
        (s('vectors'), numpy.float32, (3, 3)),
        (s('attr'), numpy.uint16, (1, )),
    ])
    dtype = dtype.newbyteorder('&lt;')  # Even on big endian arches, use little e.

    @others
</t>
<t tx="leo.20220502161649.27">def __init__(self, data, calculate_normals=True,
             remove_empty_areas=False,
             remove_duplicate_polygons=RemoveDuplicates.NONE,
             name='', speedups=True, **kwargs):
    super(BaseMesh, self).__init__(**kwargs)
    self.speedups = speedups
    if remove_empty_areas:
        data = self.remove_empty_areas(data)

    if RemoveDuplicates.map(remove_duplicate_polygons).value:
        data = self.remove_duplicate_polygons(data,
                                              remove_duplicate_polygons)

    self.name = name
    self.data = data

    if calculate_normals:
        self.update_normals()

</t>
<t tx="leo.20220502161649.28">@property
def attr(self):
    return self.data['attr']

</t>
<t tx="leo.20220502161649.29">@attr.setter
def attr(self, value):
    self.data['attr'] = value

</t>
<t tx="leo.20220502161649.3">@path ./numpy-stl/
@language python
@tabwidth -4
from __future__ import print_function

import os
import sys
import warnings
from setuptools import setup, extension
from setuptools.command.build_ext import build_ext
from setuptools.command.test import test as TestCommand

setup_kwargs = {}


@others
if __name__ == '__main__':
    setup(
        name=about['__package_name__'],
        version=about['__version__'],
        author=about['__author__'],
        author_email=about['__author_email__'],
        description=about['__description__'],
        url=about['__url__'],
        license='BSD',
        packages=['stl'],
        package_data={about['__import_name__']: ['py.typed']},
        long_description=long_description,
        tests_require=tests_require,
        entry_points={
            'console_scripts': [
                'stl = %s.main:main' % about['__import_name__'],
                'stl2ascii = %s.main:to_ascii' % about['__import_name__'],
                'stl2bin = %s.main:to_binary' % about['__import_name__'],
            ],
        },
        classifiers=[
            'Development Status :: 6 - Mature',
            'Intended Audience :: Developers',
            'License :: OSI Approved :: BSD License',
            'Operating System :: OS Independent',
            'Natural Language :: English',
            'Programming Language :: Python',
            'Programming Language :: Python :: 2',
            'Programming Language :: Python :: 2.7',
            'Programming Language :: Python :: 3',
            'Programming Language :: Python :: 3.4',
            'Programming Language :: Python :: 3.5',
            'Programming Language :: Python :: 3.6',
            'Programming Language :: Python :: 3.7',
            'Topic :: Software Development :: Libraries :: Python Modules',
        ],
        install_requires=install_requires,
        cmdclass=dict(
            build_ext=BuildExt,
            test=PyTest,
        ),
        **setup_kwargs
    )

</t>
<t tx="leo.20220502161649.30">@property
def normals(self):
    return self.data['normals']

</t>
<t tx="leo.20220502161649.31">@normals.setter
def normals(self, value):
    self.data['normals'] = value

</t>
<t tx="leo.20220502161649.32">@property
def vectors(self):
    return self.data['vectors']

</t>
<t tx="leo.20220502161649.33">@vectors.setter
def vectors(self, value):
    self.data['vectors'] = value

</t>
<t tx="leo.20220502161649.34">@property
def points(self):
    return self.vectors.reshape(self.data.size, 9)

</t>
<t tx="leo.20220502161649.35">@points.setter
def points(self, value):
    self.points[:] = value

</t>
<t tx="leo.20220502161649.36">@property
def v0(self):
    return self.vectors[:, 0]

</t>
<t tx="leo.20220502161649.37">@v0.setter
def v0(self, value):
    self.vectors[:, 0] = value

</t>
<t tx="leo.20220502161649.38">@property
def v1(self):
    return self.vectors[:, 1]

</t>
<t tx="leo.20220502161649.39">@v1.setter
def v1(self, value):
    self.vectors[:, 1] = value

</t>
<t tx="leo.20220502161649.4">def error(*lines):
    for line in lines:
        print(line, file=sys.stderr)


</t>
<t tx="leo.20220502161649.40">@property
def v2(self):
    return self.vectors[:, 2]

</t>
<t tx="leo.20220502161649.41">@v2.setter
def v2(self, value):
    self.vectors[:, 2] = value

</t>
<t tx="leo.20220502161649.42">@property
def x(self):
    return self.points[:, Dimension.X::3]

</t>
<t tx="leo.20220502161649.43">@x.setter
def x(self, value):
    self.points[:, Dimension.X::3] = value

</t>
<t tx="leo.20220502161649.44">@property
def y(self):
    return self.points[:, Dimension.Y::3]

</t>
<t tx="leo.20220502161649.45">@y.setter
def y(self, value):
    self.points[:, Dimension.Y::3] = value

</t>
<t tx="leo.20220502161649.46">@property
def z(self):
    return self.points[:, Dimension.Z::3]

</t>
<t tx="leo.20220502161649.47">@z.setter
def z(self, value):
    self.points[:, Dimension.Z::3] = value

</t>
<t tx="leo.20220502161649.48">@classmethod
def remove_duplicate_polygons(cls, data, value=RemoveDuplicates.SINGLE):
    value = RemoveDuplicates.map(value)
    polygons = data['vectors'].sum(axis=1)
    # Get a sorted list of indices
    idx = numpy.lexsort(polygons.T)
    # Get the indices of all different indices
    diff = numpy.any(polygons[idx[1:]] != polygons[idx[:-1]], axis=1)

    if value is RemoveDuplicates.SINGLE:
        # Only return the unique data, the True is so we always get at
        # least the originals
        return data[numpy.sort(idx[numpy.concatenate(([True], diff))])]
    elif value is RemoveDuplicates.ALL:
        # We need to return both items of the shifted diff
        diff_a = numpy.concatenate(([True], diff))
        diff_b = numpy.concatenate((diff, [True]))
        diff = numpy.concatenate((diff, [False]))

        # Combine both unique lists
        filtered_data = data[numpy.sort(idx[diff_a &amp; diff_b])]
        if len(filtered_data) &lt;= len(data) / 2:
            return data[numpy.sort(idx[diff_a])]
        else:
            return data[numpy.sort(idx[diff])]
    else:
        return data

</t>
<t tx="leo.20220502161649.49">@classmethod
def remove_empty_areas(cls, data):
    vectors = data['vectors']
    v0 = vectors[:, 0]
    v1 = vectors[:, 1]
    v2 = vectors[:, 2]
    normals = numpy.cross(v1 - v0, v2 - v0)
    squared_areas = (normals ** 2).sum(axis=1)
    return data[squared_areas &gt; AREA_SIZE_THRESHOLD ** 2]

</t>
<t tx="leo.20220502161649.5">try:
    from stl import stl
    if not hasattr(stl, 'BaseStl'):
        error('ERROR',
              'You have an incompatible stl package installed'
              'Please run "pip uninstall -y stl" first')
        sys.exit(1)
except ImportError:
    pass


</t>
<t tx="leo.20220502161649.50">def update_normals(self, update_areas=True):
    '''Update the normals and areas for all points'''
    normals = numpy.cross(self.v1 - self.v0, self.v2 - self.v0)

    if update_areas:
        self.update_areas(normals)

    self.normals[:] = normals

</t>
<t tx="leo.20220502161649.51">def get_unit_normals(self):
    normals = self.normals.copy()
    normal = numpy.linalg.norm(normals, axis=1)
    non_zero = normal &gt; 0
    if non_zero.any():
        normals[non_zero] /= normal[non_zero][:, None]
    return normals

</t>
<t tx="leo.20220502161649.52">def update_min(self):
    self._min = self.vectors.min(axis=(0, 1))

</t>
<t tx="leo.20220502161649.53">def update_max(self):
    self._max = self.vectors.max(axis=(0, 1))

</t>
<t tx="leo.20220502161649.54">def update_areas(self, normals=None):
    if normals is None:
        normals = numpy.cross(self.v1 - self.v0, self.v2 - self.v0)

    areas = .5 * numpy.sqrt((normals ** 2).sum(axis=1))
    self.areas = areas.reshape((areas.size, 1))

</t>
<t tx="leo.20220502161649.55">def check(self):
    '''Check the mesh is valid or not'''
    return self.is_closed()

</t>
<t tx="leo.20220502161649.56">def is_closed(self):  # pragma: no cover
    """Check the mesh is closed or not"""
    if numpy.isclose(self.normals.sum(axis=0), 0, atol=1e-4).all():
        return True
    else:
        self.warning('''
        Your mesh is not closed, the mass methods will not function
        correctly on this mesh.  For more info:
        https://github.com/WoLpH/numpy-stl/issues/69
        '''.strip())
        return False

</t>
<t tx="leo.20220502161649.57">def get_mass_properties(self):
    '''
    Evaluate and return a tuple with the following elements:
      - the volume
      - the position of the center of gravity (COG)
      - the inertia matrix expressed at the COG

    Documentation can be found here:
    http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf
    '''
    self.check()

    def subexpression(x):
        w0, w1, w2 = x[:, 0], x[:, 1], x[:, 2]
        temp0 = w0 + w1
        f1 = temp0 + w2
        temp1 = w0 * w0
        temp2 = temp1 + w1 * temp0
        f2 = temp2 + w2 * f1
        f3 = w0 * temp1 + w1 * temp2 + w2 * f2
        g0 = f2 + w0 * (f1 + w0)
        g1 = f2 + w1 * (f1 + w1)
        g2 = f2 + w2 * (f1 + w2)
        return f1, f2, f3, g0, g1, g2

    x0, x1, x2 = self.x[:, 0], self.x[:, 1], self.x[:, 2]
    y0, y1, y2 = self.y[:, 0], self.y[:, 1], self.y[:, 2]
    z0, z1, z2 = self.z[:, 0], self.z[:, 1], self.z[:, 2]
    a1, b1, c1 = x1 - x0, y1 - y0, z1 - z0
    a2, b2, c2 = x2 - x0, y2 - y0, z2 - z0
    d0, d1, d2 = b1 * c2 - b2 * c1, a2 * c1 - a1 * c2, a1 * b2 - a2 * b1

    f1x, f2x, f3x, g0x, g1x, g2x = subexpression(self.x)
    f1y, f2y, f3y, g0y, g1y, g2y = subexpression(self.y)
    f1z, f2z, f3z, g0z, g1z, g2z = subexpression(self.z)

    intg = numpy.zeros((10))
    intg[0] = sum(d0 * f1x)
    intg[1:4] = sum(d0 * f2x), sum(d1 * f2y), sum(d2 * f2z)
    intg[4:7] = sum(d0 * f3x), sum(d1 * f3y), sum(d2 * f3z)
    intg[7] = sum(d0 * (y0 * g0x + y1 * g1x + y2 * g2x))
    intg[8] = sum(d1 * (z0 * g0y + z1 * g1y + z2 * g2y))
    intg[9] = sum(d2 * (x0 * g0z + x1 * g1z + x2 * g2z))
    intg /= numpy.array([6, 24, 24, 24, 60, 60, 60, 120, 120, 120])
    volume = intg[0]
    cog = intg[1:4] / volume
    cogsq = cog ** 2
    inertia = numpy.zeros((3, 3))
    inertia[0, 0] = intg[5] + intg[6] - volume * (cogsq[1] + cogsq[2])
    inertia[1, 1] = intg[4] + intg[6] - volume * (cogsq[2] + cogsq[0])
    inertia[2, 2] = intg[4] + intg[5] - volume * (cogsq[0] + cogsq[1])
    inertia[0, 1] = inertia[1, 0] = -(intg[7] - volume * cog[0] * cog[1])
    inertia[1, 2] = inertia[2, 1] = -(intg[8] - volume * cog[1] * cog[2])
    inertia[0, 2] = inertia[2, 0] = -(intg[9] - volume * cog[2] * cog[0])
    return volume, cog, inertia

</t>
<t tx="leo.20220502161649.58">def update_units(self):
    units = self.normals.copy()
    non_zero_areas = self.areas &gt; 0
    areas = self.areas

    if non_zero_areas.shape[0] != areas.shape[0]:  # pragma: no cover
        self.warning('Zero sized areas found, '
                     'units calculation will be partially incorrect')

    if non_zero_areas.any():
        non_zero_areas.shape = non_zero_areas.shape[0]
        areas = numpy.hstack((2 * areas[non_zero_areas],) * DIMENSIONS)
        units[non_zero_areas] /= areas

    self.units = units

</t>
<t tx="leo.20220502161649.59">@classmethod
def rotation_matrix(cls, axis, theta):
    '''
    Generate a rotation matrix to Rotate the matrix over the given axis by
    the given theta (angle)

    Uses the `Euler-Rodrigues
    &lt;https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula&gt;`_
    formula for fast rotations.

    :param numpy.array axis: Axis to rotate over (x, y, z)
    :param float theta: Rotation angle in radians, use `math.radians` to
                 convert degrees to radians if needed.
    '''
    axis = numpy.asarray(axis)
    # No need to rotate if there is no actual rotation
    if not axis.any():
        return numpy.identity(3)

    theta = 0.5 * numpy.asarray(theta)

    axis = axis / numpy.linalg.norm(axis)

    a = math.cos(theta)
    b, c, d = - axis * math.sin(theta)
    angles = a, b, c, d
    powers = [x * y for x in angles for y in angles]
    aa, ab, ac, ad = powers[0:4]
    ba, bb, bc, bd = powers[4:8]
    ca, cb, cc, cd = powers[8:12]
    da, db, dc, dd = powers[12:16]

    return numpy.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],
                        [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],
                        [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])

</t>
<t tx="leo.20220502161649.6">class PyTest(TestCommand):
    @others
</t>
<t tx="leo.20220502161649.60">def rotate(self, axis, theta=0, point=None):
    '''
    Rotate the matrix over the given axis by the given theta (angle)

    Uses the :py:func:`rotation_matrix` in the background.

    .. note:: Note that the `point` was accidentaly inverted with the
       old version of the code. To get the old and incorrect behaviour
       simply pass `-point` instead of `point` or `-numpy.array(point)` if
       you're passing along an array.

    :param numpy.array axis: Axis to rotate over (x, y, z)
    :param float theta: Rotation angle in radians, use `math.radians` to
                        convert degrees to radians if needed.
    :param numpy.array point: Rotation point so manual translation is not
                              required
    '''
    # No need to rotate if there is no actual rotation
    if not theta:
        return

    self.rotate_using_matrix(self.rotation_matrix(axis, theta), point)

</t>
<t tx="leo.20220502161649.61">def rotate_using_matrix(self, rotation_matrix, point=None):
    '''
    Rotate using a given rotation matrix and optional rotation point

    Note that this rotation produces clockwise rotations for positive
    angles which is arguably incorrect but will remain for legacy reasons.
    For more details, read here:
    https://github.com/WoLpH/numpy-stl/issues/166
    '''

    identity = numpy.identity(rotation_matrix.shape[0])
    # No need to rotate if there is no actual rotation
    if not rotation_matrix.any() or (identity == rotation_matrix).all():
        return

    if isinstance(point, (numpy.ndarray, list, tuple)) and len(point) == 3:
        point = numpy.asarray(point)
    elif point is None:
        point = numpy.array([0, 0, 0])
    elif isinstance(point, (int, float)):
        point = numpy.asarray([point] * 3)
    else:
        raise TypeError('Incorrect type for point', point)

    def _rotate(matrix):
        if point.any():
            # Translate while rotating
            return (matrix - point).dot(rotation_matrix) + point
        else:
            # Simply apply the rotation
            return matrix.dot(rotation_matrix)

    # Rotate the normals
    self.normals[:] = _rotate(self.normals[:])

    # Rotate the vectors
    for i in range(3):
        self.vectors[:, i] = _rotate(self.vectors[:, i])

</t>
<t tx="leo.20220502161649.62">def translate(self, translation):
    '''
    Translate the mesh in the three directions

    :param numpy.array translation: Translation vector (x, y, z)
    '''
    assert len(translation) == 3, "Translation vector must be of length 3"
    self.x += translation[0]
    self.y += translation[1]
    self.z += translation[2]

</t>
<t tx="leo.20220502161649.63">def transform(self, matrix):
    '''
    Transform the mesh with a rotation and a translation stored in a
    single 4x4 matrix

    :param numpy.array matrix: Transform matrix with shape (4, 4), where
                               matrix[0:3, 0:3] represents the rotation
                               part of the transformation
                               matrix[0:3, 3] represents the translation
                               part of the transformation
    '''
    is_a_4x4_matrix = matrix.shape == (4, 4)
    assert is_a_4x4_matrix, "Transformation matrix must be of shape (4, 4)"
    rotation = matrix[0:3, 0:3]
    unit_det_rotation = numpy.allclose(numpy.linalg.det(rotation), 1.0)
    assert unit_det_rotation, "Rotation matrix has not a unit determinant"
    for i in range(3):
        self.vectors[:, i] = numpy.dot(rotation, self.vectors[:, i].T).T
    self.x += matrix[0, 3]
    self.y += matrix[1, 3]
    self.z += matrix[2, 3]

</t>
<t tx="leo.20220502161649.64">def _get_or_update(key):
    def _get(self):
        if not hasattr(self, '_%s' % key):
            getattr(self, 'update_%s' % key)()
        return getattr(self, '_%s' % key)

    return _get

</t>
<t tx="leo.20220502161649.65">def _set(key):
    def _set(self, value):
        setattr(self, '_%s' % key, value)

    return _set

</t>
<t tx="leo.20220502161649.66">min_ = property(_get_or_update('min'), _set('min'),
                doc='Mesh minimum value')
max_ = property(_get_or_update('max'), _set('max'),
                doc='Mesh maximum value')
areas = property(_get_or_update('areas'), _set('areas'),
                 doc='Mesh areas')
units = property(_get_or_update('units'), _set('units'),
                 doc='Mesh unit vectors')

</t>
<t tx="leo.20220502161649.67">def __getitem__(self, k):
    return self.points[k]

</t>
<t tx="leo.20220502161649.68">def __setitem__(self, k, v):
    self.points[k] = v

</t>
<t tx="leo.20220502161649.69">def __len__(self):
    return self.points.shape[0]

</t>
<t tx="leo.20220502161649.7">def finalize_options(self):
    TestCommand.finalize_options(self)
    self.test_args = []
    self.test_suite = True

</t>
<t tx="leo.20220502161649.70">def __iter__(self):
    for point in self.points:
        yield point

</t>
<t tx="leo.20220502161649.71">def get_mass_properties_with_density(self, density):
    # add density for mesh,density unit kg/m3 when mesh is unit is m
    self.check()

    def subexpression(x):
        w0, w1, w2 = x[:, 0], x[:, 1], x[:, 2]
        temp0 = w0 + w1
        f1 = temp0 + w2
        temp1 = w0 * w0
        temp2 = temp1 + w1 * temp0
        f2 = temp2 + w2 * f1
        f3 = w0 * temp1 + w1 * temp2 + w2 * f2
        g0 = f2 + w0 * (f1 + w0)
        g1 = f2 + w1 * (f1 + w1)
        g2 = f2 + w2 * (f1 + w2)
        return f1, f2, f3, g0, g1, g2

    x0, x1, x2 = self.x[:, 0], self.x[:, 1], self.x[:, 2]
    y0, y1, y2 = self.y[:, 0], self.y[:, 1], self.y[:, 2]
    z0, z1, z2 = self.z[:, 0], self.z[:, 1], self.z[:, 2]
    a1, b1, c1 = x1 - x0, y1 - y0, z1 - z0
    a2, b2, c2 = x2 - x0, y2 - y0, z2 - z0
    d0, d1, d2 = b1 * c2 - b2 * c1, a2 * c1 - a1 * c2, a1 * b2 - a2 * b1

    f1x, f2x, f3x, g0x, g1x, g2x = subexpression(self.x)
    f1y, f2y, f3y, g0y, g1y, g2y = subexpression(self.y)
    f1z, f2z, f3z, g0z, g1z, g2z = subexpression(self.z)

    intg = numpy.zeros((10))
    intg[0] = sum(d0 * f1x)
    intg[1:4] = sum(d0 * f2x), sum(d1 * f2y), sum(d2 * f2z)
    intg[4:7] = sum(d0 * f3x), sum(d1 * f3y), sum(d2 * f3z)
    intg[7] = sum(d0 * (y0 * g0x + y1 * g1x + y2 * g2x))
    intg[8] = sum(d1 * (z0 * g0y + z1 * g1y + z2 * g2y))
    intg[9] = sum(d2 * (x0 * g0z + x1 * g1z + x2 * g2z))
    intg /= numpy.array([6, 24, 24, 24, 60, 60, 60, 120, 120, 120])
    volume = intg[0]
    cog = intg[1:4] / volume
    cogsq = cog ** 2
    vmass = volume * density
    inertia = numpy.zeros((3, 3))

    inertia[0, 0] = (intg[5] + intg[6]) * density - vmass * (
        cogsq[1] + cogsq[2])
    inertia[1, 1] = (intg[4] + intg[6]) * density - vmass * (
        cogsq[2] + cogsq[0])
    inertia[2, 2] = (intg[4] + intg[5]) * density - vmass * (
        cogsq[0] + cogsq[1])
    inertia[0, 1] = inertia[1, 0] = -(
        intg[7] * density - vmass * cog[0] * cog[1])
    inertia[1, 2] = inertia[2, 1] = -(
        intg[8] * density - vmass * cog[1] * cog[2])
    inertia[0, 2] = inertia[2, 0] = -(
        intg[9] * density - vmass * cog[2] * cog[0])

    return volume, vmass, cog, inertia

</t>
<t tx="leo.20220502161649.72">@path ./numpy-stl/stl/
@language python
@tabwidth -4
import sys
import random
import argparse

from . import stl


@others
</t>
<t tx="leo.20220502161649.73">def _get_parser(description):
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('infile', nargs='?', type=argparse.FileType('rb'),
                        default=sys.stdin, help='STL file to read')
    parser.add_argument('outfile', nargs='?', type=argparse.FileType('wb'),
                        default=sys.stdout, help='STL file to write')
    parser.add_argument('--name', nargs='?', help='Name of the mesh')
    parser.add_argument(
        '-n', '--use-file-normals', action='store_true',
        help='Read the normals from the file instead of recalculating them')
    parser.add_argument(
        '-r', '--remove-empty-areas', action='store_true',
        help='Remove areas with 0 surface areas to prevent errors during '
        'normal calculation')
    parser.add_argument('-s', '--disable-speedups', action='store_true',
                        help='Disable Cython speedups')
    return parser


</t>
<t tx="leo.20220502161649.74">def _get_name(args):
    names = [
        args.name,
        getattr(args.outfile, 'name', None),
        getattr(args.infile, 'name', None),
        'numpy-stl-%06d' % random.randint(0, 1_000_000),
    ]

    for name in names:  # pragma: no branch
        if name and isinstance(name, str) and not name.startswith('&lt;'):
            return name


</t>
<t tx="leo.20220502161649.75">def main():
    parser = _get_parser('Convert STL files from ascii to binary and back')
    parser.add_argument('-a', '--ascii', action='store_true',
                        help='Write ASCII file (default is binary)')
    parser.add_argument('-b', '--binary', action='store_true',
                        help='Force binary file (for TTYs)')

    args = parser.parse_args()
    name = _get_name(args)
    stl_file = stl.StlMesh(filename=name,
                           fh=args.infile,
                           calculate_normals=False,
                           remove_empty_areas=args.remove_empty_areas,
                           speedups=not args.disable_speedups)

    if args.binary:
        mode = stl.BINARY
    elif args.ascii:
        mode = stl.ASCII
    else:
        mode = stl.AUTOMATIC

    stl_file.save(name, args.outfile, mode=mode,
                  update_normals=not args.use_file_normals)


</t>
<t tx="leo.20220502161649.76">def to_ascii():
    parser = _get_parser('Convert STL files to ASCII (text) format')
    args = parser.parse_args()
    name = _get_name(args)
    stl_file = stl.StlMesh(filename=name, fh=args.infile,
                           calculate_normals=False,
                           remove_empty_areas=args.remove_empty_areas,
                           speedups=not args.disable_speedups)
    stl_file.save(name, args.outfile, mode=stl.ASCII,
                  update_normals=not args.use_file_normals)


</t>
<t tx="leo.20220502161649.77">def to_binary():
    parser = _get_parser('Convert STL files to binary format')
    args = parser.parse_args()
    name = _get_name(args)
    stl_file = stl.StlMesh(filename=name, fh=args.infile,
                           calculate_normals=False,
                           remove_empty_areas=args.remove_empty_areas,
                           speedups=not args.disable_speedups)
    stl_file.save(name, args.outfile, mode=stl.BINARY,
                  update_normals=not args.use_file_normals)

</t>
<t tx="leo.20220502161649.78">@path ./numpy-stl/stl/
@language python
@tabwidth -4
from . import stl


class Mesh(stl.BaseStl):
    pass

</t>
<t tx="leo.20220502161649.79">@path ./numpy-stl/stl/
@language python
@tabwidth -4
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import io
import os
import enum
import numpy
import struct
import datetime

from . import base
from . import __about__ as metadata
from .utils import b
from .utils import s

try:
    from . import _speedups
except ImportError:  # pragma: no cover
    _speedups = None


@others
StlMesh = BaseStl.from_file
</t>
<t tx="leo.20220502161649.8">def run_tests(self):
    # import here, cause outside the eggs aren't loaded
    import pytest
    errno = pytest.main(self.test_args)
    sys.exit(errno)


</t>
<t tx="leo.20220502161649.80">class Mode(enum.IntEnum):
    #: Automatically detect whether the output is a TTY, if so, write ASCII
    #: otherwise write BINARY
    AUTOMATIC = 0
    #: Force writing ASCII
    ASCII = 1
    #: Force writing BINARY
    BINARY = 2


</t>
<t tx="leo.20220502161649.81"># For backwards compatibility, leave the original references
AUTOMATIC = Mode.AUTOMATIC
ASCII = Mode.ASCII
BINARY = Mode.BINARY


#: Amount of bytes to read while using buffered reading
BUFFER_SIZE = 4096
#: The amount of bytes in the header field
HEADER_SIZE = 80
#: The amount of bytes in the count field
COUNT_SIZE = 4
#: The maximum amount of triangles we can read from binary files
MAX_COUNT = 1e8
#: The header format, can be safely monkeypatched. Limited to 80 characters
HEADER_FORMAT = '{package_name} ({version}) {now} {name}'


</t>
<t tx="leo.20220502161649.82">class BaseStl(base.BaseMesh):

    @others
</t>
<t tx="leo.20220502161649.83">@classmethod
def load(cls, fh, mode=AUTOMATIC, speedups=True):
    '''Load Mesh from STL file

    Automatically detects binary versus ascii STL files.

    :param file fh: The file handle to open
    :param int mode: Automatically detect the filetype or force binary
    '''
    header = fh.read(HEADER_SIZE)
    if not header:
        return

    if isinstance(header, str):  # pragma: no branch
        header = b(header)

    if mode is AUTOMATIC:
        if header.lstrip().lower().startswith(b'solid'):
            try:
                name, data = cls._load_ascii(
                    fh, header, speedups=speedups)
            except RuntimeError as exception:
                print('exception', exception)
                (recoverable, e) = exception.args
                # If we didn't read beyond the header the stream is still
                # readable through the binary reader
                if recoverable:
                    name, data = cls._load_binary(fh, header,
                                                  check_size=False)
                else:
                    # Apparently we've read beyond the header. Let's try
                    # seeking :)
                    # Note that this fails when reading from stdin, we
                    # can't recover from that.
                    fh.seek(HEADER_SIZE)

                    # Since we know this is a seekable file now and we're
                    # not 100% certain it's binary, check the size while
                    # reading
                    name, data = cls._load_binary(fh, header,
                                                  check_size=True)
        else:
            name, data = cls._load_binary(fh, header)
    elif mode is ASCII:
        name, data = cls._load_ascii(fh, header, speedups=speedups)
    else:
        name, data = cls._load_binary(fh, header)

    return name, data

</t>
<t tx="leo.20220502161649.84">@classmethod
def _load_binary(cls, fh, header, check_size=False):
    # Read the triangle count
    count_data = fh.read(COUNT_SIZE)
    if len(count_data) != COUNT_SIZE:
        count = 0
    else:
        count, = struct.unpack(s('&lt;i'), b(count_data))
    # raise RuntimeError()
    assert count &lt; MAX_COUNT, ('File too large, got %d triangles which '
                               'exceeds the maximum of %d') % (
                                   count, MAX_COUNT)

    if check_size:
        try:
            # Check the size of the file
            fh.seek(0, os.SEEK_END)
            raw_size = fh.tell() - HEADER_SIZE - COUNT_SIZE
            expected_count = int(raw_size / cls.dtype.itemsize)
            assert expected_count == count, ('Expected %d vectors but '
                                             'header indicates %d') % (
                                                 expected_count, count)
            fh.seek(HEADER_SIZE + COUNT_SIZE)
        except IOError:  # pragma: no cover
            pass

    name = header.strip()

    # Read the rest of the binary data
    try:
        return name, numpy.fromfile(fh, dtype=cls.dtype, count=count)
    except io.UnsupportedOperation:
        data = numpy.frombuffer(fh.read(), dtype=cls.dtype, count=count)
        # Copy to make the buffer writable
        return name, data.copy()

</t>
<t tx="leo.20220502161649.85">@classmethod
def _ascii_reader(cls, fh, header):
    if b'\n' in header:
        recoverable = [True]
    else:
        recoverable = [False]
        header += b(fh.read(BUFFER_SIZE))

    lines = b(header).split(b'\n')

    def get(prefix=''):
        prefix = b(prefix).lower()

        if lines:
            raw_line = lines.pop(0)
        else:
            raise RuntimeError(recoverable[0], 'Unable to find more lines')

        if not lines:
            recoverable[0] = False

            # Read more lines and make sure we prepend any old data
            lines[:] = b(fh.read(BUFFER_SIZE)).split(b'\n')
            raw_line += lines.pop(0)

        raw_line = raw_line.strip()
        line = raw_line.lower()
        if line == b(''):
            return get(prefix)

        if prefix:
            if line.startswith(prefix):
                values = line.replace(prefix, b(''), 1).strip().split()
            elif line.startswith(b('endsolid')):
                # go back to the beginning of new solid part
                size_unprocessedlines = sum(
                    len(line) + 1 for line in lines) - 1

                if size_unprocessedlines &gt; 0:
                    position = fh.tell()
                    fh.seek(position - size_unprocessedlines)
                raise StopIteration()
            else:
                raise RuntimeError(
                    recoverable[0],
                    '%r should start with %r' % (line, prefix))

            if len(values) == 3:
                return [float(v) for v in values]
            else:  # pragma: no cover
                raise RuntimeError(recoverable[0],
                                   'Incorrect value %r' % line)
        else:
            return b(raw_line)

    line = get()
    if not lines:
        raise RuntimeError(recoverable[0],
                           'No lines found, impossible to read')

    # Yield the name
    yield line[5:].strip()

    while True:
        # Read from the header lines first, until that point we can recover
        # and go to the binary option. After that we cannot due to
        # unseekable files such as sys.stdin
        #
        # Numpy doesn't support any non-file types so wrapping with a
        # buffer and/or StringIO does not work.
        try:
            normals = get('facet normal')
            assert get().lower() == b('outer loop')
            v0 = get('vertex')
            v1 = get('vertex')
            v2 = get('vertex')
            assert get().lower() == b('endloop')
            assert get().lower() == b('endfacet')
            attrs = 0
            yield (normals, (v0, v1, v2), attrs)
        except AssertionError as e:  # pragma: no cover
            raise RuntimeError(recoverable[0], e)
        except StopIteration:
            return

</t>
<t tx="leo.20220502161649.86">@classmethod
def _load_ascii(cls, fh, header, speedups=True):
    # Speedups does not support non file-based streams
    try:
        fh.fileno()
    except io.UnsupportedOperation:
        speedups = False
    # The speedups module is covered by travis but it can't be tested in
    # all environments, this makes coverage checks easier
    if _speedups and speedups:  # pragma: no cover
        return _speedups.ascii_read(fh, header)
    else:
        iterator = cls._ascii_reader(fh, header)
        name = next(iterator)
        return name, numpy.fromiter(iterator, dtype=cls.dtype)

</t>
<t tx="leo.20220502161649.87">def save(self, filename, fh=None, mode=AUTOMATIC, update_normals=True):
    '''Save the STL to a (binary) file

    If mode is :py:data:`AUTOMATIC` an :py:data:`ASCII` file will be
    written if the output is a TTY and a :py:data:`BINARY` file otherwise.

    :param str filename: The file to load
    :param file fh: The file handle to open
    :param int mode: The mode to write, default is :py:data:`AUTOMATIC`.
    :param bool update_normals: Whether to update the normals
    '''
    assert filename, 'Filename is required for the STL headers'
    if update_normals:
        self.update_normals()

    if mode is AUTOMATIC:
        # Try to determine if the file is a TTY.
        if fh:
            try:
                if os.isatty(fh.fileno()):  # pragma: no cover
                    write = self._write_ascii
                else:
                    write = self._write_binary
            except IOError:
                # If TTY checking fails then it's an io.BytesIO() (or one
                # of its siblings from io). Assume binary.
                write = self._write_binary
        else:
            write = self._write_binary
    elif mode is BINARY:
        write = self._write_binary
    elif mode is ASCII:
        write = self._write_ascii
    else:
        raise ValueError('Mode %r is invalid' % mode)

    if isinstance(fh, io.TextIOBase):
        # Provide a more helpful error if the user mistakenly
        # assumes ASCII files should be text files.
        raise TypeError(
            "File handles should be in binary mode - even when"
            " writing an ASCII STL.")

    name = self.name
    if not name:
        name = os.path.split(filename)[-1]

    try:
        if fh:
            write(fh, name)
        else:
            with open(filename, 'wb') as fh:
                write(fh, name)
    except IOError:  # pragma: no cover
        pass

</t>
<t tx="leo.20220502161649.88">def _write_ascii(self, fh, name):
    try:
        fh.fileno()
        speedups = self.speedups
    except io.UnsupportedOperation:
        speedups = False

    if _speedups and speedups:  # pragma: no cover
        _speedups.ascii_write(fh, b(name), self.data)
    else:
        @others
        p('solid %s' % name, file=fh)

        for row in self.data:
            vectors = row['vectors']
            p('facet normal %f %f %f' % tuple(row['normals']), file=fh)
            p('  outer loop', file=fh)
            p('    vertex %f %f %f' % tuple(vectors[0]), file=fh)
            p('    vertex %f %f %f' % tuple(vectors[1]), file=fh)
            p('    vertex %f %f %f' % tuple(vectors[2]), file=fh)
            p('  endloop', file=fh)
            p('endfacet', file=fh)

        p('endsolid %s' % name, file=fh)

</t>
<t tx="leo.20220502161649.89">def p(s, file):
    file.write(b('%s\n' % s))

</t>
<t tx="leo.20220502161649.9">if sys.version_info.major == 2 or sys.platform.lower() != 'win32':
    try:
        import numpy
        from Cython import Build

        setup_kwargs['ext_modules'] = Build.cythonize([
            extension.Extension(
                'stl._speedups',
                ['stl/_speedups.pyx'],
                include_dirs=[numpy.get_include()],
            ),
        ])
    except ImportError:
        error('WARNING',
              'Cython and Numpy is required for building extension.',
              'Falling back to pure Python implementation.')

# To prevent importing about and thereby breaking the coverage info we use this
# exec hack
about = {}
with open('stl/__about__.py') as fh:
    exec(fh.read(), about)


if os.path.isfile('README.rst'):
    with open('README.rst') as fh:
        long_description = fh.read()
else:
    long_description = 'See http://pypi.python.org/pypi/%s/' % (
        about['__package_name__'])

install_requires = [
    'numpy',
    'python-utils&gt;=1.6.2',
]

try:
    import enum
    assert enum
except ImportError:
    install_requires.append('enum34')


tests_require = ['pytest']


</t>
<t tx="leo.20220502161649.90">def get_header(self, name):
    # Format the header
    header = HEADER_FORMAT.format(
        package_name=metadata.__package_name__,
        version=metadata.__version__,
        now=datetime.datetime.now(),
        name=name,
    )

    # Make it exactly 80 characters
    return header[:80].ljust(80, ' ')

</t>
<t tx="leo.20220502161649.91">def _write_binary(self, fh, name):
    header = self.get_header(name)
    packed = struct.pack(s('&lt;i'), self.data.size)

    if isinstance(fh, io.TextIOWrapper):  # pragma: no cover
        packed = str(packed)
    else:
        header = b(header)
        packed = b(packed)

    fh.write(header)
    fh.write(packed)

    if isinstance(fh, io.BufferedWriter):
        # Write to a true file.
        self.data.tofile(fh)
    else:
        # Write to a pseudo buffer.
        fh.write(self.data.data)

    # In theory this should no longer be possible but I'll leave it here
    # anyway...
    if self.data.size:  # pragma: no cover
        assert fh.tell() &gt; 84, (
            'numpy silently refused to write our file. Note that writing '
            'to `StringIO` objects is not supported by `numpy`')

</t>
<t tx="leo.20220502161649.92">@classmethod
def from_file(cls, filename, calculate_normals=True, fh=None,
              mode=Mode.AUTOMATIC, speedups=True, **kwargs):
    '''Load a mesh from a STL file

    :param str filename: The file to load
    :param bool calculate_normals: Whether to update the normals
    :param file fh: The file handle to open
    :param dict kwargs: The same as for :py:class:`stl.mesh.Mesh`

    '''
    if fh:
        name, data = cls.load(
            fh, mode=mode, speedups=speedups)
    else:
        with open(filename, 'rb') as fh:
            name, data = cls.load(
                fh, mode=mode, speedups=speedups)

    return cls(data, calculate_normals, name=name,
               speedups=speedups, **kwargs)

</t>
<t tx="leo.20220502161649.93">@classmethod
def from_multi_file(cls, filename, calculate_normals=True, fh=None,
                    mode=Mode.AUTOMATIC, speedups=True, **kwargs):
    '''Load multiple meshes from a STL file

    Note: mode is hardcoded to ascii since binary stl files do not support
    the multi format

    :param str filename: The file to load
    :param bool calculate_normals: Whether to update the normals
    :param file fh: The file handle to open
    :param dict kwargs: The same as for :py:class:`stl.mesh.Mesh`
    '''
    if fh:
        close = False
    else:
        fh = open(filename, 'rb')
        close = True

    try:
        raw_data = cls.load(fh, mode=mode, speedups=speedups)
        while raw_data:
            name, data = raw_data
            yield cls(data, calculate_normals, name=name,
                      speedups=speedups, **kwargs)
            raw_data = cls.load(fh, mode=ASCII,
                                speedups=speedups)

    finally:
        if close:
            fh.close()

</t>
<t tx="leo.20220502161649.94">@classmethod
def from_files(cls, filenames, calculate_normals=True, mode=Mode.AUTOMATIC,
               speedups=True, **kwargs):
    '''Load multiple meshes from a STL file

    Note: mode is hardcoded to ascii since binary stl files do not support
    the multi format

    :param list(str) filenames: The files to load
    :param bool calculate_normals: Whether to update the normals
    :param file fh: The file handle to open
    :param dict kwargs: The same as for :py:class:`stl.mesh.Mesh`
    '''
    meshes = []
    for filename in filenames:
        meshes.append(cls.from_file(
            filename,
            calculate_normals=calculate_normals,
            mode=mode,
            speedups=speedups,
            **kwargs))

    data = numpy.concatenate([mesh.data for mesh in meshes])
    return cls(data, calculate_normals=calculate_normals, **kwargs)


</t>
<t tx="leo.20220502161649.95">@path ./numpy-stl/stl/
@language python
@tabwidth -4
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)
import sys


IS_PYTHON2 = (sys.version_info[0] == 2)


@others
</t>
<t tx="leo.20220502161649.96">def b(s, encoding='ascii', errors='replace'):  # pragma: no cover
    if IS_PYTHON2:
        return bytes(s)
    else:
        if isinstance(s, str):
            return bytes(s, encoding, errors)
        else:
            return s
        # return bytes(s, encoding, errors)


</t>
<t tx="leo.20220502161649.97">def s(s):  # pragma: no cover
    if IS_PYTHON2:
        return bytes(s)
    else:
        return s
</t>
<t tx="leo.20220502161649.98">@path ./numpy-stl/stl/
@language python
@tabwidth -4
__package_name__ = 'numpy-stl'
__import_name__ = 'stl'
__version__ = '2.16.3'
__author__ = 'Rick van Hattem'
__author_email__ = 'Wolph@Wol.ph'
__description__ = ' '.join('''
Library to make reading, writing and modifying both binary and ascii STL files
easy.
'''.split())
__url__ = 'https://github.com/WoLpH/numpy-stl/'

</t>
<t tx="leo.20220502161649.99">@path ./numpy-stl/stl/
@language python
@tabwidth -4
from .stl import BUFFER_SIZE
from .stl import HEADER_SIZE
from .stl import COUNT_SIZE
from .stl import MAX_COUNT

from .stl import Mode
from .base import Dimension
from .base import RemoveDuplicates
from .mesh import Mesh

__all__ = [
    'BUFFER_SIZE',
    'HEADER_SIZE',
    'COUNT_SIZE',
    'MAX_COUNT',
    'Mode',
    'Dimension',
    'RemoveDuplicates',
    'Mesh',
]
</t>
<t tx="leo.20220502161804.1"></t>
<t tx="leo.20220502224846.1"></t>
<t tx="leo.20220502224846.10">def read_header(self):
    self.f.seek(self.f.tell() + 80)

</t>
<t tx="leo.20220502224846.11">def cm3_To_inch3Transform(self, v):
    return v * 0.0610237441

</t>
<t tx="leo.20220502224846.12">def calculateMassCM3(self, totalVolume):
    totalMass = 0
    if material in {1, 'ABS'}:
        totalMass = (totalVolume * 1.04)
    elif material in {2, 'PLA'}:
        totalMass = (totalVolume * 1.25)
    elif material in {3, 'CFRP'}:
        totalMass = (totalVolume * 1.79)
    elif material in {4, 'Plexiglass'}:
        totalMass = (totalVolume * 1.18)
    elif material in {5, 'Alumide'}:
        totalMass = (totalVolume * 1.36)
    elif material in {6, 'Aluminum'}:
        totalMass = (totalVolume * 2.68)
    elif material in {7, 'Brass'}:
        totalMass = (totalVolume * 8.6)
    elif material in {8, 'Bronze'}:
        totalMass = (totalVolume * 9.0)
    elif material in {9, 'Copper'}:
        totalMass = (totalVolume * 9.0)
    elif material in {10, 'Gold_14K'}:
        totalMass = (totalVolume * 13.6)
    elif material in {11, 'Gold_18K'}:
        totalMass = (totalVolume * 15.6)
    elif material in {12, 'Polyamide_MJF'}:
        totalMass = (totalVolume * 1.01)
    elif material in {13, 'Polyamide_SLS'}:
        totalMass = (totalVolume * 0.95)
    elif material in {14, 'Rubber'}:
        totalMass = (totalVolume * 1.2)
    elif material in {15, 'Silver'}:
        totalMass = (totalVolume * 10.26)
    elif material in {16, 'Steel'}:
        totalMass = (totalVolume * 7.86)
    elif material in {17, 'Titanium'}:
        totalMass = (totalVolume * 4.41)
    elif material in {18, 'Resin'}:
        totalMass = (totalVolume * 1.2)
    return totalMass

</t>
<t tx="leo.20220502224846.13">def calculateVolume(self, infilename, unit):
    print(infilename)
    self.resetVariables()
    totalVolume = 0
    totalMass = 0
    try:
        self.f = open(infilename, "rb")
        self.read_header()
        l = self.read_length()
        print("total triangles:", l)
        try:
            while True:
                totalVolume += self.read_triangle()
        except Exception as e:
            print("End calculate triangles volume")
        totalVolume = (totalVolume / 1000)
        totalMass = self.calculateMassCM3(totalVolume)

        if totalMass &lt;= 0:
            print('Total mass could not be calculated')
        else:
            print('Total mass:', totalMass, 'g')

            if unit == "cm":
                print("Total volume:", totalVolume, "cm^3")
            else:
                totalVolume = self.cm3_To_inch3Transform(totalVolume)
                print("Total volume:", totalVolume, "inch^3")
    except Exception as e:
        print(e)
    return totalVolume


</t>
<t tx="leo.20220502224846.2"></t>
<t tx="leo.20220502224846.3">@path ./STL-Volume-Model-Calculator/
@language python
@tabwidth -4
#! /usr/bin/env python3
'''
VOLUME CALCULATION STL binary MODELS
Author: Mar Canet (mar.canet@gmail.com) - september 2012
Description: useful to calculate cost in a 3D printing ABS or PLA usage

Modified by:
Author: Saijin_Naib (Synper311@aol.com)
Date: 2016-06-26 03:55:13.879187
Description: Added input call for print material (ABS or PLA), added print of object mass, made Python3 compatible, changed tabs for spaces
Material Mass Source: https://www.toybuilderlabs.com/blogs/news/13053117-filament-volume-and-length
'''

import struct
import sys
print('Choose desired print material of STL file below:')
material = input('1 = ABS or 2 = PLA or 3 = 3k CFRP or 4 = Plexiglass : ')


@others
if __name__ == '__main__':
    if len(sys.argv) == 1:
        print("Define model to calculate volume ej: python measure_volume.py torus.stl")
    else:
        mySTLUtils = STLUtils()
        if(len(sys.argv) &gt; 2 and sys.argv[2] == "inch"):
            mySTLUtils.calculateVolume(sys.argv[1], "inch")
        else:
            mySTLUtils.calculateVolume(sys.argv[1], "cm")
</t>
<t tx="leo.20220502224846.4">class STLUtils:
    @others
</t>
<t tx="leo.20220502224846.5">def resetVariables(self):
    self.normals = []
    self.points = []
    self.triangles = []
    self.bytecount = []
    self.fb = []  # debug list

</t>
<t tx="leo.20220502224846.6"># Calculate volume for the 3D mesh using Tetrahedron volume
# based on: http://stackoverflow.com/questions/1406029/how-to-calculate-the-volume-of-a-3d-mesh-object-the-surface-of-which-is-made-up
def signedVolumeOfTriangle(self, p1, p2, p3):
    v321 = p3[0] * p2[1] * p1[2]
    v231 = p2[0] * p3[1] * p1[2]
    v312 = p3[0] * p1[1] * p2[2]
    v132 = p1[0] * p3[1] * p2[2]
    v213 = p2[0] * p1[1] * p3[2]
    v123 = p1[0] * p2[1] * p3[2]
    return (1.0 / 6.0) * (-v321 + v231 + v312 - v132 - v213 + v123)

</t>
<t tx="leo.20220502224846.7">def unpack(self, sig, l):
    s = self.f.read(l)
    self.fb.append(s)
    return struct.unpack(sig, s)

</t>
<t tx="leo.20220502224846.8">def read_triangle(self):
    n = self.unpack("&lt;3f", 12)
    p1 = self.unpack("&lt;3f", 12)
    p2 = self.unpack("&lt;3f", 12)
    p3 = self.unpack("&lt;3f", 12)
    b = self.unpack("&lt;h", 2)

    self.normals.append(n)
    l = len(self.points)
    self.points.append(p1)
    self.points.append(p2)
    self.points.append(p3)
    self.triangles.append((l, l + 1, l + 2))
    self.bytecount.append(b[0])
    return self.signedVolumeOfTriangle(p1, p2, p3)

</t>
<t tx="leo.20220502224846.9">def read_length(self):
    length = struct.unpack("@i", self.f.read(4))
    return length[0]

</t>
<t tx="leo.20220502234818.1"></t>
<t tx="leo.20220502234818.10">def __init__(self,p1,p2,p3,n=None):
    #3 points of the triangle
    self.vertices=np.array(p1),np.array(p2),np.array(p3)
  
    #triangles normal
    if n != None:
        self.normal= n
    else:
        self.normal = np.array(self.calculate_normal(self.vertices[0],self.vertices[1],self.vertices[2]))

</t>
<t tx="leo.20220502234818.11">def calculate_normal(self,p1,p2,p3):
    p12 = p2-p1
    p23 = p3-p2
    #calculate the cross product
    return np.cross(p12,p23)    




</t>
<t tx="leo.20220502234818.12">class STLmodel:

    @others
</t>
<t tx="leo.20220502234818.13">def __init__(self,filename):
    self.filename = filename
    self.triangles=[]
    self.centroid = None
    self.volume = None
    self.load_stl()
  
</t>
<t tx="leo.20220502234818.14">#return the faces of the triangles
def get_triangles(self):
    if self.triangles:
        for face in self.triangles:
            yield face

</t>
<t tx="leo.20220502234818.15">def get_centroid(self):
    # Yen fix this
    #if  self.centroid == None:
    if self.centroid is None:
        self.calculateCentroid()
    return self.centroid

</t>
<t tx="leo.20220502234818.16">def get_volume(self):
    if self.volume is None:
        self.calculateCentroid()
    return self.volume
        

</t>
<t tx="leo.20220502234818.17">def calculateCentroid(self):
    totalVolume=0
    currentVolume=0
    xCenter = 0
    yCenter = 0
    zCenter = 0
    #Each triangle forms a tetrahedron with the origin.  
    #Calculate the size inside the volume of the model. Then add the 
    #contributions to the centroid of the 3-d shape based on those volumes.
    for tri in self.triangles:
        p1 = tri.vertices[0]
        p2 = tri.vertices[1]
        p3 = tri.vertices[2]
        currentVolume = ((p1[0]*p2[1]*p3[2] - p1[0]*p3[1]*p2[2] - p2[0]*p1[1]*p3[2] +
                p2[0]*p3[1]*p1[2] + p3[0]*p1[1]*p2[2] - p3[0]*p2[1]*p1[2])/6)
        totalVolume += currentVolume
        xCenter += ((p1[0] + p2[0] + p3[0])/4) * currentVolume
        yCenter += ((p1[1] + p2[1] + p3[1])/4) * currentVolume
        zCenter += ((p1[2] + p2[2] + p3[2])/4) * currentVolume
    
    self.volume = totalVolume
    xCentroid = xCenter/totalVolume
    yCentroid = yCenter/totalVolume
    zCentroid = zCenter/totalVolume
    self.centroid = np.array([xCentroid,yCentroid,zCentroid])



</t>
<t tx="leo.20220502234818.18">#load stl file detects if the file is a text file or binary file
def load_stl(self):
    #read start of file to determine if its a binay stl file or a ascii stl file
    if self.filename:
        fp=open(self.filename,'r')
        h=fp.read(80)
        type=h[0:5]
        fp.close()

        if type=='solid':
            self.load_text_stl()
            #Many Binary Files also start with 'solid' unfortunately. 
            #if we don't have any triangles after attempting an ascii read
            #let's try a binary read and see if that works
            if len(self.triangles) &lt; 1:
                print('ASCII load did not find any triangles.  Your binary .STL file probably starts with "solid". Trying a binary read instead')
                self.load_binary_stl()
        
        else:
            self.load_binary_stl()

    #If we don't have any triangles.  Something went wrong. 
    if len(self.triangles) &lt; 1:
        print("No triangles found for file.  This may not be a .stl file.")
       

</t>
<t tx="leo.20220502234818.19">#read text stl match keywords to grab the points to build the model
def load_text_stl(self):
    print("Attempting to read ASCII STL: "+str(self.filename))
    fp=open(self.filename,'r')
    for line in fp:
        words=line.split()
        if len(words)&gt;0:
            if words[0]=='solid':
                try:
                    self.name=words[1]
                except IndexError:
                    self.name="polyhedron"

            if words[0]=='facet':
                center=[0.0,0.0,0.0]
                vertices=[]
                normal=(float(words[2]),float(words[3]),float(words[4]))
              
            if words[0]=='vertex':
                vertices.append((float(words[1]),float(words[2]),float(words[3])))
              
              
            if words[0]=='endloop':
                #make sure we got the correct number of values before storing
                if len(vertices)==3:
                    self.triangles.append(triangle(vertices[0],vertices[1],vertices[2],normal))
    fp.close()

</t>
<t tx="leo.20220502234818.2"></t>
<t tx="leo.20220502234818.20">#load binary stl file check wikipedia for the binary layout of the file
#we use the struct library to read in and convert binary data into a format we can use
def load_binary_stl(self):
    print("Attempting to read binary STL: "+str(self.filename,))
    fp=open(self.filename,'rb')
    h=fp.read(80)

    l=struct.unpack('I',fp.read(4))[0]
    count=0
    while True:
        try:
            p=fp.read(12)
            if len(p)==12:
                n=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]
              
            p=fp.read(12)
            if len(p)==12:
                p1=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            p=fp.read(12)
            if len(p)==12:
                p2=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            p=fp.read(12)
            if len(p)==12:
                p3=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            new_tri=(n,p1,p2,p3)

            if len(new_tri)==4:
                tri=triangle(p1,p2,p3,n)
                self.triangles.append(tri)
            count+=1
            fp.read(2)

            if len(p)==0:
                break
        except EOFError:
            break
    fp.close()

</t>
<t tx="leo.20220502234818.21">def write_text_stl(self, filename):
    print("Writing STL to: " + filename)

    try:
        f = open(filename, 'w')
        try:
            f.write('solid {:s}\n'.format(self.filename))
        except AttributeError:
            f.write('solid {:s}\n'.format('polyhedron'))

        for facet in self.triangles:
            normal = facet.normal
            f.write('  facet normal {0:.6E} {1:.6E} {2:.6E}\n'.format(normal[0], normal[1], normal[2]))
            f.write('    outer loop\n')
            for point in facet.vertices:
                f.write('      vertex {0:.6E} {1:.6E} {2:.6E}\n'.format(point[0], point[1], point[2]))
            f.write('    endloop\n')
            f.write('  endfacet\n')
        
        try:
            f.write('endsolid {:s}\n'.format(self.name))
        except AttributeError:
            f.write('endsolid {:s}\n'.format('polyhedron'))

        f.close()
    except IOError:
        print("Couldn't complete write. IOError encountered.")



</t>
<t tx="leo.20220502234818.22">#Pass this a numpy 3-array to translate all the points in the .stl file. 
def translate(self, p):
    for tri in self.triangles:
        for point in tri.vertices:
            point[0] += p[0]
            point[1] += p[1]
            point[2] += p[2]
    self.volume = None
    self.centroid = None

</t>
<t tx="leo.20220502234818.23">#Pass this a numpy 2D array, not a numpy matrix a rotation object.
def rotate(self, R):
    for tri in self.triangles:
        for point in tri.vertices:
            rotatedPoint = R.dot(point)
            point[0] = rotatedPoint[0]
            point[1] = rotatedPoint[1]
            point[2] = rotatedPoint[2]

    self.centroid = None
    self.volume = None

</t>
<t tx="leo.20220502234818.24">def scale(self, scale):
    for tri in self.triangles:
        for point in tri.vertices:
            point[0] = scale*point[0]
            point[1] = scale*point[1]
            point[2] = scale*point[2]

    self.volume = None
    self.centroid = None


</t>
<t tx="leo.20220502234818.25">@path ./pySTL/
@language python
@tabwidth -4
import pySTL
from numpy import array

@others
#Load a model from a file.
model = pySTL.STLmodel('./../../link2_ascii.stl')
leoprint(model.get_volume())

#print model properties
leoprint("Volume  " + str(model.get_volume()))
c = model.get_centroid()
leoprint("Centroid " +  "X: " + str(c[0]) + " Y:" + str(c[1]) + "  Z:" + str(c[2]))

#Translate the model so that the centroid is at the origin.
model.translate(-c)
model.write_text_stl("link2_AtCentroid.stl")

#Rotate the model 90 degrees about the Y-axis
R2 = pySTL.rotationAboutY(-3.14159/2)

model.rotate(R2)

c = model.get_centroid()

leoprint("Centroid " +  "X: " + str(c[0]) + " Y:" + str(c[1]) + "  Z:" + str(c[2]))

model.write_text_stl('link2_rot_90_about_Y.stl')

#Scale the model down by 100%
scale = 0.001
model.scale(scale)

model.write_text_stl('link2_scale_down_0.001.stl')

</t>
<t tx="leo.20220502234818.26">def leoprint(x):
    try:
        print(x)
    except:
        g.es(x)

</t>
<t tx="leo.20220502234818.3">@path ./pySTL/
@language python
@tabwidth -4
#!/usr/bin/python

import pySTL
import argparse


parser = argparse.ArgumentParser(description='Process a given STL file and perform rotation, translation, and scaling on it.  Actions happen in the order given here.  Scaling, then translation, then rotation. If selected, centroid translation happens last.')

parser.add_argument('-i', '--infile', action="store", help='input STL file', required=True)

parser.add_argument('-o', '--outfile', action="store", help='output STL file including the extension.  If none is given, processing is performed in place and the input file is replaced by the edited version', default="SECRET")

parser.add_argument('-s', '--scale', action="store", help='scaling factor for output STL', type=float, default=1.0)


parser.add_argument('-t', '--translate', action="store", help='translate the STL file: provide three numeric values for x, y, and z translation  e.g. --translate 10.1 -14.2 15', nargs=3, type=float, default=[])

parser.add_argument('-r', '--rotate', action="store", help='rotate the STL file: provide 3 angles for 3-1-3 body-fixed Euler angle rotations in radians', nargs=3, type=float, default=[]) 

parser.add_argument('-c', '--centroid', action="store_true", help='move the STL file so that the origin is the centroid after performing all other operations', default=False)
parser.add_argument('-v', '--verbose', action="store_true", help='print out operations', default=False)

args = parser.parse_args()
 
if args.verbose:
    def verboseprint(*args):
        # Print each argument separately so caller doesn't need to
        # stuff everything to be printed into a single string
        for arg in args:
           print(arg)
        print()
else:   
    verboseprint = lambda *a: None      # do-nothing function



model = pySTL.STLmodel(args.infile)

if args.scale != 1:
    verboseprint("Scaling model by factor: ", args.scale)
    model.scale(args.scale)


translation = args.translate
if len(translation) == 3:
    verboseprint("Performing translation: deltaX = ", str(translation[0]), ", deltaY = ", str(translation[1]), ", deltaZ = ", str(translation[2]))
    model.translate(translation)

eulerAngles = args.rotate
if len(eulerAngles) == 3:
    verboseprint('Performing Rotation')
    R1 = pySTL.rotationAboutZ(eulerAngles[0])
    R2 = pySTL.rotationAboutX(eulerAngles[1])
    R3 = pySTL.rotationAboutZ(eulerAngles[2])
    #For body-fixed, pre-multiply.   
    R = R3.dot(R2.dot(R1))
    verboseprint("Rotation Matrix: \n", R)
    model.rotate(R)


if args.centroid:
    verboseprint("Moving model to centroid")
    c = model.get_centroid()
    model.translate(-c)
   

if args.outfile == "SECRET":
    outfile = args.infile
else:
    outfile = args.outfile

model.write_text_stl(outfile)
</t>
<t tx="leo.20220502234818.4">@path ./pySTL/
@language python
@tabwidth -4
import pySTL
from numpy import array

#Load a model from a file.
model = pySTL.STLmodel('./../../link2_ascii.stl')

#print model properties
print "Volume  " + str(model.get_volume())
c = model.get_centroid()
print "Centroid " +  "X: " + str(c[0]) + " Y:" + str(c[1]) + "  Z:" + str(c[2])


#Translate the model so that the centroid is at the origin.
model.translate(-c)

model.write_text_stl('textCenteredAtCentroid.stl')

</t>
<t tx="leo.20220502234818.5">@path ./pySTL/
@language python
@tabwidth -4
import struct
import numpy as np
from math import cos
from math import sin

@others
</t>
<t tx="leo.20220502234818.6">#3 Utility methods to calculate rotation matrices.
def rotationAboutX(phi):
    R = np.array([[1, 0, 0],[0, cos(phi), sin(phi)],[0, -sin(phi), cos(phi)]])
    return R

</t>
<t tx="leo.20220502234818.7">def rotationAboutY(phi):
    R = np.array([[cos(phi), 0, -sin(phi)],[0, 1, 0],[sin(phi), 0, cos(phi)]])
    return R

</t>
<t tx="leo.20220502234818.8">def rotationAboutZ(phi):
    R = np.array([[cos(phi), sin(phi), 0],[-sin(phi), cos(phi), 0],[0, 0, 1]])
    return R

</t>
<t tx="leo.20220502234818.9">#3d face on a model
class triangle:
    
    @others
</t>
</tnodes>
</leo_file>
