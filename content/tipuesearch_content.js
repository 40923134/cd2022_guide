var tipuesearch = {"pages": [{'title': 'About', 'text': '倉儲:  https://github.com/mdecycu/cd2022_guide \n 網站:  https://mde.tw/cd2022_guide \n 課程倉儲與網站: \n https://github.com/mdecycu/cd2022 \n https://mde.tw/cd2022 \n 網路設定: \n 由於目前電腦輔助設計室中的電腦只要將網路連接到系上的主幹 (因為課程要全面在純 IPv6 網段上運作), 直接連外, 電腦中就會有蠕蟲程式啟動攻擊(Why?, 如何找到攻擊源頭?), 造成操作系統所安裝的防毒軟體為了防堵惡意攻擊而關閉網路連線. \n 為因應上述問題, 可以在切換至連外網段後, 將系統的代理主機自動偵測關閉, 且自行設定能夠支援 IPv6 與 IPv4 的代理主機, 並且關閉網路卡的 IPv4 網路協定, 就可以避開惡意軟體的攻擊. \n 若要在開機後, 防毒軟體啟動前, 以批次檔案的執行, 自動完成上述三項設定, 可以參考: \n 電腦輔助設計室  IPv6 網路設定 \n 分組: \n 利用 Ethercalc 收集各班學員的 Github 帳號與組別, 存入  https://github.com/mdecycu/studlist/tree/main/2022spring \n 各學員若 github 帳號有更動, 可以自行至  https://github.com/mdecycu/studlist \xa0 倉儲, 以 pull requests 進行修改. \n 以 2b 為例, 每一大組 8 人, 且分為兩個 4 人小組, 目前可以透過  http://mde.tw/studlist/2022spring/2b.txt  讀取. 且透過  read_data_from_nfulist.py  可以在近端讀取各班學員的 github 帳號與組別. \n 目前碰到的問題是: \n 能不能透過隨機方式自動幫尚未納組的學員分組? \n 能不能直接在網站上顯示出各學員的 cd2022 課程倉儲與網站? \n 參考:  grp_2022 ,  2a 分組程式練習 ,  2b 分組程式練習 \n 下載課程工具: \n 協同產品設計實習課程將會用到 NX1980, 若在電腦輔助設計室, 可以直接從  http://wcm.cycu.org:88/  下載. \n NX12 版 (2017.10) 之後的版號: \n 2019.01: NX1847 開始啟動 Continuous Release \n 2019.06: NX1872 啟動每半年釋出一個累加 27 的 Series 版次號. \n 2019.12: NX1899 = NX1872 + 27 \n 2020.06: NX1926 = NX1899 + 27 \n 2020.12: NX1953 = NX1926 + 27 \n 2021.06: NX1980 = NX1953 + 27 \n 2021.12: NX2007 = NX1980 + 27 \n 2022.06: NX2034 = NX2007 + 27 \n 讀取各學員每週工作內容: \n 當完成分組後, 且各學員已經透過各自 Github 帳號下的 cd2022 倉儲開始執行課程任務後, 能否透過程式逐日或逐週讀取各學員的工作內容? \n 課程第一階段要求: \n 每一個大組都要設法提供 solvespace, NX1980 格式的  uarm  (Onshape 格式) 機械手臂零組件. \n cd2022_uarm_nx12_imported.7z \n \n \n \n \n Please enable JavaScript to view the  comments powered by Disqus. \n', 'tags': '', 'url': 'About.html'}, {'title': 'IPv6', 'text': '電腦輔助設計室  IPv6 網路設定 \n 手機、筆電或平板可以透過 810WIFI 無線網路接點連線, 取得系網 IPv6 連外網址與 IPv4 NAT 內部網址. \n 智慧財產局學校行政與電算中心篇 \n 如何避免惡意軟體的侵害 ? \n 問題: \n 為何不使用 NAT 機制, 而讓電腦輔助設計室中的電腦直接連上外部網路? \n 因為與 IPv4 協定比較, IPv6 協定安全性較高, 且直接連外可取得較大頻寬, 無需採 port mapping 就可啟動 IPv6 協定伺服器. \n 使用 IPv6 連網有哪些好處? 有沒有壞處? \n 好處如上, 而壞處是若要連線到只支援 IPv4 協定的網站, 需要透過雙協定支援的 Proxy, 其中包括 http(s) 與 git. \n 如何使用批次檔案完成 IPv6 網路設定, 避開惡意軟體的網路攻擊? \n 請參考  IPv6 網路設定  說明. \n', 'tags': '', 'url': 'IPv6.html'}, {'title': 'template and SSH', 'text': '以下教學影片說明如何利用  https://github.com/wcm2022/wcm2022  倉儲作為 template, 建立個人與分組的倉儲. 並且利用 putty 與 GIT_SSH 變數的設定, 採用 SSH 網路協定對 Github 上的倉儲進行改版: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'template and SSH.html'}, {'title': 'Grouping', 'text': 'cd2022  課程由學員自行分組, 每四人為一小組, 每兩小組組成一大組. \n 所有課程指定內容可由各小組組員討論 (每週至少開會一次, 且將小組討論過程與結論放入各小組分組倉儲) 後, 在個人所負責的項目執行完成後, 先納入個人 cd2022 倉儲後, 再依照組序整合至該小組組長的協同倉儲 (例如: 甲班第一大組的第一小組倉儲名稱將為: cd2022ag1-1, 甲班第一大組的第二小組倉儲名稱將為: cd2022ag1-2). \n 各大組成員每兩週在上課之前必須至少開會一次, 且將大組討論過程與結論放入各大組分組倉儲後 (例如: 甲班第一大組的倉儲名稱將為: cd2022ag1), 比較並統整各小組所完成的內容後, 將協同設計結果納入各大組的分組倉儲, 且各大組每兩週將利用課程時間進行網際協同分組簡報. \n 問題: \n 為什麼需要定期進行分組簡報? \n The Importance of Presentation Skills in Institutions of Higher Learning.pdf \n The 7 Main Reasons Why People Give Presentations.pdf \n 以下 Brython 程式可讀取各大組的學員分組資料後, 直接在網頁中列出各學員 cd2022 倉儲與網頁連結、各小組協同倉儲與網頁連結、以及各大組協同倉儲與網頁連結. \n 請注意: 各組學員 github 帳號下除建有個人 cd2022 倉儲外, 還必須 fork 大組倉儲 (例如: 甲班第一大組的倉儲名稱將為: cd2022ag1) 並在各大組進行網際協同分組簡報前, 與所屬大組的分組協同倉儲內容保持同步. \n grp_2022.py  ( run ) \n w4_2a_get_grp1_num_of_members.txt \n w4 2a 分組結果 \n', 'tags': '', 'url': 'Grouping.html'}, {'title': 'Pull requests', 'text': 'cd2022  (cd 為 collaborative design 縮寫) 協同產品設計實習課程的修課學員名單、Github 帳號與大組分組組別資料, 以 Tab (即 \\t) 隔開 ( 2a.txt  與  2b.txt ), 採用倉儲儲存, 再透過 Github Pages, 能讓任何成員從全球資訊網介面: \n http://mde.tw/studlist/2022spring/2a.txt \n http://mde.tw/studlist/2022spring/2b.txt \n 讀取資料內容. \n 採用 Github 存放各班學員相關資料的好處, 是可以讓學員自行透過 Pull Requests 的方式協同管理資料內容, 除能讓資料始終保持正確外版本. 當學員的 Github 帳號或組別有異動時, 能夠自行維護並留下改版紀錄. \n 協同產品設計流程中最重要的概念是: 如何運用各種永續的方法, 讓產品設計的各階段工具與終端產品, 皆能採有效率的方式因應可能遭遇的變化. \n \n 利用 wcm2022 帳號修改  https://github.com/mdecycu/studlist  中的組別資料, 作為 pull request 範例. \n 動態網頁嵌入 Wink 影片的參考 html:  2a_w3_studlist_pull_requests_wink_html.txt \n 以下影片說明如何利用 Pull Requests 對沒有協同管理權限的 github 倉儲進行改版後, 要求合併內容: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 以下影片說明如何透過逆向 Pull Requests 讓各學員帳號下的分組倉儲與組長帳號下的協同倉儲內容保持同步: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'Pull requests.html'}, {'title': 'Revealjs', 'text': 'https://revealjs.com/  是一個 Javascript 程式框架, 可用來建立全球資訊網上的簡報. \n 將 reveal.js 納入分組倉儲的真正目的, 是能直接在統一的 GitHub 提交推送過程中, 持續查核各組員對於協同產品開發流程的貢獻度. \n 至於為何要利用 markdown 格式, 在 Leo Editor 中轉為 index.html 進行展示, 是希望在組員改版間避開以 html 格式處理衝突的難度. \n 課程中所採的各種方法並非限制, 而是在衡量協同利弊得失後的可行方法之一.你們可以就各種工具在協同產品設計流程中的應用. 進行討論及實作, 然後查驗所採行的方法是否也能: \n \n 持續改進 \n 保有各組員的改版紀錄 \n 方便處理合併及展示 \n 具永續性及可應變性 \n \n https://github.com/hakimel/reveal.js  引用了許多 Javascript 程式庫, 這些程式庫的改版非常頻繁, 經常造成改版頻率相對緩慢的  cmsimde  經常收到來自 Github 的改版通知. \n 因此在利用  cmsimde  建立 cd2022 課程網站與大分組網站時, 若要直接使用 Reveal.js 建立線上簡報, 就必須將\xa0 cmsimde  的 reveal 目錄內容保持在最新的 Reveal.js 版本. \n https://github.com/mdecycu/cmsimde_site  就是用於開發  cmsimde  的倉儲. cmsimde_site 的 main 分支直接將  cmsimde  內容放入 cmsimde 目錄, 可以直接根據需求修改其中的任何內容, 當測試無誤後(尚未使用  unittest ), 將改版內容反應至  cmsimde  後, 將在 cmsimde_site 倉儲中的 submodule 分支中進行測試. \n 由於 cmsimde_site 的 main 分支直接將 cmsimde 當作子目錄, 而 submodule 分支則將 cmsimde 當作子模組. 從 main 分支切換到 submodule, 由於需要同時取下 cmsimde 子模組資料, 因此使用: \n git checkout -f submodule --recurse-submodules \n 而從 submodule 分支切換回 main 分支, 則使用: \n git checkout -f main \n cmsimde  倉儲中的 config/reveal.leo 使用  Leo Editor  編輯各簡報頁面內容. reveal.leo 中包含 demo.html 中的各種簡報應用, 使用者可以從 Leo Editor 專案中取出所需的簡報頁面進行編輯. \n 以下影片說明如何利用 Leo Editor 編輯 config/reveal.leo 網際簡報檔案: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 以下影片說明如何利用 Leo Editor 編輯 config/pelican.leo 網誌檔案: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'Revealjs.html'}, {'title': 'Meeting', 'text': 'https://www.atlassian.com/blog/teamwork/how-to-run-effective-meetings \n Most of us don’t have formal training in meeting management skills, but anyone can learn to do it well – whether your team is in the office, fully virtual, or hybrid. \n An efficient meeting starts promptly, stays on track due to good time management, includes as few people as possible, and achieves the stated objective. \n An effective meeting brings a thoughtfully selected group of people together for a specific purpose, provides a forum for open discussion, and delivers a tangible result: a decision, a plan, a list of great ideas to pursue, a shared understanding of the work ahead. Not only that, but the result is then shared with others whose work may be affected. \n Successful meetings have a clear purpose. \n Meetings should never be held for the sole purpose of sharing information – that’s what email, chat, and company intranets (e.g., Confluence) are for. Department and company all-hands meetings are a notable exception. They provide a unique chance for people at all levels of the business to hear directly from executives and other decision-makers – and, if you include time for Q&A, vice-versa. \n In the best-case scenario, a meeting’s purpose is to make a decision or create something collaboratively. Project planning, mapping out customer journeys, setting goals, solving a problem, choosing X vs. Y … all these are situations where holding a meeting is probably the most effective way to get it done. \n Effective meetings keep attendees engaged. \n Effective meetings provide a safe space for divergent thinking. \n Effective meetings produce real, shareable results. \n https://www.nytimes.com/guides/business/how-to-run-an-effective-meeting \n Set the Agenda \n Start on Time. End on Time. \n End with an Action Plan \n https://hbr.org/1976/03/how-to-run-a-meeting \n https://slack.com/blog/productivity/run-effective-meetings \n https://www.scoro.com/blog/tips-for-effective-meeting-management/ \n 結論是: 在協同產品設計流程, 該如何開會? \n', 'tags': '', 'url': 'Meeting.html'}, {'title': 'TEX and LaTeX', 'text': '為什麼協同產品設計實習需要採用 TEX 與 LaTeX 輸出技術文件? \n https://github.com/mdecycu/4072pj1/blob/master/.github/workflows/main.yml \n https://dev.to/mrturkmen/latex-with-github-actions-4580 \n https://www.reed.edu/cis/help/LaTeX/intro.html \n https://ftp.ntou.edu.tw/ctan/info/gentle/gentle.pdf \n http://tug.ctan.org/info/impatient/book.pdf \n https://texdoc.org/serve/TeXbyTopic.pdf/0 \n', 'tags': '', 'url': 'TEX and LaTeX.html'}, {'title': '有關 TeX', 'text': 'A Guide to the Many Flavours of TeX \n 解釋何謂 LaTeX, pdfTeX, pdfLaTeX, XeTeX, XeLaTeX, LuaTeX, and LuaLaTeX. \n The TeX tuneup of 2021 \n XeLaTeX means using the LaTeX macro package with the XeTeX engine. \n LuaLaTeX means using the LaTeX macro package with the LuaTeX engine. \n https://www.luatex.org \n https://www.tug.org/texlive/ \n https://miktex.org/ \n \n', 'tags': '', 'url': '有關 TeX.html'}, {'title': 'Assignments', 'text': '協同產品設計實習課程學員評分要點: \n sustainable (可持續使用, 永續): \n 1 : capable of being sustained (可持續) \n 2a : of, relating to, or being a method of harvesting (獲取成果) or using a resource (運用資源) so that the resource (該資源) is not depleted (不致枯竭) or permanently damaged (永久損壞). \n 2b : of or relating to a lifestyle involving the use of sustainable methods (採取永續的生活方式) \n 在 cd2022 課程 sustainable 代表所採行的解題方式,  為所有分組組員認可是當下環境中, 最佳處理方式與流程, 可作為其他分組學習並能在課程各階段任務中延續使用 . \n resilience (應變能力, 韌性): \n 1 : the capability of a strained body (承受應變物體) to recover its size and shape after deformation caused especially by compressive stress (尤指受到壓縮應力) \n 2 : an ability to recover (回復能力) from or adjust easily (易於調適) to misfortune or change (面臨意外情境或變化) \n 在 cd2022 課程 resilience 代表 各分組成員需具備一定的應變處理能力 . \n 20220302 工作流程: \n \n 將 cadlab 網路連線接到系 backbone (使用純 IPv6 設定後, 為了連結到 IPv4 網站, 必須透過雙協定支援的 proxy server) \n 將兩個隨身碟放入電腦 USB 3.0 插槽 (與 2.0 速度差 10 倍) \n 啟動電腦 \n 在 Windows 10 尚未啟動防毒軟體之前, 以系統管理員身分執行 1_ipv6_network_setup.bat (為了避開蠕蟲惡意的網路攻擊) \n 批次檔案將會開啟 Firefox 連結到 cd2022 課程網頁與倉儲 \n 希望修改 cmsimde 倉儲內容, 以 git clone --recurse-submodules git@github.com:mdecycu/cmsimde.git 取下倉儲資料時, 電腦回報沒有 correct access rights \n 上個步驟表示 putty session github.com 並沒有設定, 可帶出上週在 cdb 從 registry 匯出的 2022_cdb.reg, 直接以滑鼠點擊執行後, 再次執行 git clone --recurse-submodules git@github.com:mdecycu/cmsimde.git 取下 cmsimde 倉儲 \n 但 cmsimde 無法直接產生靜態網頁與動態網頁, 因此以 cmsimde_site 倉儲納入 cmsimde 程式碼, 進行修改後, 將資料回應至 cmsimde \n 需要新增 github 倉儲, 因此必須登入 github.com 建立 cmsimde_site 倉儲 (能不能直接在近端使用 ssh 與程式建立 github 倉儲?) \n 因為要取 2a 學員 github 帳號, 以 ssh 登入 .17 電腦, 啟動 ethercalc \n 由於必須從教務主機取得 2a 學員學號, 經由 heroku 雲端主機取得  https://nfulist.herokuapp.com/?semester=1102&courseno=0752&column=True \n 連接至 cd2022 gitter, 告知擷取 2a github 帳號的 ethercalc 表單連結 \n cd2022 要求每一學員必須在 github 帳號下建立 cd2022 倉儲與網頁, 並且由各小組組長建立 cd2022ag1-1 (為第一組第一小組), 且每位學員在 cd2022ag1-1 都擁有 git push 權限, 或採 pull requests 方式修改小組分組倉儲內容 \n 而每一大組的組長負責建立 cd2022ag1 (為 2a 第一大組為例) 後, 各大組學員對分組倉儲可以擁有 git push 權限, 或各學員採 pull requests 方式修改大分組倉儲內容 \n 各學員在每週會議後, 個人所負責完成的內容或簡報必須先放到個人的 cd2022 倉儲後, 再透過小組協同倉儲練習如何解決組員間提交內容的衝突後, 再整合至各大組的協同倉儲. \n 接著要從 ethercalc 取下 2a 學員的 github 帳號與大組分組資料, 並存入 studlist 倉儲 (能不能用程式協助?) \n \n 2a w2 assignments: \n 1. 在個人帳號下, 使用 最新版的 cmsimde  建立 cd2022: \n 以子模組的方式建立倉儲: \n git submodule add https://github.com/mdecycu/cmsimde.git cmsimde \n 或者直接將 cmsimde 倉儲作為 cmsimde 目錄: \n git clone --recurse-submodules https://github.com/mdecycu/cmsimde.git \n 然後再將沒有 git 版本資料的 cmsimde 目錄放到個人倉儲. \n 2. 根據  https://mde.tw/cd2022_guide/content/Grouping.html \xa0 中的 2b 程式執行, 配合  https://mde.tw/studlist/2022spring/2a.txt  修改為能夠直接在頁面顯示各組員的 cd2022 倉儲與網頁連結, 以及各學員協同大分組倉儲與網頁連結 (例如: cd2022ag1). 3. 能否透過 github api 程式 (也可以逐一進入各班組員 github 帳號, 以手動查驗後, 以表格列出結果), 列出 w2 階段各組員帳號下 cd2022 與 cd2022ag1 (以 2a 第一組組員為例) 是否符合陽春的 cmsimde_site 內容. (例如: 透過  https://github.com/PyGithub/PyGithub ) \n 2bw2: \n 建立個人 cd2022 與 cd2022bg1 (以 2b 第一大組為例) 時, 可以用 import  cmsimde_site  倉儲 (但 history 將會是 mdecycu 而非學員), 或 git submodule add 或直接將 cmsimde 下載  https://github.com/mdecycu/cmsimde/archive/refs/heads/master.zip  後解開為倉儲下的 cmsimde 目錄, 之後再將 up_dir 內容複製到倉儲根目錄. 當評分檢查時, 各大組需繳交全班各學員是否達成任務要求. \n cd2022 w2 任務 1: \n 請各組利用一個小時建立一個欄位以 tab 隔開的 txt 檔案, 欄位標題分別為學號, 個人倉儲, 大分組倉儲排列, 按照各班學員學號順序 ( 2a 修課學員 ,  2b 修課學員 ). 完成後請各大組將結果回應至  2b w2 討論區 . \n', 'tags': '', 'url': 'Assignments.html'}, {'title': '各週任務', 'text': 'w2 任務: \n 問題緣起: \n 第二週的任務 啟動源頭 來自課程實際分組時所產生的問題. \n 各班利用 Ethercalc 表單同步輸入 github 帳號與組別時, 將資料存入  https://github.com/mdecycu/studlist \xa0 倉儲. \n 經由 Github Pages 設定後, 可由  https://mde.tw/studlist/2022spring/2a.txt  讀取甲班的學員帳號及分組資料 (各欄位以 tab 隔開), 而從  https://mde.tw/studlist/2022spring/2b.txt  則可讀取乙班的學員帳號及分組資料. \n 指定任務: \n 請學員以全球資訊網頁的 URL 讀取各班資料後, 是否能夠以永續便捷的方式取得已經選好組別的 學員學號 、學員 個人倉儲連結 、學員 個人網站 、各組位於學員帳號下的 大組倉儲 以及各學員帳號下各大組的 協同網站 . \n 而針對尚未填入 github 帳號的學員, 以其學號作為其 github 帳號. 針對尚未列出分組序號的學員, 則委由隨機方式編入尚不足 8 名學員的組別, 若各組已經都補滿 8 名學員, 仍餘有尚未分組的學員時, 則採隨機方式從各班第一組依序補入各組後, 分別在個人及大分組的 w2 標題頁面中, 列出各大組與全班的上述要求資料. \n 到了 w4 各班學員分組已經底定, 若採 Brython 方式(全球資訊網前端)將學員資料讀出後進行排序與整合, 可以如  https://mde.tw/cd2022_guide/content/Brython.html  中, 直接在網頁上即時列出與  https://mde.tw/studlist/2022spring/2a.txt  及  https://mde.tw/studlist/2022spring/2b.txt  對應的學員倉儲與網頁連結, 以及各學員帳號下的大組同步倉儲與網頁連結. \n 接下來若要採 CPython (全球資訊網後端或  CLI/GUI  模式)在 Windows 環境中執行運算, 該如何進行? \n w3 任務: \n 問題緣起: \n w2 完成分組後, 各組即進入利用 NX1980 繪製 uArm 機械手臂的協同設計階段, 其中包括手臂兩側的正齒輪減速機設計, 以及各連桿與組立所需要的其他組件設計等 (完成圖如  Onshape 中的 uArm 組立圖 ). \n cd2022_uarm_nx12_imported.7z \n uArm 機械手臂的初步設計目的, 是完成 NX1980 組立圖後, 能轉入 Coppeliasim 環境中進行機電系統組合模擬, 讓操作者透過  Custom UIs 介面 操控四個自由度的 uArm 步進伺服馬達. \n 指定任務: \n 這裡 有 38 個比較接近 NX1980 版本功能的教學影片 ( 連結 ), 請以每一學員分配 5 個影片的原則, 由各學員在 w3 標題頁面中, 根據影片中的教學內容, 以 Wink 影片互相對照的方式採 NX1980 執行操作進行整理, 完成後請將所負責的 Wink 教學影片嵌入個人與大分組的 w3 標題頁面中. \n w4 各班上課時段前 , 請各小組與大組成員分別開會討論後, 採協同設計流程執行上述任務, 並準備在 w4 上課時段中直接利用網頁簡報呈現各大組的執行流程與結果. \n', 'tags': '', 'url': '各週任務.html'}, {'title': 'w6 任務', 'text': '2a w6 blog 查驗 \n 2a_stage1.txt \n 2a_stage2.txt \n 2a_stage3.txt \n 2b w6 blog 查驗 \n 2b_stage1.txt \n 2b_stage2.txt \n 以下影片說明如何利用 Leo Editor 編輯 config/pelican.leo 網誌檔案: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'w6 任務.html'}, {'title': 'w7 任務', 'text': '2a w7 summary 查驗  ( 2a 有網誌者 ) \n 2b w7 summary 查驗  ( 2b 有網誌者 ) \n 為了讓各組設計中的 uArm 機械手臂 ( cd2022_uarm_nx12_imported.7z ) 能夠透過 Pick and Place 控制流程參與  Tic-Tat-Toe 遊戲 , 本週將進行下列實習任務: \n 請利用隨身程式系統編譯  https://github.com/mdecourse/scarysim  中的 SCARA robot 模擬系統. 完成此 Qt C++ 程式碼的編譯與操作後, 接著請完成 CoppeliaSim 範例中  MTB robot  所進行的  Pick and Place demo . \n 設法以隨身程式系統編譯此程式碼: \n \n git clone  https://github.com/mdecourse/scarysim.git \n 修改 scarysim.pro, 蓋掉第 11 行, 成為 # LIBS\xa0\xa0\xa0\xa0 += -lglut -lGLU \n cd scarysim \n qmake -o Makefile scarysim.pro \n mingw32-make -f Makefile.Release 可以在 release 目錄取得 scarysim.exe \n 因為 scarysim.exe 執行需要 base.obj, arm1.obj, arm2.obj, arm3.obj 等零件外型檔案, 以及對應的 .mtl 材質檔案, 因此可將 scarysim.exe 移至倉儲根目錄, 並且需要 msys64_20210419\\mingw64\\bin 路徑中的 dll 動態連結程式庫配合執行. \n 由於此套程式碼在 Target 模式下, 零組件間會造成干涉, 表示其 Inverse Kinematic 運算並不正確, 請設法修正此錯誤後, 修改其零件尺寸與操作控制方法, 設法模擬 MTB 的  Pick and Place demo  範例. \n 請各組指定組員分別利用 Solvespace、NX12、NX1980、NX2008 與 Onshape 繪製  Pick and Place demo  範例所需的零組件, 並完成 Coppeliasim 4.1.0、4.2.0 與 4.3.0 版的 MTB 機械手臂 Pick and Place 模擬, 完成後請說明在使用不同 MCAD 系統與版次的情況下, 該如何執行協同產品設計專案. \n \n Deliverables : \n \n 各組組員以 Pelican 網誌 (w7_pick_and_place.html) 及 Reveal.js 簡報紀錄個人所完成的內容. \n 各大組以 Pelican 網誌 (w7_pick_and_place.html) 及 Reveal.js 簡報摘要各大組任務執行結果. \n 各大組將所有完成的程式碼、編譯結果、MCAD 零組件檔案以及場景模擬檔案壓縮為 .7z (以 2ag1 大分組為例, 檔案名稱設為w7_pap_cd2022ag1.7z) 後, 送到組長的 @gm 帳號下的  OneDrive  共享區, 設定為只有 @gm 帳號登入者可以下載的共用權限後, 將連結發布在大組的 Pelican 網誌中. \n 各大組以程式方法執行上述任務的量化查驗後, 結合組員自評與互評流程後, 將各組員的評量結果存為 w7_cd2022ag1_evaluation.txt (以 2ag1 為例), 採允許各組組員與 yen@gm 共享下載進行設定. \n \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'w7 任務.html'}, {'title': 'w7_summary', 'text': "2a w7 summary 查驗  ( 2a 有網誌者 ) \n 2b w7 summary 查驗  ( 2b 有網誌者 ) \n 請各大組在分組 blog 區域加入一個 Slug: w7_summary 的工作摘要說明, 將本週課堂上每位組員的工作內容與進度列在網誌中, 並以連結導引至各組員的個人網站中. \n 請各大組在摘要網誌中回答下列問題: \n \n 如何集結各大組組員在各週所完成的工作進度? \n 為何要在大組倉儲中建立 Reveal 投影片與 Pelican Blog? ( git blame 用法 ) \n 可以利用 Leo Editor 延續開發  scarysim  程式功能嗎? (與  VScode  比較, 或者直接在 VScode 中使用 Leo Editor,  leointeg ) \n \n 假如在各大組倉儲的 downloads 目錄中針對每週的任務進行分類, 例如: 建立 downloads/w7 目錄, 讓各組組員利用 users/學號.leo 編寫個人有關的 blog 或其他相關資料的導入或引用, 如此, 就可以在上課階段 (stage1) 或次週上課前 (stage2), 以手動或程式方法集合各組員的 blog, reveal 或 cmsimde 內容, 經過人工查核後, 直接發布在各大組的網頁、網誌或簡報上. \n 協同重點: \n \n 各組員負責維護各自的 users/學號.leo, 每次提交推送並不會產生衝突. \n 經由 users/學號.leo 建立 downloads/w7 目錄中, 各組員根據學號或主題所提交推送的網誌、網頁或簡報片段資料, 若產生衝突, 將會比較容易進行檢查與合併. \n 透過已經處理衝突後的 downloads/w7 目錄資料, 由人工或程式集結各段落內容, 可以減少解決衝突的難度. \n \n Leo Editor 常用大綱標題指令: \n @path \n @edit 檔名 \n @clean 檔名 + sub-outline 中的 @others \n @auto 檔名 \n @button \n @path mardown 表示隨後的 sub-outline 路徑都將位於 markdown 目錄之下. \n @edit myfile.md 表示存檔後, 將在此節點所對應的路徑下, 修改或新建 myfile.md 檔案. \n @clean myfile.md 表示存檔後, 將在此節點所對應的路徑下, 結合其子節點與上層 @others 所在位置的所有內容, 修改或新建 myfile.md 檔案. \n 以下程式片段, 存於節點對應的內容區後, 按下 ctrl + b 可以執行. \n '''Recursively import all python files in a directory and clean the result.'''\n\nc.recursiveImport(\n    dir_ = r'./',\n    kind = '@clean', \n    safe_at_file = False,\n    theTypes =  ['.py']\n) \n Reference: \n https://leoeditor.com/tutorial.html \n \n", 'tags': '', 'url': 'w7_summary.html'}, {'title': 'w8 任務', 'text': '任務一: 請依照下列步驟編譯 simExtMtb plugin 專案: \n w7_project.7z \n 編譯  simExtMtb  plugin: \n 針對 simExtMtb.pro: \n \n CoppeliaSim 4.1.0 原始碼編譯專案  (登入 @gm OneDrive 後下載). \n E:\\downloads\\cop410\\programming\\simExtMTB>qmake -o Makefile simExtMtb.pro \n E:\\downloads\\cop410\\programming\\simExtMTB>mingw32-make -f Makefile.Release \n 在 release 目錄中取得 simExtMtb.dll, 啟動前放入 Coppeliasim 根目錄. \n \n 任務二: 請各組依照下列零件檔案, 將組員分為三組, 分別以 Solvespace, NX (12, 1980 或 2008) 及 Onshape, 完成各零件 工程圖 與 組合圖 後, 將 uarm 組合件轉為  STL 格式後轉入 CoppeliaSim , 並安排以 GUI Slider 方式 控制前三軸作動 . 各組員需將零組件繪製過程與 CoppeliaSim 操控流程及心得, 寫為 Pelican Blog 與 Reveal.js 簡報, 並在期中考週將個人與分組網誌與簡報流程透過 Wink 製作為 mp4 影片嵌入個人與分組網頁, 流程中的 cmsimde H1 頁面命名為  midterm , 而網誌命名為  midterm.html ,  簡報 則採 index.html 命名. \n 查驗項目: \n \n uarm 各零件工程圖 \n uarm 組合圖 \n uarm 組合圖 STL 格式轉入 CoppeliaSim \n GUI slider 控制前三軸作動 \n cmsimde 中第一階頁面, 標題為 midterm \n 網誌名稱為 midterm.html \n 流程與心得簡報 \n \n Onshape 中的 uArm 組立圖 \n cd2022_uarm_nx12_imported.7z \n \n uarm 末端連桿尺寸: \n \n', 'tags': '', 'url': 'w8 任務.html'}, {'title': 'uarm 主體零件', 'text': '從  cd2022_uarm_nx12_imported.7z  中的\xa0 uArmSwiftPro_UP1300_3D_hide_parts.prt  可整理出下列主體零件, 請問能否透過程式方法讀取下列零件後, 在 cmsimde 頁面中, 以  Three.js 架構 列出這些主體零件? \n 前端通用件 \n 前端關節 \n 7mm 支撐柱 \n 3mm 鋁支撐柱 \n 三角形連桿軸承壓緊件 \n 三角形連桿 \n 絞鍊 \n 主臂關節2 \n 主臂關節1 \n 電機軸承支撐座_左側 \n 電機軸承支撐座_右側 \n 右側曲柄 \n 輸出軸 \n 右側連桿 \n 左側連桿 \n 4mm 鋁支撐柱 \n 減速箱上殼 \n L 型連接件 \n 軸承支撐軸 \n 軸承支撐圈 \n 底座上蓋 \n 底座中間部分 \n 底座蓋 \n References: \n 從 STL 檔案轉為 non-parametric solid . \n https://www.swooshtech.com/2018/04/13/taking-the-next-step-in-nx/ \n https://www.nxjournaling.com/content/beginning-journaling-using-nx-journal \n 與 uarm 相同機構的 EvoArm:  https://github.com/AliShug/EvoArm  (採 Inventor 繪圖) \n', 'tags': '', 'url': 'uarm 主體零件.html'}, {'title': 'Spur Gear', 'text': "uarm 機械手臂零組件從 STEP 203 轉入 NX12 -  cd2022_uarm_nx12_imported.7z \n 若使用 NX12, 其中需要設計並繪製減速機中的正齒輪組 (Spur Gear Train), 若採 UGOPEN C 編寫延伸程式, 可以利用 MSYS2 中的 gcc 進行編譯與連結: \n mkdir build\n\nmkdir dist\n\nREM compile gear.c\ngcc.exe -c -g -IC:\\nx12_portable\\data\\nx12\\UGOPEN -MMD -MP -MF build/gear.o.d -o build/gear.o gear.c\n\nREM link with libufun.lib and libugopenint.lib\ngcc.exe -shared -o dist/gear.dll build/gear.o C:\\nx12_portable\\data\\nx12\\UGOPEN\\libufun.lib C:\\nx12_portable\\data\\nx12\\UGOPEN\\libugopenint.lib  \n 取得 gear.dll 後, 可開啟 new Model file 後, 以 File -> Execute -> NX Open 執行 gear.dll. \n UGOpen C 程式架構請參考  UG_Open-API_Programming.pdf \n UGOpen 技術文件請參考: \n UG Open Doc \n Open C Programmer's Guide  (for internal use only) \n Open C Reference Manual  (for internal use only) \n 以下為 gear.c 編譯連結與執行過程: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 除了使用上述 NX UGOpen C 的 gear.c 協助正齒輪的設計繪圖外, 也可以利用 NX12 版之後系統自帶的 \\UGOPEN\\SNAP\\examples\\More Examples\\Gear\\Gear.vb. \n", 'tags': '', 'url': 'Spur Gear.html'}, {'title': 'Block UI Styler', 'text': 'Application -> Gateway -> More -> Block UI Styler \n NXOpen_Getting_Started_2019.pdf  中  Chapter 14: Block-Based Dialogs  說明如何利用 Block UI Styler 應用程式建立 API 程式所需要的表單. \n NX1953 Block UI Styler Documentation \n 利用 Block UI Styler 建立表單, 用來控制 block.prt 零件的長寬與高:  block_ui.7z  (NX2008 零件檔案) \n 操作方法: 以 NX2008 開啟 block.prt, 利用 Menu -> Tools -> Journal -> Play 執行 length_width_height.py, 待出現方塊長度、寬度與高度的設定表單後, 填入所需尺寸後, 按下 Ok, 零件即可依照設定修改尺寸. 此為利用 Block UI Styler 所製作的互動式零件參數設定. 若將表單移置網誌 Brython 前端, 則可依相同方式設定 Server 上的 NX2008 零組件檔案的設計參數. \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n Example codes: \n CreateNode API: \n node = self.tree_control0.CreateNode("NodeDisplayText")\n# Set properties of node\nnode.ForegroundColor = 198\nnode.DisplayIcon = "edge"\nnode.SelectedIcon = "draft" \n InsertNode API: \n self.tree_control0.InsertNode(\n    node, parentNode, afterNode, \n    NXOpen.BlockStyler.Tree.NodeInsertOption.AlwaysLast) \n AskEditControl Callback: \n def AskEditControl (self, tree, node, columnID):\n    control = None\n    try:\n        options = ["AcceptText", "DefaultText", " RejectText"]\n        # The option must be set here or there will \n        # be no options available to edit.\n        tree.SetEditOptions(options, 1)\n        control = NXOpen.BlockStyler.Tree.ControlType.ListBox \n        # or NXOpen.BlockStyler.Tree.ControlType.ComboBox\n    except Exception as ex:\n        # ---- Enter the exception handling code here. -----\n        pass\n    return control \n OnEditOptionSelected Callback: \n def OnEditOptionSelected(\n    tree, node, columnId, selectedOptionID, \n    selectedOptionText, type):\n    try:\n        if type == NXOpen.BlockStyler.Tree.ControlType.ComboBox:\n            if selectedOptionText == "RejectText":\n                OnEditOptionSelected = \n                    NXOpen.BlockStyler.Tree.EditControlOption.Reject\n            else:\n                OnEditOptionSelected = \n                    NXOpen.BlockStyler.Tree.EditControlOption.Accept\n        elif type == NXOpen.BlockStyler.Tree.ControlType.ListBox:\n            if selectedOptionText == "RejectText":\n                OnEditOptionSelected = \n                    NXOpen.BlockStyler.Tree.EditControlOption.Reject\n            else:\n                OnEditOptionSelected = \n                    NXOpen.BlockStyler.Tree.EditControlOption.Accept\n    except Exception as ex:\n        # ---- Enter the exception handling code here. -----\n        pass \n OnMenuCallback: \n class MenuID:\n    AddNode = 0\n    DeleteNode = 1\n    SubMenuItem1 = 2\n    SubMenu1 = 3\ndef OnContextMenuCallback(self, tree, node, columnID):\n    try:\n        menu = tree.CreateMenu()\n        SubMenu1 = tree.CreateMenu()\n        menu.AddMenuItem(MenuID.AddNode, "Add Node")\n        menu.AddSeperator()\n        menu.AddMenuItem(MenuID.DeleteNode, "Delete Node")\n        # Sub menu\n        SubMenu1.AddMenuItem(MenuID.SubMenuItem1, "Sub Menu Item 1")\n        # Set submenu\n        menu.SetSubMenu(MenuID.SubMenu1, SubMenu1)\n        # Set menu on the tree\n        tree.SetMenu(menu)\n        # Dispose the menu only after setting the menu on the tree\n        menu.Dispose()\n        SubMenu1.Dispose()\n    except Exception as ex:\n        # ---- Enter the exception handling code here. -----\n        self.theUI.NXMessageBox.Show(\n            "Block Styler", \n            NXOpen.NXMessageBox.DialogType.Error, \n            str(ex)) \n OnMenuCommandCallback: \n def OnMenuCommandCallback(self, tree, node, menu_item_id):\n    try:\n        if menu_item_id == MenuID.DeleteNode:\n            tree.DeleteNode(node)\n    except Exception as ex:\n        # ---- Enter your exception handling code here -----\n        pass \n StateIconName Callback: \n def StateIconNameCallback (self, tree, node, state):\n    stateIcon = ""\n    try:\n        if state == 3:\n            stateIcon = "hole"\n        elif state == 4:\n            stateIcon = "boss"\n        elif state == 5:\n            stateIcon = "revolve"\n    except Exception as ex:\n        # ---- Enter your exception handling code here -----\n        pass\n    return stateIcon \n StateIconName Callback: \n def StateIconNameCallback (self, tree, node, state):\n    stateIcon = ""\n    try:\n        if state == 3:\n            stateIcon = "hole"\n        elif state == 4:\n            stateIcon = "boss"\n        elif state == 5:\n            stateIcon = "revolve"\n    except Exception as ex:\n        # ---- Enter your exception handling code here -----\n        pass\n    return stateIcon \n OnSelectCallback \n def OnSelectCallback (self, tree, node, columnID, selected):\n    node1 = self.tree_control0.CreateNode(self.newNodeString)\n    parentNode = NXOpen.BlockStyler.Tree.Node.Null\n    afterNode = NXOpen.BlockStyler.Tree.Node.Null\n    self.tree_control0.InsertNode(\n        node1, parentNode, afterNode, \n        NXOpen.BlockStyler.Tree.NodeInsertOption.Sort) \n Tutorial: \n https://www.youtube.com/watch?v=qeDgmwz-xQU \n https://www.youtube.com/watch?v=Qo_A2lJEn0c \n', 'tags': '', 'url': 'Block UI Styler.html'}, {'title': 'w10 任務', 'text': '請各組員在下列影片中加入註解說明後, 分別以 w10_block_ui、w10_nx_integ 與 w10_ssh 作為標題, 將說明影片嵌入個人 cd2022 網站頁面 (設為 H2 或 H3) 及 blog 網誌中. \n w10-1 任務執行步驟: \n \n 下載 w10_block_ui.wnk \n 利用 Wink 開啟專案 \n 在各頁面加入說明標註 \n 若有其他附加頁面, 則需縮至 1008x630 後插入適當位置 \n 完成後轉出對應的 mp4 放入頁面與網誌 \n \n w10_block_ui \n 以下影片嵌入 html 內容 (採用的  cmsimde 版本 ): \n <script>\n// 在 Javascript 標註內以兩個斜線加入單行註解\n// 每一個影片要有獨特的 data-varname 變數名稱\nvar winkVideoData_w10_block_ui = {\n  dataVersion: 1,\n  frameRate: 10,\n  buttonFrameLength: 5,\n  buttonFrameOffset: 2,\n  frameStops: {\n  },\n};\n</script>\n<!-- 將 mp4 檔案從 downloads 目錄取出 -->\n<div class="winkVideoContainerClass" style="border: thin solid black; padding: 10px;"><video width="100%" height="100%" autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="./../cmsimde/static" data-varname="winkVideoData_w10_block_ui" muted="true">\n<source src="./../downloads/w10_block_ui/w10_block_ui.mp4" type="video/mp4" /></video></div> \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n w10_nx_integ \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n w10_ssh \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'w10 任務.html'}, {'title': 'cube', 'text': '以下為採用 NX1980 繪製的正方體零件, 可能原先的繪圖流程是在草圖階段繪圖時並未對長度與寬度設定尺寸, 就直接長出實體, 然後再回到草圖設定尺寸, 因此 Tools -> Expressions 以 p1 定義高度, 而長度則設為 p2, 寬度設為 p3, 在沒有透過 set Expressions 對長度與寬度對應尺寸約束之前, 在 Tools -> Expressions 只能看到 p1, 其實 p2 與 p3 應該已經跟草圖的尺寸綁定, 因此可以透過 NXOpen Python API 程式 對無列出長寬尺寸變數的零件進行操控, 看是否能夠利用 p2 與 p3 變數控制草圖大小. \n 以下為設法透過草圖編輯列出尺變數的 Wink 影片: \n 參考零件.7z \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n', 'tags': '', 'url': 'cube.html'}, {'title': 'run_journal', 'text': '若以 NXOpen Python API 為例, 可以安排將 AJAX 送進 Server 的設計變數存為檔案, 然後由 run_journal.exe 執行的 Python 程式讀進設計變數後, 驅動 NX12、NX1980 或 NX2008 後將結果透過 URL 傳回前端瀏覽器端. \n run_journal.exe help: \n Usage: run_journal [ -pim ] [ -r=<filename>[,lang=<lang>][,format=<format>] ] [ -profile ] [ -allow_redo ] <journal-file> [ -args .... ]\n    Runs a journal file from the command line\n\n    -pim           Run the journal with NX connected to Teamcenter\n                   Any arguments after -pim that are not in the list below but are before\n                   the -args switch are assumed to be for setting up the Teamcenter session,\n                   examples are -u=<user>, -p=<password> and -g=<group>\n    -r=<filename>[,lang=<lang>][,format=<format>]\n                   Rerecord a new journal to the given file name\n                   <lang> must be vb, cpp, cs, java or py\n                   <format> must be ascii, utf8, unicode, or unicode_big_endian\n    -profile       Profile this journal\'s calls\n    -args ...      Pass the rest of the command line after this as\n                   an array of strings to Main in the journal file\n    -allow_redo    Enables redo, useful for tests but not for normal automation and\n                   takes some resources when enabled\n    -help          Prints this message \n block_modified_on_site.py \n # 導入 NXOpen\nimport NXOpen\nimport NXOpen.UF\nimport NXOpen.Gateway\n   \ndef main():\n    # 取得目前開啟的工作階段\n    theSession = NXOpen.Session.GetSession()\n    theUfSession = NXOpen.UF.UFSession.GetUFSession()\n      \n    # 建立 ListingWindow\n    listWin= theSession.ListingWindow\n    # 開啟零件檔案\n    basePart1 = theSession.Parts.OpenBaseDisplay("C:/mdecycu/cd2022_guide/downloads/w11_ajax/block.prt")\n    workPart = theSession.Parts.Work\n    unit1 = workPart.UnitCollection.FindObject("MilliMeter")\n    # height\n    p7 = workPart.Expressions.FindObject("p7")\n    # width\n    p8 = workPart.Expressions.FindObject("p8")\n    # length\n    p9 = workPart.Expressions.FindObject("p9")\n    workPart.Expressions.EditWithUnits(p7, unit1, "30")\n    workPart.Expressions.EditWithUnits(p8, unit1, "60")\n    workPart.Expressions.EditWithUnits(p9, unit1, "90")\n    theSession.UpdateManager.DoUpdate(0)\n    #saveStatus1 = workPart.SaveAs("c:/tmp/block_new.prt")\n    #saveStatus1.Dispose()\n    # initialize list to hold bodies\n    theBodyTags = []\n   \n    for x in workPart.Bodies:\n        if x.IsSolidBody:\n            theBodyTags.append(x.Tag)\n      \n    # 準備輸出 ASCII 格式 STL 零件檔案\n    sTLCreator1 = theSession.DexManager.CreateStlCreator()\n    sTLCreator1.AutoNormalGen = True\n    sTLCreator1.ChordalTol = 0.08\n    sTLCreator1.AdjacencyTol = 0.08\n    sTLCreator1.OutputFile = "C:/mdecycu/cd2022_guide/downloads/w11_ajax/block_ascii.stl"\n    # Binary STL: NXOpen.STLCreatorOutputTypeEnum.Binary\n    sTLCreator1.OutputType = NXOpen.STLCreatorOutputTypeEnum.Text\n    # 已知 body1 命名\n    body1 = workPart.Bodies.FindObject("EXTRUDE(2)")\n    added1 = sTLCreator1.ExportSelectionBlock.Add(body1)\n    nXObject1 = sTLCreator1.Commit()\n    sTLCreator1.Destroy()\n  \n    # 開啟所建立的 ListingWindow\n    listWin.Open()\n    listWin.WriteLine("number of solid bodies: " + str(len(theBodyTags)))\n   \n    (massProps, Stats) = theUfSession.Modeling.AskMassProps3d(theBodyTags, len(theBodyTags), 1, 4, .03, 1, [0.99,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])\n    listWin.WriteLine("units: kg, mm")\n    listWin.WriteLine("surface area: " + str(massProps[0]))\n    listWin.WriteLine("volume: " + str(massProps[1]*1E9))\n    # 在 ListingWindow 中寫入字串\n    listWin.WriteLine("Hello, NXOpen")\n    listWin.Close()\n     \n    # 將零件檔案 fit 之後, export 出 png 檔案\n    # 假如開啟 NX GUI 後執行 互動模式 1\n    \'\'\'\n    theUI = NXOpen.UI.GetUI()\n    imageExportBuilder1 = theUI.CreateImageExportBuilder()\n \n    custombackgroundcolor1 = [None] * 3\n    custombackgroundcolor1[0] = 1.0\n    custombackgroundcolor1[1] = 1.0\n    custombackgroundcolor1[2] = 1.0\n \n    imageExportBuilder1.SetCustomBackgroundColor(custombackgroundcolor1)\n    imageExportBuilder1.FileFormat = NXOpen.Gateway.ImageExportBuilder.FileFormats.Png\n    imageExportBuilder1.FileName = "C:/mdecycu/cd2022_guide/downloads/w11_ajax/block.png"\n \n    imageExportBuilder1.BackgroundOption = NXOpen.Gateway.ImageExportBuilder.BackgroundOptions.Original\n \n    imageExportBuilder1.EnhanceEdges = False\n    imageExportBuilder1.RegionMode = False\n    # fit view 後 commit export png\n    workPart.ModelingViews.WorkView.Fit()\n    nXObject6 = imageExportBuilder1.Commit()\n \n    imageExportBuilder1.Destroy()\n    \n    # 互動模式 2\n    # https://docs.plm.automation.siemens.com/data_services/resources/nx/11/nx_api/custom/en_US/nxopen_python_ref/NXOpen.UF.Disp.CreateImage.html?highlight=createimage\n    workPart.ModelingViews.WorkView.Fit()\n    disp = theUfSession.Disp\n    screenshotPath = "C:/mdecycu/cd2022_guide/downloads/w11_ajax/block"\n    png = NXOpen.UF.DispImageFormat.PNG\n    white = NXOpen.UF.DispBackgroundColor.WHITE\n    disp.CreateImage(screenshotPath, png, white)\n    \'\'\'\n    # 無 GUI 互動模式導出零件 .jpg\n    # https://docs.plm.automation.siemens.com/data_services/resources/nx/10/nx_api/en_US/custom/nxopen_python_ref/NXOpen.UF.Disp.BatchShade.html\n    workPart.ModelingViews.WorkView.Fit()\n    disp = theUfSession.Disp\n    screenshotPath = "C:/mdecycu/cd2022_guide/downloads/w11_ajax/block.jpg"\n    method = NXOpen.UF.DispShadeMethod.GOURAUD\n    disp.BatchShade(screenshotPath, 1920, 1080, method)\n      \nif __name__ == "__main__":\n    main()', 'tags': '', 'url': 'run_journal.html'}, {'title': 'w11 任務', 'text': "本週將要進行兩項任務, 第一是確認各分組能夠有效在組長的分組倉儲中, 以非同步協同的方式進行 uArm 機械手臂場景的建置與操控, 第二則是從 CoppeliaSim 的兩種  XML 檔案格式 , 了解如何透過程式方法建立 uArm 機械手臂場景. \n w11-1 任務: \n 請各組組員在第一節課堂時段, 以每兩人一小組的方式, 在組長帳號下的分組倉儲中的同一網頁 (標題為 w11s1 ~w11s4) 加入個人 w8-w10 協同設計過程所負責的項目內容與心得. 過程中請參考下列 Wink 影片解決可能產生的衝突, 最後並將 git pull 至 acp 的操作過程, 建立 Wink 影片後, 以組員為單位嵌入個人負責的協同網頁中. \n 學習要點: \n 各組員是否透過 SSH 協定, 參與組長帳號下的分組倉儲內容協同編輯? \n 各組員是否在自己的 Github 帳號下, fork 分組協同倉儲後, 與組長帳號下的分組倉儲內容保持同步? \n 各組員是否在近端對分組倉儲改版前, 都透過 git pull 處理內容衝突與合併後, 再對分組倉儲改版? \n 各組是否每週舉行分組會議, 檢討協同設計內容進度, 並研討所面臨議題解決方案? \n w11-2 任務: \n \n 請自行搜尋 STL 檔案中的 ASCII 與 Binary 格式, 舉例說明這兩種零件檔案格式如何定義? \n 請利用 MTB 機械手臂中的 Link2 零件檔案為例, 分別在 Solvespace、NX 與 Onshape 中建立 Link2 零件檔案後, 分別以 Binary 與 ASCII 格式轉出 STL 檔案, 若轉出的 STL 為 Binary 格式, 則請設法以 Python 程式轉為 ASCII 格式, 反之, 若轉出的 STL 為 ASCII 格式, 也請設法以 Python 程式轉為 Binary 格式. \n 請試著將 Link2 零件檔案轉入 Coppeliasim 後, 分別以兩種 XML 格式轉出, 並以 Leo Editor 導入後比較其內容差異. CoppeliaSim 兩種 XML 格式中的 tags, 可利用下列檔案讀取: \n \n 學習要點: \n STL 零件檔案格式是如何定義的? \n 為什麼 STL 格式的零件檔案需要分 ASCII 與 Binary 格式? \n Python 程式如何讀取 Binary 格式的 STL 零件檔案? \n 能否利用 Python 程式對 STL 格式的零件檔案, 分別在 ASCII 與 Binary 之間互相轉換? \n CoppeliaSim 機電模擬場景中的 XML 檔案, 能否置入 STL 格式的零件? \n 利用程式方法組合 XML 格式的 CoppeliaSim 機電模擬場景的目的為何? \n 一個整合零組件架構、驅動配置、GUI 介面以及自動控制程式的 CoppeliaSim 場景, 其 XML tags 與屬性檔案能否透過 Leo Editor 執行編輯? \n # from https://stackoverflow.com/questions/29596584/getting-a-list-of-xml-tags-in-file-using-xml-etree-elementtree\nimport xml.etree.ElementTree as ET\n# load and parse the file\nxmlTree = ET.parse('two_link_slvs_shaft_simple.simscene.xml')\n\nelemList = []\n\nfor elem in xmlTree.iter():\n    elemList.append(elem.tag)\n\n# now I remove duplicities - by convertion to set and back to list\nelemList = list(set(elemList))\n\n# Just printing out the result\nprint(elemList)\n\nfor i in elemList:\n    print(i) \n 解決協同設計流程中的倉儲衝突 \n 當各組學員對組長帳號下的分組倉儲具備協同管理權限後, 各學員可以 git 採非同步協同設計, 對組長帳號下的分組倉儲進行改版, 其間不免要設法以手動方式解決 config/content.htm 動態超文件中的衝突. \n 以下影片就是利用動態網頁系統中的 Search 與 Edit All 設法找出帶有衝突起點、中線與衝突終點的超文件範圍, 然後根據協同設計整體需求解決衝突後, 新增、提交並推送新版本. \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 至於各學員帳號下 fork 的分組倉儲, 則可以透過逆向 Pull Requests 設法與組長帳號下的分組倉儲保持同步, 並設定 Github Pages 呈現各組員帳號下的分組倉儲靜態網頁. \n 模擬場景的  XML 格式 \n CoppeliaSim 場景可以存為 exhaustive format 與 simple format 等兩種  XML 格式 的純文字檔案. 意即使用者應該有機會可以根據這兩種  XML 格式 中的語法, 透過程式方法建立所需的模擬場景. \n 假如希望利用 Leo Editor 處理 CoppeliaSim  XML 格式 場景, 可以參考 這裡 的說明. 將 CoppeliaSim  XML 格式 的純文字文字場景 import 進入 Leo Editor 編輯環境. \n Leo Editor File -> Import Files 可以導入 .simscene.xml 場景檔案, 但解讀 XML 節點的設定位於 Leo Editor 系統 Settings -> LeoSettings.leo 檔案中的 @data import-xml-tags. 下列設定以 CoppeliaSim, environment, dynamics, simulation, camera, dummy, shape 與 mesh 作為第一階節點 tags. \n @data import-xml-tags 也可以放在各 Leo Editor 專案檔案中的 ＠settings 節點下, 設定完成存檔後, 重新開啟已經設定 @data import-xml-tags 的專案檔, 即可利用 Import Files 輸入 .simscene.xml 檔案之後, 根據 import-xml-tags 中的 tag 設定解讀 .xml 中的內容. \n \n 在上述 @data import-xml-tags 場景節點的設定下,\xa0 import MTB 機械手臂的 Leo Editor 畫面, 分別導入 simple 與 exhaustive 格式的場景. \n \n 除了 Leo Editor 也可以使用  XmlNotepad  編輯 XML 格式場景 ( XmlNotepad.7z ).", 'tags': '', 'url': 'w11 任務.html'}, {'title': 'XML', 'text': 'CoppeliaSim 檔案格式: \n https://www.coppeliarobotics.com/helpFiles/en/xmlFormat.htm \n UI 圖形介面格式: \n https://www.coppeliarobotics.com/helpFiles/en/simUI-widgets.htm \n Collada 輸出入插件: \n https://www.coppeliarobotics.com/helpFiles/en/colladaPlugin.htm \n 原始碼:  https://github.com/CoppeliaRobotics/simExtCollada \n URDF  輸入插件: \n https://www.coppeliarobotics.com/helpFiles/en/urdfPlugin.htm \xa0 \n 原始碼:  https://github.com/CoppeliaRobotics/simExtURDF \n', 'tags': '', 'url': 'XML.html'}, {'title': 'STL', 'text': 'https://github.com/proverbialsunrise/pySTL  是採 Python2 編寫的 STL 零件檔案編輯程式, 改為 Python3 格式後的主要程式碼為  pySTL.py , 而應用範例程式則為  sample.py . \n 由於利用 CoppeliaSim 中的 XML 檔案格式建立場景, 需要編修對應的零件 STL 檔案, 並根據場景組件的樹狀結構建立動態模擬系統. 此處將設法利用 pySTL 編輯從 Solvespace、NX 與 Onshape 所轉出的 STL 零件檔案. \n https://en.wikipedia.org/wiki/STL_(file_format) \n https://docs.fileformat.com/cad/stl/ \n https://github.com/proverbialsunrise/pySTL \n https://github.com/taxpon/pymesh \n https://github.com/timzhang642/3D-Machine-Learning \n https://github.com/WoLpH/numpy-stl/', 'tags': '', 'url': 'STL.html'}, {'title': 'NX', 'text': '多重啟動可攜程式與 NX: \n 將各 NX 版本的啟動整合至不同的 start.bat 檔案中. \n \n 設定啟動 NX12 所需的環境變數: \n \n 設定認證用的伺服主機: \n \n 使用英文介面, 並將啟動 NX 所需的指令搜尋路徑整合到 path: \n \n 啟動 NX 所需的環境變數與指令搜尋路徑設定完成後, 利用 ugraf.exe 開啟 NX: \n \n https://www.plm.automation.siemens.com/global/en/products/nx/ \n https://www.plm.automation.siemens.com/global/en/products/nx/nx-for-design.html \n https://en.wikipedia.org/wiki/Siemens_NX \n View Commands  ( Video ): \n Zoom in and out \xa0\xa0\xa0 (roll mouse wheel) \xa0\xa0\xa0 MB2 3D Orbit \xa0\xa0\xa0 (move mouse while holding in middle mouse wheel) \xa0\xa0\xa0 MB2 Pan \xa0\xa0\xa0 (move mouse and right click button) \xa0\xa0\xa0 MB2 + MB3 Twist view \xa0\xa0\xa0 MB2 + Slide along edges of screen Align view \xa0\xa0\xa0 F8 \n', 'tags': '', 'url': 'NX.html'}, {'title': 'NX3', 'text': 'NX3 Document  (for internal use only) \n 因為 NX 從 NX10 之後才支援 NXOpen for Python, 在 NX3 環境希望利用 Python 編寫延伸程式, 可以透過 UGOpen C 將延伸程式編譯為 Python 可以呼叫執行的動態連結程式庫, 然後間接透過 Python 驅動 NX3 的零組件延伸應用. \n 相關說明位於:  https://github.com/mdecycu/cd2022_guide/tree/main/downloads/nx3_c_pyd  (2004 年採用  Netbean  作為 IDE) \n 至於在 Windows 操作系統編譯 C/C++ 的環境, 則可以 結合 VSCode 與 MSYS2 , 用於 NXOpen C/C++ 與 Python 的延伸開發. \n', 'tags': '', 'url': 'NX3.html'}, {'title': 'NX12', 'text': 'NX12 於 2017.10 釋出, 完整安裝容量約 18 GB. \n NX 自 NX10 之後支援 NXOpen Python API: \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/common/en_US/graphics/fileLibrary/nx/nxopen/nxopen_getting_started_v12.pdf \n https://docs.plm.automation.siemens.com/data_services/resources/nx/10/nx_api/en_US/custom/nxopen_python_ref \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref \n 利用  https://github.com/cjrh/easycython  將 .pyx 轉為 .pyd 後, 由 .py 導入後執行, 可 提升  Python 程式的執行速度. ( 參考 ) \n 以下內容取自  Getting started with NX Open for NX12 . \n NX Open is an Application Programming Interface (API) that lets you write programs to customize or extend NX. \n The benefit is that applications created this way can often speed up repetitive tasks, and capture important design process knowledge. \n There is a broad range of NX Open functions, which provide capabilities like: \n \n Creating part geometry, assemblies, drawings, and CAE and CAM objects \n Cycling through the objects in a part file, reading information or performing various operations on them \n Creating custom user interfaces that allow users to select objects and enter data \n \n Some typical applications of these functions are: \n \n Creating part geometry or drawings according to your local standards \n Importing data from other sources, outside of NX \n Reading data from objects in a part file, and writing it out in some form of report \n Building custom applications to make processes faster or easier to understand \n \n Of course, these are just a few examples of what is possible. You can probably think of many little repetitive processes that you would like to automate to speed up your work or standardize your output. \n NXOpen C refrence guide \n NXOpen Python reference guide \n ListingWindow \n https://support.industrysoftware.automation.siemens.com/gtac.shtml \n References: \n cd2022_uarm_nx12_imported.7z \n https://slideplayer.com/slide/11624773/ \n NX Customization and Programming Discussion \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/common/en_US/graphics/fileLibrary/nx/nxopen/nxopen_getting_started_v12.pdf \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/common/en_US/graphics/fileLibrary/nx/snap/SNAP_Getting_Started_v12.pdf \n', 'tags': '', 'url': 'NX12.html'}, {'title': 'NX12_API', 'text': '假如希望套用 NX12 的 Python Journal 程式錄製, 首先需要將操作過程的程式錄製類別從內建的 VB 轉為 Python. \n Journal 錄製程式類別的設定, 位於 File -> Preferences -> User Interfaces -> Tools -> Journal -> Python. \n 選定採 Python 格式錄製操作過程 Journal 之後, 就可以利用上方下拉式功能表最右方的 Toolbar Options 將 Menu 功能表開啟, 然後透過 Menu -> Tools -> Journal -> Record 選擇將 NX12 設計繪圖的操作過程以 NXOpen Python API 程式進行錄製, 完成後則可以透過 Menu -> Tools -> Journal -> Play 執行. \n 選擇 Record 之後, 跳出標題為 Journal Record 的視窗, 內容如下: \n Some NX commands are not recorded. Therefore, replay many not produce the same results as the interactive NX session. \n Replay of Journals recorded in VB, C# are supported only on Windows. Replay of journals recorded in Python are supported on both Windows and Linux. \n To execute Journals recorded in other languages and/or on Linux, first create executable and then use the File-> Execute -> NXOpen command. \n Refer to on-line Help documentation for further information. \n 表示: \n \n NXOpen API 錄製程式可能無法將全部互動操作細節還原 \n 採 VB 及 C# 錄製的程式只能在 Windows 執行, 而 Python 格式的程式可以在 Windows 與 Linux 操作系統執行 \n 採 C/C++ 及 Java 錄製的程式, 經過編譯後, 可利用 File -> Execute -> NX Open 選單執行 \n \n', 'tags': '', 'url': 'NX12_API.html'}, {'title': 'NX1980', 'text': "NX1980 於 2021.06 釋出, 完整安裝容量約 28 GB. \n NX1980 參考頁面: \n 有關 Siemens NX 的歷史, 請參考  https://en.wikipedia.org/wiki/Siemens_NX \n https://mde.tw/cd2022/content/NX1980.html \n 假如在系上網段, 可直接從  http://wcm.cycu.org:88  下載. \n http://wcm.cycu.org:88  中目前有三個與可攜 Python 程式有關的檔案, 有何差別, 建立的目的為何? \n 請注意: 以下的 .7z 檔案下載, 只允許在系上網段上下載 . \n compile_copsim_cd2022.7z \xa0(file size: 5 GB, extracted size: 17.3 GB, 包含除了 NX1980 之外的所有課程相關可攜程式套件, 是專門為  cd2022  課程學員打造的套件). \n portable_python_wcm2022.7z  (file size: 513 MB, extracted size: 17.3 G, 這是專門為  wcm2022  課程打造的可攜程式套件, 適合選修學員下載後在任何 Windows 10 中以隨身碟啟動後操作) \n drive.7z  (file size: 2.6 MB, extracted size: 10 MB, 只包含 PUTTY, tcc, wscite 與 tmp 目錄, 採用 Hybrid 方式設定, 可與目前電腦輔助設計室中 SSD 硬碟所安裝的 Python 3.9.5 與  Portablegit  結合, 使用者只需自行設定啟動後的 home_ipv6 目錄與 home_ipv6/Desktop 目錄後即可以最輕薄便捷的方式將 SSH key 存入隨身碟, 並將個人與分組倉儲存入隨身碟啟動後的 tmp 目錄進行操作). \n 問題: \n http://wcm.cycu.org:88  是如何建置的? (採純 IPv6 設定, 且只允許特定網段下載) \n 使用  Nginx , 採用如下設定: \n worker_processes  1;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        # port 80 僅開啟 IPv6 網路連線\n        listen       [::]:80 default ipv6only=on;\n        # 伺服器的符號名稱\n        server_name  xxx.xxxx.xxx;\n        return       301 https://$server_name$request_uri;\n    }\n\n   server {\n       # 同時開啟 IPv4 與 IPv6 連線, port 設為 88\n        listen       [::]:88 ipv6only=off;\n        listen       88;\n       # 允許系上 IPv4 網段連線\n        allow 140.xxx.xx.0/24;\n       # 允許特定單一 IPv4 電腦連線\n        allow xxx.xxx.xxx.xx;\n       # 允許系上 IPv6 網段連線\n        allow 2001:xxx:xxxx:xx::0/32;\n       # 其餘網段禁止連線\n        deny all;\n        location / {\n            # 根目錄設定\n            root X:/xxxxxx/xxxx/spring2022;\n            }\n        # 開啟 autoindex, 連線後會列出目錄下所有檔案內容\n        autoindex on;\n    }\n} \n 可攜 NX1980 是如何建立的? \n 利用  UniExtract2  將 NX1980 安裝檔案解開後, 透過批次檔案設定啟動. \n 如何讓 NX1980 認證伺服器 IPv6 相容? \n 開啟伺服器的 IPv6 網路連線. \n Siemens NX 套件更新頻率? \n 請參見  Updating the NX Installation . \n 每 6 個月釋出一個大改版, 每個月則各有一次小改版. \n NX1980 為 2021/06 釋出的版本. 目前 2022/03 最新版本為 2007 系列 ( What's new 2022/02 影片 ), 其他各版資訊請參考  https://nxcadtips.com/docs/list-of-nx-versions-with-documentation-links/ \n 如何學習利用 NX1980 進行 3D 零組件設計繪圖? \n NX1847 nx_help \n NX1980 線上 Documentation \n NX1855-1919 零組件設計繪圖 教學影片 \n 此一系列教學影片共有 38 個影片檔, 請各大組學員分別認領五個教學影片後, 以 Wink 製作教學影片後, 先將影片放入各自的 cd2022 網站中的 NX1980 H1 頁面中, 然後再整合至各小組與大組的協同網站中. \n 有關電腦輔助設計室 IPv6 網路設定流程, 可以利用手機參考 設定教學 後, 利用隨身碟中的 批次檔案 進行設定. \n 此階段的 NX1980 uArm 機械手臂零組件繪圖目的, 希望能以 NX1980 繪製 uArm ( Onshpae 中的 uArm 組立檔 , 使用者可以在手機中安裝 Onshpe App ( Android ,  iPhone ) 後開啟 uArm 組立檔) \n cd2022_uarm_nx12_imported.7z \n NX1980 如何取得啟動授權? \n 系上購買的 NX1980 教育版是透過網路連線取得啟動授權, 意即啟動 NX1980 時, 必須連接到系上的伺服器取得授權後, 才能開啟. \n 假如是在校外, 可以透過 IPv4 或 IPv6 網路連線取得授權, 若在協同產品設計實習上課時段, 則只能透過 IPv6 協定連網, 因此使用者可以在 start_NX1980.bat 多台授權伺服器如下: \n set SPLM_LICENSE_SERVER=port@IPv4_server_address;port@[IPv6_server_address] \n 就能同時在不同網路連線情況下, 啟動 NX1980. \n 以下的 bat 檔案, 能夠同時啟動 Python, Msys2 以及 NX1980: \n start_ipv6_nx1980_bat.txt \n 其中 Msys2 可用來編譯 Solvespace、SciTE、Fossil SCM 以及 CoppeliaSim, Python 可用來啟動個人動態與靜態網頁, 並透過 Leo Editor 編輯 Reveal.js 簡報. \n", 'tags': '', 'url': 'NX1980.html'}, {'title': 'Start_NX1980', 'text': 'NX1980 series 為 2021.06 的版本. \n 啟動 NX1980 全部模組, 容量約 28.6 GB. \n start_nx1980_all.bat \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\n%Disk%:\n\nset HomePath=%Disk%:\\home_mdecourse\nset HomeDrive=%Disk%:\\home_mdecourse\nset Home=%Disk%:\\home_mdecourse\nset USERPROFILE=%Disk%:\\home_mdecourse\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Disk%:\\py373\\DLLs;%Disk%:\\py373\\Lib;%Disk%:\\py373\\Lib\\site-packages;\nset PYTHONHOME=%Disk%:\\py373\n\nset path_python=%Disk%:\\py373;%Disk%:\\py373\\Scripts;\nset path_msys2=%Disk%:\\msys64\\mingw64\\bin;\nREM coreutils is for compiling fossil scm\nset path_coreutils=%Disk%:\\coreutils-5.3.0\\bin;%Disk%:\\depends22_x64;\nset path_tcc=%Disk%:\\tcc;\nset path_cmake=%Disk%:\\cmake-3.10.1-win64-x64\\bin;\nset path_nodejs=Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm;\nset path_git=%Disk%:\\portablegit\\bin;\nset path_xming=%Disk%:\\Xming;\nset path_latex=%%Disk%:\\Pandoc;%Disk%:\\TinyTeX\\bin\\win32;\n\nREM for NX1980\nREM use ipv6\nset FNP_IP_PRIORITY=6\nset UGII_BASE_DIR=%Disk%:\\NX1980\nset TMP_DIR=%Disk%:\\tmp\nset UGII_USER_PROFILE_DIR=%Disk%:\\home_mdecourse\nset START_DIR=%TMP_DIR%\nset UGII_TMP_DIR=%TMP_DIR%\nset UGII_USER_DIR=%Disk%:\\tmp\nset UGII_GROUP_DIR=%Disk%:\\tmp\nset UGII_SITE_DIR=%Disk%:\\tmp\nset UGII_BASE_DIR_CUSTOM=%UGII_BASE_DIR%\n\nset SPLM_LICENSE_SERVER=28000@xxx.xxx.xx.xx;28000@[xxxx:xxx:xxxx:xx::xx];28000@192.168.56.3\nset UGII_LANG=english\n\nset UGII_ROOT_DIR=%UGII_BASE_DIR%\\ugii\nset UGS_LICENSE_BUNDLE=ACD10\nset UGII_TEMPLATE_DIR=%UGII_ROOT_DIR%\\templates\nset ugpath=%UGII_BASE_DIR%\\nxbin;%UGII_BASE_DIR%\\ugii;%UGII_BASE_DIR%\\NXBIN\\Radical;%UGII_BASE_DIR%\\NXBIN\\managed;\n\npath=%ugpath%;%path%;%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\nstart /MIN %Disk%:\\wscite415\\wscite\\SciTE.exe\nstart /MIN %Disk%:\\wscite415\\wscite\\SciTE.exe\n\n%UGII_BASE_DIR%\\ugii\\ugraf.exe -nx | start /d  %UGII_BASE_DIR%\\ugii %UGII_BASE_DIR%\\nxbin\\simcenter3d.exe | %UGII_BASE_DIR%\\ugii\\ugraf.exe -layout | %UGII_BASE_DIR%\\ugii\\ugraf.exe -view | %UGII_BASE_DIR%\\ugii\\ugraf.exe -mechatronics | %UGII_BASE_DIR%\\ugii\\ugraf.exe -simviewer\n\nExit \n 指啟動 NX1980 基本模組, 容量約 15 GB. \n start_nx1980.bat \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\n%Disk%:\n\nset HomePath=%Disk%:\\home_mdecourse\nset HomeDrive=%Disk%:\\home_mdecourse\nset Home=%Disk%:\\home_mdecourse\nset USERPROFILE=%Disk%:\\home_mdecourse\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Disk%:\\py373\\DLLs;%Disk%:\\py373\\Lib;%Disk%:\\py373\\Lib\\site-packages;\nset PYTHONHOME=%Disk%:\\py373\n\nset path_python=%Disk%:\\py373;%Disk%:\\py373\\Scripts;\nset path_msys2=%Disk%:\\msys64\\mingw64\\bin;\nREM coreutils is for compiling fossil scm\nset path_coreutils=%Disk%:\\coreutils-5.3.0\\bin;%Disk%:\\depends22_x64;\nset path_tcc=%Disk%:\\tcc;\nset path_cmake=%Disk%:\\cmake-3.10.1-win64-x64\\bin;\nset path_nodejs=Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm;\nset path_git=%Disk%:\\portablegit\\bin;\nset path_xming=%Disk%:\\Xming;\nset path_latex=%%Disk%:\\Pandoc;%Disk%:\\TinyTeX\\bin\\win32;\n\nREM for NX1980\nREM use ipv6\nset FNP_IP_PRIORITY=6\nset UGII_BASE_DIR=%Disk%:\\NX1980\nset TMP_DIR=%Disk%:\\tmp\nset UGII_USER_PROFILE_DIR=%Disk%:\\home_mdecourse\nset START_DIR=%TMP_DIR%\nset UGII_TMP_DIR=%TMP_DIR%\nset UGII_USER_DIR=%Disk%:\\tmp\nset UGII_GROUP_DIR=%Disk%:\\tmp\nset UGII_SITE_DIR=%Disk%:\\tmp\nset UGII_BASE_DIR_CUSTOM=%UGII_BASE_DIR%\n\nset SPLM_LICENSE_SERVER=28000@xxx.xxx.xx.xx;28000@[xxxx:xxx:xxxx:xx::xx];28000@192.168.56.3\nset UGII_LANG=english\n\nset UGII_ROOT_DIR=%UGII_BASE_DIR%\\ugii\nset UGS_LICENSE_BUNDLE=ACD10,ACD11\nset UGII_TEMPLATE_DIR=%UGII_ROOT_DIR%\\templates\nset ugpath=%UGII_BASE_DIR%\\nxbin;%UGII_BASE_DIR%\\ugii;%UGII_BASE_DIR%\\NXBIN\\Radical;%UGII_BASE_DIR%\\NXBIN\\managed;\n\npath=%ugpath%;%path%;%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\nstart /MIN %Disk%:\\wscite415\\wscite\\SciTE.exe\nstart /MIN %Disk%:\\wscite415\\wscite\\SciTE.exe\n\n%UGII_BASE_DIR%\\ugii\\ugraf.exe -nx\n\nExit \n', 'tags': '', 'url': 'Start_NX1980.html'}, {'title': 'Portable NX1980', 'text': '在 Windows 10 配置可攜 NX1980 程式, 需要: \n \n https://github.com/Bioruebe/UniExtract2 \n https://github.com/wixtoolset/wix3/releases/tag/wix3112rtm \n \n 等兩項工具, UniExtract2 用來解開 SiemensNX-1980_wntx64\\nx\\SiemensNX.msi, 以及 .msi, 而 wix 則用來解開 SiemensNX-1980_wntx64\\nx\\VC_redist.x64.exe, 指令為: \n wix311-binaries\\dark.exe vc_redist.x64.exe -x x64-extracted \n 表示要在 x64-extracted 目錄中取得 x64-extracted\\AttachedContainer\\packages\\vcRuntimeMinimum_amd64\\vc_runtimeMinimum_x64.msi 之後, 再利用 UniExtract2 解開所需的 dll 檔案後, 再放入 NXBIN 目錄. \n 製作 Portable NX1980 的步驟請參考以下影片: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'Portable NX1980.html'}, {'title': 'NX1980_setup', 'text': '以下影片說明如何設定 Journal 存檔格式, 關閉 Product Execellence Program, 並查驗版本與授權使用單位: \n w5_nx_api.txt \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'NX1980_setup.html'}, {'title': 'NXOpen', 'text': "Python 範例: UGOPEN\\SampleNXOpenApplications\\Python \n NXOpen Programmer's Guide  (NX12) \n NXOpen for Python Reference Guide  (NX12 \n NXOpen_spur_gear.c \n Get Started with NXOpen.pdf  (2019) \n NX10:  https://docs.plm.automation.siemens.com/data_services/resources/nx/10/nx_api/en_US/custom/nxopen_python_ref/index.html \n NX12:  https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref/index.html \n NXOpen Python 程式範例: \n nxopen_ex1.py \n nxopen_ex2.py \n nxopen_ex3.py \n Referene: \n NX 各版本技術手冊 \n https://docs.plm.automation.siemens.com/tdoc/nx/1899/nx_help \n NX1980\\NXBIN\\managed\\exceladdin_x64.dll \n ugii_env_ug.dat.txt \n UGII_PYTHONPATH \n UGII_PYTHON_LIBRARY_DIR \n https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2656770  (Design of a KBE system for automatic weld path definition in CAD) \n", 'tags': '', 'url': 'NXOpen.html'}, {'title': 'UGOpen', 'text': '在 NX3 時代, 因為尚未支援採用 Python 編寫 API 延伸程式, 但仍可透過當時的 UGOpen C 編寫為 Python 可呼叫的 pyd 動態連結程式庫, 然後由 Python 程式主導後續的 延伸應用 . \n nx3_for_pyd.c \n nx3_call_pyd.py \n run_nx3_call_pyd.bat \n kmol_readme.txt \n Tiny C Compiler   可以 建立 dll 動態連結程式庫. 這樣有機會利用它來建立 UGOpen API 嗎? \n UGOpen_spur_gear.c \n NX10 之後已經支援 NXOpen Python, 因此接下來可利用  Visual Studio Code  作為 IDE, 用來開發 NX12 之後的 C/C++ 與 Python 整合應用的延伸程式. \n Reference: \n https://iter01.com/614343.html \n Get Started with NX Snap (2017).pdf \n Get Started with NX Snap  (2021) \n NX Custumization and Programming Discussions \n \n', 'tags': '', 'url': 'UGOpen.html'}, {'title': 'NX2008', 'text': 'NX2008 於 2022.01 釋出, 屬於 NX2007 系列 (2021.12 釋出). 容量約 30 GB. \n https://github.com/Bioruebe/UniExtract2  可用來解開 SiemensNX-2008_wntx64\\nx\\SiemensNX.msi, 但必須配合 SiemensNX-2008_wntx64\\nx\\VC_redist.x64.exe 的安裝或解壓縮檔案才能執行. \n 至於要解開\xa0SiemensNX-2008_wntx64\\nx\\VC_redist.x64.exe 中的檔案, 可先利用  https://github.com/wixtoolset/wix3/releases/tag/wix3112rtm  中的 wix311-binaries.zip, 以 wix311-binaries\\dark.exe vc_redist.x64.exe -x x64-extracted, 在 x64-extracted 目錄中取得 x64-extracted\\AttachedContainer\\packages\\vcRuntimeMinimum_amd64\\vc_runtimeMinimum_x64.msi 之後, 再利用 UniExtract2 解開所需的 dll 檔案後, 再放入 NXBIN 目錄. \n NX2008 啟動方式同 NX1980. \n', 'tags': '', 'url': 'NX2008.html'}, {'title': 'Research', 'text': 'NX12, NX1980 與 NX2008 的動態連結程式庫位於 NXBIN\\python 目錄中. \n Implementation of recognition algorithm with NXOpen API in siemens NX  (2017) \n The Method of Automatic Determination of the Types of Spatial Angles in 3D Models of CAD Systems  (2019) \n 能不能利用  NXOpen_Getting_Started_2019.pdf  中的程式庫,\xa0 自動從  cd2022_uarm_nx12_imported.7z  中的零件, 整理出對應的工程圖? 甚至根據這些零件的關鍵尺寸"自動建立對應的參數化零件檔案? \n 根據 這裡 的說明, 利用 Visual Basic 列出零件陣列的程式段為: \n Dim partDimensions() As Annotations.Dimension\npartDimensions = workPart.Dimensions.ToArray  \n 從  NX12 NXOpen Python Reference  (同  http://c.cycu.org ), 與 Annotations.Dimension 相關的資料在 這裡  (或 這裡 ). 可以試著以 Python 根據這裡的 說明 , 透過 os.walk(), 進入 NX 零件目錄後, 逐一取出各個零件檔案, 並以 for 迴圈列出相關幾何尺寸: \n theSession  = NXOpen.Session.GetSession()\nworkPart = theSession.Parts.Work\n \n# 利用迴圈列出 workPark 中的所有尺寸\nfor dim in workPart.Dimensions: \n 也可以從 這裡 的討論中, 取出參考用的 NXOpen Python 程式段: \n     for  dim in workPart.Dimensions:\n    \tlinearDimensionBuilder = workPart.Dimensions.CreateLinearDimensionBuilder(dim)\n    \tmethod = linearDimensionBuilder.Measurement.Method\n    \tlinearDimensionBuilder.Destroy()\n     \n    \t#   check if measurement is cylindrical (see ref: https://docs.plm.automation.siemens.com/data_services/resources/nx/10/nx_api/en_US/custom/nxopen_python_ref/NXOpen.Annotations.DimensionMeasurementBuilderMeasurementMethod.html#NXOpen.Annotations.DimensionMeasurementBuilderMeasurementMethod)\n    \tif method == 5: \n     #report dimension type\n    #\n     \n    import NXOpen\n    import NXOpen.UF\n     \n    theSession = NXOpen.Session.GetSession()\n    theLw = theSession.ListingWindow\n    theUfSession = NXOpen.UF.UFSession.GetUFSession()\n        \n        \n    def main(): \n     \n        workPart = theSession.Parts.Work\n        displayPart = theSession.Parts.Display\n        \n        theLw.Open()\n        \n        for  dim in workPart.Dimensions:\n            theLw.WriteLine(str(type(dim)))\n            if type(dim).__name__ == \'CylindricalDimension\':\n                theLw.WriteLine("Cylindrical dimension found!")\n        theLw.Close()\n        \n        \n    if __name__ == \'__main__\':\n        main() \n References: \n https://www.youtube.com/watch?v=l9Lq3D4AMAQ \n http://www.nxjournaling.com/content/get-all-dimensions-formula-set-value \n http://www.nxjournaling.com/content/expressions-query-existing-expressions \n https://nxopen1.rssing.com/chan-61486962/all_p16.html \n A REINFORCEMENT LEARNING FRAMEWORK FOR THE AUTOMATION OF ENGINEERING DECISIONS IN COMPLEX SYSTEMS \n Design of an engineer-to-order product configuration with CAD integration \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_net/class_n_x_open_1_1_sketch.html#ad0e5c9fa4361cc5f63386b800a14dbf1 \n https://www.nxjournaling.com/content/how-i-stopped-worrying-and-learned-love-help-file \n Object-oriented approach to product design using extended NX Open API \n Multi-objective spur gear design using teaching learning-based optimization and decision-making techniques \n https://github.com/marmakoide/gear-profile-generator \n https://github.com/ZiniuLu/SmartConverter \n https://github.com/chiamingyen/mdeCourse \n NXOpen Spur Gear Creation \n https://www.grobinc.com/spur-gears/ \n The Discussion of Spur Gear Library System Based on UG/Open \n The dlx file must be placed in one of the following locations: 1. From where NX session is launched 2. $UGII_USER_DIR/application 3. For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly recommended. This variable is set to a full directory path to a file \n \n', 'tags': '', 'url': 'Research.html'}, {'title': 'Python API', 'text': '設定 NX Journal 存為 Python 的步驟為: \n File -> Preferences -> User Interface -> Tools -> Journal 將 Journal Language 設為 Python. \n 接著將 Quick Access Toolbar 中的 Menu 功能表開啟. 然後透過 Menu -> Tools -> Journal 選擇 Record, 將 Journal 檔案存至特定目錄區後, 開始錄製操作過程. 選擇 Stop 可以將操作過程存為 Python 程式. 選擇 Play 可以播放已經存檔案的 Python 程式. 選擇 Edit 則可編輯 Python API 程式. \n Create New Model Python API 程式: \n import NXOpen\n\ndef main() : \n\n    theSession  = NXOpen.Session.GetSession()\n    fileNew1 = theSession.Parts.FileNew()\n    fileNew1.TemplateFileName = "model-plain-1-mm-template.prt"\n    fileNew1.UseBlankTemplate = False\n    fileNew1.ApplicationName = "ModelTemplate"\n    fileNew1.Units = NXOpen.Part.Units.Millimeters\n    fileNew1.UsesMasterModel = "No"\n    fileNew1.TemplateType = NXOpen.FileNewTemplateType.Item\n    fileNew1.TemplatePresentationName = "Model"\n    fileNew1.SetCanCreateAltrep(False)\n    fileNew1.NewFileName = "Y:\\\\model1.prt"\n    fileNew1.MakeDisplayedPart = True\n    fileNew1.DisplayPartOption = NXOpen.DisplayPartOption.AllowAdditional\n    nXObject1 = fileNew1.Commit()\n    \n    workPart = theSession.Parts.Work\n    displayPart = theSession.Parts.Display\n    \n    fileNew1.Destroy()\n    theSession.ApplicationSwitchImmediate("UG_APP_MODELING")\n    \nif __name__ == \'__main__\':\n    main() \n List and Edit Expressions: \n import NXOpen\n\ndef main():\n\n    theSession  = NXOpen.Session.GetSession()\n    theUI = NXOpen.UI.GetUI()\n    theMsgBox = theUI.NXMessageBox\n    theMsgBox.Show("window", NXOpen.NXMessageBox.DialogType.Information,"Edit parameter")\n    workPart = theSession.Parts.Work\n    unit1 = workPart.UnitCollection.FindObject("MilliMeter")\n    for i in workPart.Expressions:\n        theMsgBox.Show("window", NXOpen.NXMessageBox.DialogType.Information, i.Name)\n        dim = workPart.Expressions.FindObject(i.Name)\n        # dim type is Expressions\n        workPart.Expressions.EditWithUnits(dim, unit1, "150")\n    theSession.UpdateManager.DoUpdate(0)\n\n    # Insert code here\n\nif __name__ == \'__main__\':\n    main()\n \n Tools -> Expressions 可以列出所有 Expressions \n 在零件繪製過程若將關鍵尺寸以 Expressions 變數命名後, 透過 Python API 進行操控, 並利用 Flask 讓該 Python 程式網際化, 之後再交由前端的 Brython 表單輸入所需要的零組件變數值, 由 AJAX 傳至後端將該零組件轉為 STL 或 STEP 格式後提供下載. 且將客製化後之零組件 PMI 資訊直接顯示在 Brython 前端. 將有助於提升各階段協同產品設計流程效益. \n', 'tags': '', 'url': 'Python API.html'}, {'title': 'AJAX', 'text': '可以將下列 Server 端的 Flask 程式透過 NXOpen Python API 與 NX12、NX1980 或 NX2008 相連, 然後將 uarm 機械手臂所需要的零組件參數, 由 Brython 端輸入, 執行後的結果再傳回網際前端應用. \n Client 端的 Brython: \n # 從 browser 導入 document\nfrom browser import document\n# 使用者可以透過 window 當作介面使用其他 Javascript 功能\nfrom browser import html, window, ajax\n# https://www.brython.info/static_doc/en/ajax.html\n\nbrython_div = document["brython_div"]\noutput = html.DIV("output")\noutput.id = "output"\nbrython_div <= output\n\n# 插入輸入表單\nform = html.FORM()\nA = html.INPUT(type="text", id="A", size="5", name="a", value="2")\nB = html.INPUT(type="text", id="B", size="5", name="b", value="3")\nbutton = html.BUTTON("calculate", id="calculate")\nform <= "a: " + A + html.BR()\nform <= "b: " + B + html.BR()\nbrython_div <= form + button + html.BR()\n\ndef log(*args):\n    output = document["output"]\n    output.html += \', \'.join(str(arg) for arg in args)\n\ndef show(req):\n    document["output"].clear()\n    log(req.text)\n    \ndef on_complete(req):\n    document["output"].clear()\n    if req.status==200 or req.status==0:\n        document["output"] <= req.text\n    else:\n        document["output"] <= "error " + req.text\n         \ndef post(ev):  \n    # a 為 id="A" 輸入欄位中所輸入的值\n    a = document[\'A\'].value\n    # b 為 id="B" 輸入欄位中所輸入的值        \n    b = document[\'B\'].value\n    url = "http://localhost:9448/add_numbers"\n    ajax.post(url,\n             oncomplete=show,\n             data={"a": a, "b":b})\n    # req 從 ajax 模組中的 ajax 類別建立案例, 為一個 ajax 物件        \n    \'\'\'\n    req = ajax.Ajax()\n    # ajax 物件中的 bind 方法, 第一個輸入變數為 evt, \'complete\' 表示 ajax 從伺服器取值完成後, 執行 on_complete 函式\n    req.bind(\'complete\', on_complete)\n    req.open(\'POST\', url, True)\n    req.set_header(\'content-type\',\'application/x-www-form-urlencoded\')\n    req.send({"a": a, "b":b}) \n    \'\'\'\n \n# 使用者按下 id="calculate" 按鈕, 將會執行上述 get("/add_numbers") 函式\ndocument[\'calculate\'].bind(\'click\', post) \n Server 端的 Flask: \n from flask import Flask, render_template, request, jsonify\n# 必須導入 CORS\nfrom flask_cors import CORS\n \n# Initialize the Flask application\napp = Flask(__name__)\nCORS(app, support_credentials=False)\n \n@app.route(\'/\')\ndef index():\n    #return render_template(\'index.html\')\n    return "index"\n \n@app.route(\'/add_numbers\', methods=[\'POST\'])\ndef add_numbers():\n    a = request.form.get(\'a\', 0, type=int)\n    b = request.form.get(\'b\', 0, type=int)\n    #return jsonify(result = a+b)\n    # 必須傳回字串?\n    return str(a+b)\n \nif __name__ == \'__main__\':\n    app.run(debug=True, port=9448) #, ssl_context="adhoc") \n \n', 'tags': '', 'url': 'AJAX.html'}, {'title': 'Applications', 'text': 'Solvespace \n 根據  https://mde.tw/cad2021/content/Compile%20Solvespace.html  中的說明, 可以利用  compile_copsim_for_cd2022.7z  (file size: 5 GB, extracted size: 17.3 GB), 完成編譯. \n 自行編譯 Solvespace 的目的是希望透過  https://www.coppeliarobotics.com/helpFiles/en/xmlFormat.htm  與  https://www.coppeliarobotics.com/helpFiles/en/importExport.htm  的資訊, 自行在 Solvespace 中將組立檔案直接轉入 Coppeliasim 的場景檔案. 其中牽涉如何將 Solvespace 組立件中的零件檔案進行分割後, 以  STL 、 URDF  或  SDF  格式直接轉入 Coppeliasim. \n Onshape \n 以  Onshape 中的 uArm robot . (並未自行繪製零組件而是從  uArmSwiftPro_UP1300_3D.STEP  import) \n', 'tags': '', 'url': 'Applications.html'}, {'title': 'Coppeliasim', 'text': '根據  https://www.coppeliarobotics.com/helpFiles/en/xmlFormat.htm  中有關 simple format 的說明, 可直接將 uArm 機械手臂在 NX 中的零組件, 透過 NXOpen Python API 的程式轉為 CoppeliaSim 的 Scene hierarchy 組合狀態. \n 如此便將 uArm 機械手臂各零組件參數化, 然後直接在 Brython 前端介面設定 uArm 機械手臂的設計參數, 經由 AJAX 將參數送至後端 Flask + NXOpen Python API 伺服器, 產生 uArm 機械手臂組合場景後, 再透過  Legacy Python remote API  或  ZeroMQ Python remote API  控制 uArm 機械手臂 (或利用  Socket 傳遞控制參數 ), 並以客製化 image sensor 的 影像串流 從 Flask server 送至各協同成員的瀏覽器, 或採  Web browser based frontend  方式呈現控制流程. \n https://www.york.ac.uk/media/electronic-engineering/welcome/Simulation%20Challenge%20-%20Python%20Scripting.pdf \n http://hades.mech.northwestern.edu/index.php/Getting_Started_with_the_CoppeliaSim_Simulator \n https://www.doc.ic.ac.uk/~ajd/Robotics/RoboticsResources/questions1.pdf \n https://github.com/stepjam/PyRep \n https://www.diva-portal.org/smash/get/diva2:1569215/FULLTEXT02.pdf \n https://github.com/abr/abr_control \n \n 利用  sympy  根據  meArm Pi Technical Overview  中的說明 (修正錯誤後), 解出 Inverse Kinematics 如下: \n 當已知 manimpulator 端點的座標為 (x, y ,z) 時, 求 theta, ltheta (low arm link theta) 與 utheta (upper arm link theta). 利用  sympy  之前必須先以 pip install sympy 安裝模組. \n mearm_ik_sympy.py \n 使用者可以設法在 CoppeliaSim meArm 場景中驗證上述推導是否正確, 並與  https://github.com/yorkhackspace/meArm  中的控制運算進行比較. \n CoppeliaSim 編譯: \n CoppeliaSim 4.1.0 原始碼編譯專案  (登入 @gm OneDrive 後下載). \n CoppeliaSim 從 4.1.0 的 help files  (只能在系上以 IPv6 網路連線). \n CoppeliaSim 編譯說明 1  (只能在系上以 IPv6 網路連線). \n CoppeliaSim 編譯  (只能在系上以 IPv6 網路連線). \n \n', 'tags': '', 'url': 'Coppeliasim.html'}, {'title': 'Tic-Tat-Toe', 'text': 'https://techvidvan.com/tutorials/python-game-project-tic-tac-toe/ \n https://www.geeksforgeeks.org/tic-tac-toe-game-with-gui-using-tkinter-in-python/ \n UR10e  Robot 透過影像辨識與人進行  Tic-Tat-Toe  遊戲: \n \n cd2022  則希望透過  uArm  robot 搬動 OX 棋子的方式進行  Tic-Tat-Toe  遊戲. \n Tic-Tat-Toe: \n https://www.cormerica.com/robot-tic-tac-toe/ \n Playing_Tic-Tac-Toe_Using_Genetic_Neural_Network_with_Double_transfer_functions.pdf \n \n \n uArm 資料: \n https://www.trossenrobotics.com/uarm-swift-pro.aspx \n https://github.com/uArm-Developer/UArmForArduino \n https://uarm-developer.github.io/UArmForArduino/ \n 且 uArm robot 的零組件要求分別由 Solvespace, NX1980 與 Onshape 執行設計繪圖後轉入 Coppeliasim 場景完成機電資系統模擬. \n 其中 uArm 原型零件採用 3D 列印或雷射切割的製造過程可依照  Realization  頁面中的模擬系統進行, 並包括齒輪減速機的設計運算與  Arduino 伺服馬達的控制模擬 . \n uArm 零組件: \n 以  Onshape 中的 uArm robot . (並未自行繪製零組件而是從  uArmSwiftPro_UP1300_3D.STEP  import) \n cd2022_uarm_nx12_imported.7z \n', 'tags': '', 'url': 'Tic-Tat-Toe.html'}, {'title': 'Threejs', 'text': '假如能夠在 server 端配置 NX + Flask 延伸應用程式, 並讓 Brython 前端程式操控產品設計參數, 完成後的零組件將可在轉為 OBJ 格式後, 直接展示在客戶端的瀏覽器中. \n https://jayconsystems.com/blog/exporting-3d-files-stl-vs-obj-vs-iges-vs-step \n https://threejs.org/ \n \n \n https://www.coppeliarobotics.com/helpFiles/en/externalFrontEnd.htm \n', 'tags': '', 'url': 'Threejs.html'}, {'title': 'run', 'text': '\n \n \n \n  for ggame  \n \n \n \n \n \n \n \n \n  Cango 程式庫  \n \n \n \n \n \n \n \n \n  for Konva 程式庫  \n \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n add 1 to 100 p261 ROC flag PROC flag USA flag Draw Grid Random Rect Rect Walk Rect U Walk Rect rev U Walk 單節貪食蛇 5 個紅點方塊 Snake BSnake auto_guess ball bezier big_lotto brython_kw bunny cango_spur cango_spur1 cango_three_gears clear clock convert_temp deepmerge display_stl draw ex1 ex2 ex3 ex4 fibo fourbar grp2a_2022 grp_2022 guess_a_number hw1_1 hw1_2 Keycode knova1 merge3 power_lotto spur spur_w_form stl_binary_ascii stl_writer Tetris turtle1 turtle2 turtle3 turtle4 turtle5 turtle6 turtle7 turtle8 twl_link_ik webcam websocket ycqsort \n  ######################  editor1 開始 ######################  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div 作為切入位置  \n  這裡的畫布 id 為 brython_div  \n \n  graphics-column is for ggame  \n \n  ######################  editor1 結束 ######################  \n  以下可以開始利用 editor1 的設定編寫對應 Brython 程式  \n \n  以上為內建程式, 頁面可透過 ?src=gist_url 執行  \n  add 1 to 100 開始  \n \n \n', 'tags': '', 'url': 'run.html'}, {'title': 'Brython', 'text': '2a 分組程式練習 \n 2b 分組程式練習 \n 2a w6 blog 查驗  ( 2a 有網誌者 ) |  2a w7 summary 查驗  ( 2a 有網誌者 ) \n 2b w6 blog 查驗  ( 2b 有網誌者 ) |  2b w7 summary 查驗  ( 2b 有網誌者 ) \n \n \n \n \n  for ggame  \n \n \n \n \n \n \n \n \n  Cango 程式庫  \n \n \n \n \n \n \n \n \n  for Konva 程式庫  \n \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  #####  editor1 開始 #####  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div 作為切入位置  \n  這裡的畫布 id 為 brython_div  \n \n  graphics-column is for ggame  \n \n  #####  editor1 結束 #####  \n  以下可以開始利用 editor1 的設定編寫對應 Brython 程式  \n \n \n  印出程式2 \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n Filename:  .py   \n Run   Output   清除輸出區 清除繪圖區 Reload \n \n \n   結束列印程式 2  \n  印出程式3 \n \n \n \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n Filename:  .py   \n Run   Output   清除輸出區 清除繪圖區 Reload \n \n \n   結束列印程式 3 ', 'tags': '', 'url': 'Brython.html'}]};